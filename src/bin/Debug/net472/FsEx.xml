<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FsEx</name></assembly>
<members>
<member name="P:FsEx.DefaultDict`2.Items">
<summary>
 Returns a seq of key and value tuples
</summary>
</member>
<member name="M:FsEx.DefaultDict`2.Pop(`0)">
<summary>
 Get a value and remove it from Dictionary, like *.pop() in Python 
</summary>
</member>
<member name="T:FsEx.DefaultDict`2">
<summary>A System.Collections.Generic.Dictionary with default Values that get created upon accessing a key.
 If accessing a non exiting key , the default function is called to create and set it. 
 Like defaultdict in Python</summary>    
<param name="defaultFun">(unit->'V): The function to create a default Value</param>
</member>
<member name="M:FsEx.IntRef.op_BangPlusPlus(Microsoft.FSharp.Core.FSharpRef{System.Int32})">
<summary>
Increment ref cell and return new incremented integer value
</summary>
</member>
<member name="M:FsEx.Util.t3``3(``0,``1,``2)">
<summary>
Get third element of triple (tuple of three element)
</summary>
</member>
<member name="M:FsEx.Util.t2``3(``0,``1,``2)">
<summary>
Get second element of triple (tuple of three element)
</summary>
</member>
<member name="M:FsEx.Util.t1``3(``0,``1,``2)">
<summary>
Get first element of triple (tuple of three element)
</summary>
</member>
<member name="M:FsEx.Util.op_BarGreaterGreater``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
Apply function ( like |&gt; ) but ignore result. return original input
</summary>
</member>
<member name="M:FsEx.Util.op_BarQmark``1(``0,``0)">
<summary>
Returns the value on the left unless it is null, then it returns the value on the right.
</summary>
</member>
<member name="M:FsEx.NiceString.toNiceStringFull``1(``0)">
<summary>
 Nice formating for floats , some Rhino Objects and sequences of any kind, all items including nested items are printed out.
</summary>
</member>
<member name="M:FsEx.NiceString.toNiceString``1(``0)">
<summary>
 Nice formating for floats , some Rhino Objects and sequences of any kind, first four items are printed out.
 set NiceString.toNiceStringMaxItemsPerSeq to other value if more or less shall be shown (default is 4)
 set NiceString.toNiceStringMaxDepth to change how deep nested lists are printed (default is 2)
</summary>
</member>
<member name="P:FsEx.NiceString.sb">
<summary>
 the internal stringbuilder for recursive function
</summary>
</member>
<member name="M:FsEx.NiceString.singleToString(System.Single)">
<summary>
Formating with automatic precision 
e.g.: 0 digits behind comma if above 1000
</summary>
</member>
<member name="M:FsEx.NiceString.floatToString(System.Double)">
<summary>
Formating with automatic precision 
e.g.: 0 digits behind comma if above 1000 
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.rotate``1(System.Int32,System.Collections.Generic.List{``0})">
<summary>
Shift items poistion  towards the end of ResizeArray. refilling at start from end.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.unzip``2(System.Collections.Generic.List{System.Tuple{``0,``1}})">
<summary>
Split an array of pairs into two arrays.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.zip``2(System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Combine the two arrays into an array of pairs. The two arrays must have equal lengths, 
otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is raised..
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.tryFindIndexi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.List{``0})">
<summary>
Return the index of the first element in the array
that satisfies the given predicate.        
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.tryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return the index of the first element in the array
that satisfies the given predicate.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.singleton``1(``0)">
<summary>
Return an array containing the given element.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.scanBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.List{``0},``1)">
<summary>
Like &lt;c&gt;foldBack&lt;/c&gt;, but return both the intermediary and final results.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.List{``1})">
<summary>
Like &lt;c&gt;fold&lt;/c&gt;, but return the intermediary and final results.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.mapi2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Build a new collection whose elements are the results of applying the given function
to the corresponding elements of the two collections pairwise.  The two input
arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
raised.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.iteri2``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Apply the given function to pair of elements drawn from matching indices in two arrays,
also passing the index of the elements. The two arrays must have the same lengths, 
otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is raised.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.isEmpty``1(System.Collections.Generic.List{``0})">
<summary>
Return True if the given array is empty, otherwise False.        
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.forall2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Test elements of the two arrays pairwise to see if all pairs of elements satisfy the given predicate.
Raise &lt;c&gt;ArgumentException&lt;/c&gt; if the arrays have different lengths.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.foldBack2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1},``2)">
<summary>
Apply a function to pairs of elements drawn from the two collections, right-to-left, 
threading an accumulator argument through the computation.  The two input
arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
raised.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.fold2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,System.Collections.Generic.List{``1},System.Collections.Generic.List{``2})">
<summary>
Apply a function to pairs of elements drawn from the two collections, 
left-to-right, threading an accumulator argument
through the computation.  The two input
arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
raised.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.reduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.List{``0})">
<summary>
Apply a function to each element of the array, threading an accumulator argument
through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then 
computes &lt;c&gt;f i0 (...(f iN-1 iN))&lt;/c&gt;. Raises ArgumentException if the array has size zero.        
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.List{``0})">
<summary>
Apply a function to each element of the array, threading an accumulator argument
through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
then computes &lt;c&gt;f (... (f i0 i1)...) iN&lt;/c&gt;. Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.findIndexi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.List{``0})">
<summary>
Return the index of the first element in the array
that satisfies the given predicate. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if 
none of the elements satisfy the predicate.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.findIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return the index of the first element in the array
that satisfies the given predicate. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if 
none of the elements satisfy the predicate.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Test elements of the two arrays pairwise to see if any pair of element satisfies the given predicate.
Raise ArgumentException if the arrays have different lengths.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.sortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
Sort in place the elements using the key extractor and generic comparison on the keys.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.sort``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},System.Collections.Generic.List{``0})">
<summary>
Sort in place the elements using the given comparison function.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
Build a &lt;c&gt;ResizeArray&lt;/c&gt; from the given elements.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.toSeq``1(System.Collections.Generic.List{``0})">
<summary>
Return a view of the array as an enumerable object.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.ofArray``1(``0[])">
<summary>
Build a &lt;c&gt;ResizeArray&lt;/c&gt; from the given elements.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.toArray``1(System.Collections.Generic.List{``0})">
<summary>
Return a fixed-length array containing the elements of the input &lt;c&gt;ResizeArray&lt;/c&gt;.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.List{``1})">
<summary>
Apply a function to each element of the collection, threading an accumulator argument
through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
then computes &lt;c&gt;f (... (f s i0)...) iN&lt;/c&gt;
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.List{``0},``1)">
<summary>
Apply a function to each element of the array, threading an accumulator argument
through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then 
computes &lt;c&gt;f i0 (...(f iN s))&lt;/c&gt;.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.rev``1(System.Collections.Generic.List{``0})">
<summary>
Return a new array with the elements in reverse order.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Split the collection into two collections, containing the 
elements for which the given predicate returns True and False
respectively.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return a new collection containing only the elements of the collection
for which the given predicate returns True.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array. Return
the array comprised of the results &apos;x&apos; for each element where
the function returns &lt;c&gt;Some(x)&lt;/c&gt;.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Build a new collection whose elements are the results of applying the given function
to the corresponding elements of the two collections pairwise.  The two input
arrays must have the same lengths.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.iter2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Apply the given function to two arrays simultaneously. The
two arrays must have the same lengths, otherwise an Invalid Argument exception is
raised.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.tryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return the first element for which the given function returns True.
Return None if no such element exists.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.tryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to successive elements, returning the first
result where function returns Some(x) for some x.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return the first element for which the given function returns True.
Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Test if all elements of the array satisfy the given predicate.
If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; and &quot;j0...jN&quot;
then computes &lt;c&gt;p i0 &amp;&amp; ... &amp;&amp; p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Test if any element of the array satisfies the given predicate.
If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
then computes &lt;c&gt;p i0 or ... or p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.iteri``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array.  The integer passed to the
function indicates the index of element.        
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.mapi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Collections.Generic.List{``0})">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array. The integer index passed to the
function indicates the index of element being transformed.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array. 
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
Build an array from the given list.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.toList``1(System.Collections.Generic.List{``0})">
<summary>
Build a list from the given array.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.copy``1(System.Collections.Generic.List{``0})">
<summary>
Build a new array that contains the elements of the given array.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.fill``1(System.Collections.Generic.List{``0},System.Int32,System.Int32,``0)">
<summary>
Fill a range of the collection with the given element.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.sub``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
Build a new array that contains the given subrange specified by
starting index and length.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.append``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
<summary>
Build a new array that contains the elements of the first array followed by the elements of the second array.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.concat``1(Microsoft.FSharp.Collections.FSharpList{System.Collections.Generic.List{``0}})">
<summary>
Build a new array that contains the elements of each of the given list of arrays.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.blit``1(System.Collections.Generic.List{``0},System.Int32,System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
Read a range of elements from the first array and write them into the second.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
Create an array by calling the given generator on each index.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.create``1(System.Int32,``0)">
<summary>
Create an array whose elements are all initially the given value.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.set``1(System.Collections.Generic.List{``0},System.Int32,``0)">
<summary>
Set the value of an element in the collection. You can also use the syntax &lt;c&gt;arr.[idx] &lt;- e&lt;/c&gt;.
However this function allows for negtive index too (like python)
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.get``1(System.Collections.Generic.List{``0},System.Int32)">
<summary>
Fetch an element from the collection.  You can also use the syntax &lt;c&gt;arr.[idx]&lt;/c&gt;.
However this function allows for negtive index too (like python)
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.length``1(System.Collections.Generic.List{``0})">
<summary>
Return the length of the collection.  You can also use property &lt;c&gt;arr.Length&lt;/c&gt;.
</summary>
</member>
<member name="M:FsEx.ResizeArrayModule.MinMax.sort3f``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},``0,``0,``0)">
<summary>
* if any are equal then the the order is kept
</summary>
</member>
<member name="T:FsEx.ResizeArrayModule">
<summary>
Generic operations on the type System.Collections.Generic.List, which is called ResizeArray in the F# libraries.
</summary>
</member>
<member name="M:FsEx.StringModule.low1(System.String)">
<summary>
First letter of string to Lowercase
</summary>
</member>
<member name="M:FsEx.StringModule.up1(System.String)">
<summary>
First letter of string to Uppercase
</summary>
</member>
<member name="M:FsEx.StringModule.betweenIncl(System.String,System.String,System.String)">
<summary>
Finds text betwween two strings including delimiters on middle string 
betweenIncl &quot;((&quot; &quot;))&quot; &quot;c((ab))d&quot; = &quot;c&quot;, &quot;((ab))&quot;, &quot;d&quot;
</summary>
</member>
<member name="M:FsEx.StringModule.between(System.String,System.String,System.String)">
<summary>
finds text betwween two strings
between &quot;((&quot; &quot;)&quot; &quot;c((ab)c&quot; = (&quot;c&quot;, &quot;ab&quot;, &quot;c&quot;)
</summary>
</member>
<member name="M:FsEx.StringModule.replace(System.String,System.String,System.String)">
<summary>
inText.Replace(toReplace, replaceWith)
</summary>
</member>
<member name="M:FsEx.StringModule.split2(System.String,System.String)">
<summary>
split string into two elements, if splitter not found first string is same , second string is empty 
like : string.Split( [| spliter |],2, StringSplitOptions.RemoveEmptyEntries) in if xs.Length &gt; 1 then xs.[0],xs.[1] else s,&quot;&quot;
</summary>
</member>
<member name="M:FsEx.StringModule.splitKeep(System.String,System.String)">
<summary>
split string, Keep Empty Entries
like : string.Split([| spliter |], StringSplitOptions.None)  
</summary>
</member>
<member name="M:FsEx.StringModule.split(System.String,System.String)">
<summary>
split string, Remove Empty Entries
like: string.Split([| spliter |], StringSplitOptions.RemoveEmptyEntries)
</summary>
</member>
<member name="M:FsEx.StringModule.before(System.String,System.String)">
<summary>
Returns everytrhing before a given splitting string.
Or full string if splitter not present
</summary>
</member>
<member name="M:FsEx.TypeExtensionsStructs.DateTime.get_nowStrLong.Static">
<summary>
* UTC time, inludes 3 digits of miliseconds
</summary>
</member>
<member name="M:FsEx.TypeExtensionsStructs.Color.AreEqualARGB.Static(System.Drawing.Color,System.Drawing.Color)">
<summary>
Compare two colors only by Alpha, Red, Green and Blue values ignoring other fields such as IsNamedColor
</summary>
</member>
<member name="M:FsEx.TypeExtensionsStructs.Color.EqualsARGB(System.Drawing.Color,System.Drawing.Color)">
<summary>
Compare to another color only by Alpha, Red, Green and Blue values ignoring other fields such as IsNamedColor        
</summary>
</member>
<member name="M:FsEx.TypeExtensionsStructs.Single.get_ToNiceString(System.Single)">
<summary>
 with automatic formating of display precision depending on float size
</summary>
</member>
<member name="M:FsEx.TypeExtensionsStructs.Double.get_ToNiceString(System.Double)">
<summary>
 with automatic formating of display precision depending on float size
</summary>
</member>
<member name="M:FsEx.TypeExtensionsStructs.Double.get_ToInt(System.Double)">
<summary>
converts int to float including rounding: 
int(round(x))
</summary>
</member>
<member name="M:FsEx.TypeExtensionsCollections.[]`1.Slice``1(``0[],System.Int32,System.Int32)">
<summary>
Allows for negative indices too.
</summary>
</member>
<member name="M:FsEx.TypeExtensionsCollections.[]`1.SetItem``1(``0[],System.Int32,``0)">
<summary>
Allows for negtive index too (like python)
</summary>
</member>
<member name="M:FsEx.TypeExtensionsCollections.[]`1.GetItem``1(``0[],System.Int32)">
<summary>
Allows for negtive index too (like python)
</summary>
</member>
<member name="M:FsEx.TypeExtensionsCollections.List`1.SetItem``1(System.Collections.Generic.List{``0},System.Int32,``0)">
<summary>
Allows for negtive index too (like python)
</summary>
</member>
<member name="M:FsEx.TypeExtensionsCollections.List`1.GetItem``1(System.Collections.Generic.List{``0},System.Int32)">
<summary>
Allows for negtive index too (like python)
</summary>
</member>
<member name="M:FsEx.TypeExtensionsCollections.List`1.GetSlice``1(System.Collections.Generic.List{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
Allows for negtive slice index too ( -1 = last element), 
returns a shallow copy including the end index.
</summary>
</member>
<member name="M:FsEx.TypeExtensionsCollections.Dictionary`2.get_Items``2(System.Collections.Generic.Dictionary{``0,``1})">
<summary>
Returns a seq of key and value tuples
</summary>
</member>
<member name="M:FsEx.TypeExtensionsCollections.Dictionary`2.Pop``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
<summary>
Get a value and remove it from Dictionary, like *.pop() in Python         
</summary>
</member>
<member name="M:FsEx.TypeExtensionsCollections.String.Slice(System.String,System.Int32,System.Int32)">
<summary>
Allows for negative indices too.
</summary>
</member>
<member name="M:FsEx.TypeExtensionsCollections.String.GetItem(System.String,System.Int32)">
<summary>
Allows for negtive index too (like python)
</summary>
</member>
<member name="M:FsEx.TypeExtensionsCollections.Object.get_ToNiceString(System.Object)">
<summary>
A property like the ToString() method, 
but with richer formationg for collections.
</summary>
</member>
<member name="M:FsEx.SeqModule.iPrevThisNextLooped``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
Yields looped Seq of (index, previous, this, next): from (0, last, first, second)  upto (lastIndex, second-last, last, first)
Consider &quot;iThisNextNextafterLooped&quot; as faster since the last element is not required from the start on.
</summary>
</member>
<member name="M:FsEx.SeqModule.prevThisNextLooped``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
Yields looped Seq of (previous, this, next): from (last, first, second)  upto (second-last, last, first)
Consider &quot;thisNextNextafterLooped&quot; as faster since the last element is not required from the start on.
</summary>
</member>
<member name="M:FsEx.SeqModule.fastLast``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 faster implemetation of Seq.last till F# 4.8 is out
</summary>
</member>
<member name="M:FsEx.SeqModule.iThisNextAndNextafterLooped``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
Yields looped Seq of (Index of next, this, next, Nextafter): from (1, first, second, third)  upto (0, last, first, second)
</summary>
</member>
<member name="M:FsEx.SeqModule.thisNextAndNextafterLooped``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
Yields looped Seq of (this, next, Nextafter): from (first, second, third)  upto (last, first, second)
</summary>
</member>
<member name="M:FsEx.SeqModule.thisNextAndNextafter``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
Yields Seq of (this, next, Nextafter): from (first, second, third)  upto (third-last, second-last, last)
</summary>
</member>
<member name="M:FsEx.SeqModule.iThisAndNextLooped``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
Yields looped Seq of (this, next) from (first, second)  upto (last, first)
</summary>
</member>
<member name="M:FsEx.SeqModule.thisAndNextLooped``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
Yields looped Seq of (this, next) from (first, second)  upto (last, first)
</summary>
</member>
<member name="M:FsEx.SeqModule.iThisAndNext``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
Yields Seq of (index this, this, next) from (first, second)  upto (second-last, last)
</summary>
</member>
<member name="M:FsEx.SeqModule.thisAndNext``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
Yields Seq of (this, next) from (first, second)  upto (second-last, last)
</summary>
</member>
<member name="M:FsEx.SeqModule.rotate``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
Considers sequence cirular and move elements up or down
 e.g.: rotate +1 [ a, b, c, d] = [ d, a, b, c]
 e.g.: rotate -1 [ a, b, c, d] = [ b, c, d, a]
</summary>
</member>
<member name="M:FsEx.SeqModule.slice``1(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
Allows for negtive slice index too ( -1 = last element), returns a shallow copy including the end index.
</summary>
</member>
<member name="T:FsEx.StructTuples.IntTrip">
<summary>
 Use &apos;==&apos; operater for fast equality (EquatableModule)
</summary>
</member>
<member name="T:FsEx.StructTuples.IntTup">
<summary>
 Use &apos;==&apos; operater for fast equality (EquatableModule)
</summary>
</member>
<member name="M:FsEx.EquatableModule.op_BangEquals``1(``0,``0)">
<summary>
 high performance comparison for non core Struct types
</summary>
</member>
<member name="M:FsEx.EquatableModule.op_EqualsEquals``1(``0,``0)">
<summary>
 high performance comparison for non core Struct types
</summary>
</member>
<member name="M:FsEx.EquatableModule.eq``1(``0,``0)">
<summary>
 high performance comparison for non core Struct types
</summary>
</member>
<member name="M:FsEx.NumericSteping.stepedFloat(System.Double,System.Double)">
<summary>
Converts floats to floats within defined float step sizes, (always rounding down like the int function)
</summary>
</member>
<member name="M:FsEx.NumericSteping.stepedInt(System.Int32,System.Double)">
<summary>
Converts floats to ints within defined integer step sizes, (always rounding down like the int function)
</summary>
</member>
<member name="M:FsEx.NumericSteping.precInt(System.Double,System.Double)">
<summary>
Converts floats to ints, devides by precicion
</summary>
</member>
<member name="M:FsEx.UtilMath.asBinaryString(System.Int32)">
<summary>
Converts an Int32 to a string of 32 characters of &apos;1&apos; or &apos;0&apos;.
</summary>
</member>
<member name="M:FsEx.UtilMath.roundDownToNextLogSteps(System.Int32,System.Double)">
<summary>
Rounds to the next smaller (closer to zero) number on logaritmic scale
Define scale by giving amount of steps(int) to double or half a value.
</summary>
</member>
<member name="M:FsEx.UtilMath.roundUpToNextLogSteps(System.Int32,System.Double)">
<summary>
Rounds to the next biggest (away from zero) number on logaritmic scale.
Define scale by giving amount of steps(int) to double or half a value.
</summary>
</member>
<member name="M:FsEx.UtilMath.normalize``6(``0,``4,``1)">
<summary>
Given the min and max value and a test value,  (val-min) / (max-min)
Returns the relative  position  of the test value between min (= 0.0) and (max = 1.0),
can also be bigger than 1.0
</summary>
</member>
<member name="M:FsEx.UtilMath.toDegrees(System.Double)">
<summary>
converts Angels from Radians to Degrees
</summary>
</member>
<member name="M:FsEx.UtilMath.toRadians(System.Double)">
<summary>
converts Angels from Degrees to Radians
</summary>
</member>
<member name="M:FsEx.UtilMath.areSame(System.Double,System.Double,System.Double)">
<summary>
Compares two floating point numbers to be within a tolerance for equality
</summary>
</member>
<member name="M:FsEx.UtilMath.areSameRel(System.Double,System.Double,System.Double)">
<summary>
Compares two floating point numbers within a relative tolerance for equality. 
The comparing tolerance is calculated as:  relativeTolerance * (the smaller of the two float arguments).
</summary>
</member>
<member name="M:FsEx.UtilMath.randomStandardDeviation(System.Double,System.Double)">
<summary>
given mean  and standardDeviation returns a random value from this Gaussian distribution
if mean is 0 and stDev is 1 then 99% of values are  are within -2.3 to +2.3 ; 70% within -1 to +1
</summary>
</member>
<member name="M:FsEx.UtilMath.isNanOrInf(System.Double)">
<summary>
Test is a floating point value is Infinity or Not a Number
</summary>
</member>
<member name="M:FsEx.UtilMath.ifZero2(System.Double,System.Double)">
<summary>
if second value is 0.0 return first else second
</summary>
</member>
<member name="M:FsEx.UtilMath.ifZero1(System.Double,System.Double)">
<summary>
if first value is 0.0 return second else first
</summary>
</member>
<member name="M:FsEx.UtilMath.op_DivideDot(System.Int32,System.Int32)">
<summary>
Gives a float from int / int division
&lt;c&gt;(float(i)) / (float(j))&lt;/c&gt; 
</summary>
</member>
<member name="M:FsEx.UtilMath.op_MultiplyDot(System.Int32,System.Double)">
<summary>
Allows ints to be multiplied by floats
&lt;c&gt;int(round(float(i) * f))&lt;/c&gt; 
</summary>
</member>
<member name="M:FsEx.UtilMath.floatOfObj``1(``0)">
<summary>
Get Float from any input. This helper enables more generic code in parsing sequences
</summary>
</member>
<member name="M:FsEx.UtilMath.parseFloatEnDe(System.String)">
<summary>
First tries to parses english float (period as decimal separator),
if this fails tries to parse german floats,(comma as decimal separator)
</summary>
</member>
<member name="M:FsEx.ResizeArrayBuilder.resizeArray``1">
<summary>
 Computational Expression:  use &apos;yield&apos; to add alements to a ResizeArray (= Collections.Generic.List).
</summary>
</member>
<member name="P:FsEx.StringBufferBuilder.stringBuffer">
<summary>
Computational Expression:  
use &apos;yield&apos; to append text
and &apos;yield!&apos; (with an exclamation mark)  to append text followed by a new line character.
accepts ints and floats too. (including nice Formating)
</summary>
</member>
<member name="T:FsEx.MaybeBuilder.MaybeBuilder">
<summary>
 The maybe monad. 
</summary>
</member>
<member name="P:FsEx.MaybeBuilder.maybe">
<summary>
 A maybe monad. 
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_DotGreaterDot``1(System.Boolean,``0,``0)">
<summary>
For inner expressions: like this: min &lt;. x .&lt;. y .&lt; max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_DotLessDot``1(System.Boolean,``0,``0)">
<summary>
For inner expressions: like this: min &lt;. x .&lt;. y .&lt; max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_DotGreater``1(System.Boolean,``0,``0)">
<summary>
Point must be at middle of expression: like this: min &lt;. x .&lt; max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_DotLess``1(System.Boolean,``0,``0)">
<summary>
Point must be at middle of expression: like this: min &lt;. x .&lt; max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_GreaterDot``1(``0,``0)">
<summary>
Point must be at middle of expression: like this: min &lt;. x .&lt; max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_LessDot``1(``0,``0)">
<summary>
Point must be at middle of expression: like this: min &lt;. x .&lt; max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_DotGreaterEqualsDot``1(System.Boolean,``0,``0)">
<summary>
for inner expressions: like this: min &lt;. x .&lt;. y .&lt; max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_DotLessEqualsDot``1(System.Boolean,``0,``0)">
<summary>
for inner expressions: like this: min &lt;. x .&lt;. y .&lt; max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_DotGreaterEquals``1(System.Boolean,``0,``0)">
<summary>
Point must be at middle of expression: like this: min &lt;=. x .&lt;= max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_DotLessEquals``1(System.Boolean,``0,``0)">
<summary>
Point must be at middle of expression: like this: min &lt;=. x .&lt;= max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_GreaterEqualsDot``1(``0,``0)">
<summary>
Point must be at middle of expression: like this: min &lt;=. x .&lt;= max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_LessEqualsDot``1(``0,``0)">
<summary>
Point must be at middle of expression: like this: min &lt;=. x .&lt;= max
</summary>
</member>
<member name="T:FsEx.CompareOperators">
<summary>
Operators for chaining compare operations like: &lt;c&gt; 1 &lt;. x .&lt; 9 &lt;/c&gt;
or &lt;c&gt; 0 &lt;. x .&lt;. y .&lt; 99 &lt;/c&gt;
</summary>
</member>
<member name="M:FsEx.MinMaxSort.diff``2(``0,``0)">
<summary>
Gets the positiv differnce between 2 numbers. 
Avoids the integer( or byte) overflow and underflow risk of &quot;abs(a-b)&quot;
</summary>
</member>
<member name="M:FsEx.MinMaxSort.sort3By``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``0,``0)">
<summary>
If any are equal after Function is applied then the the order is kept
</summary>
</member>
<member name="M:FsEx.MinMaxSort.sort3``1(``0,``0,``0)">
<summary>
If any are equal then the the order is kept
</summary>
</member>
<member name="M:FsEx.MinMaxSort.sort2By``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``0)">
<summary>
If they are equal then the the order is kept
</summary>
</member>
<member name="M:FsEx.MinMaxSort.sort2``1(``0,``0)">
<summary>
If they are equal then the the order is kept
</summary>
</member>
<member name="M:FsEx.MinMaxSort.maxBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``0)">
<summary>
If both are equal then the first is returned
</summary>
</member>
<member name="M:FsEx.MinMaxSort.minBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``0)">
<summary>
If both are equal then the first is returned
</summary>
</member>
<member name="M:FsEx.PrintDistribution.sprintDistributionByStepSizeOffset(System.String,System.Double,System.Double,System.Double,System.Collections.Generic.IEnumerable{System.Double})">
<summary>
* units as string (&quot;mm&quot;?) -&gt; scale for Bars ( ~0.5 to ~2.0) -&gt; stepSize (float) -&gt; offset for scale (float) -&gt;list of floats -&gt; returns string
</summary>
</member>
<member name="M:FsEx.PrintDistribution.sprintDistributionByStepSize(System.String,System.Double,System.Double,System.Collections.Generic.IEnumerable{System.Double})">
<summary>
* units as string (&quot;mm&quot;?) -&gt; scale for Bars ( ~0.5 to ~2.0) -&gt; stepSize (float) -&gt; list of floats -&gt; returns string
</summary>
</member>
<member name="M:FsEx.PrintDistribution.sprintDistribution(System.String,System.Double,System.Int32,System.Collections.Generic.IEnumerable{System.Double})">
<summary>
* units as string (&quot;mm&quot;?) -&gt; scale for Bars ( ~0.5 to ~2.0) -&gt; substeps (int 5 to 30) -&gt; list of floats -&gt; returns string
</summary>
</member>
</members>
</doc>

<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FsEx</name></assembly>
<members>
<member name="P:FsEx.DefaultDict`2.Items">
<summary>
 Returns a seq of key and value tuples
</summary>
</member>
<member name="M:FsEx.DefaultDict`2.Pop(`0)">
<summary>
 Get a value and remove it from Dictionary, like *.pop() in Python 
</summary>
</member>
<member name="T:FsEx.DefaultDict`2">
<summary>A System.Collections.Generic.Dictionary with default Values that get created upon accessing a key.
 If accessing a non exiting key , the default function is called to create and set it. 
 Like defaultdict in Python</summary>    
<param name="defaultFun">(unit->'V): The function to create a default Value</param>
</member>
<member name="M:FsEx.IntTrip.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
<summary>
 multiplies x, y and z with precMult  then adds shiftX, shiftY and shiftZ respectively before casting to three integers
</summary>
</member>
<member name="M:FsEx.IntTrip.#ctor(System.Double,System.Double,System.Double,System.Double)">
<summary>
 multiplies x, y and z with precMult before casting to three integers
</summary>
</member>
<member name="T:FsEx.IntTrip">
<summary>
A struct of three integers
use operator (===) for fast equality test
Avoid using this struct in Fsharp.Core functions like: List.contains value. boxing will ocure
Better: List.exists (fun v -&gt; v === value)
</summary>
</member>
<member name="M:FsEx.IntTup.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double)">
<summary>
 multiplies x and y with precMult  then adds shiftX and shiftY respectively before casting to two integers
</summary>
</member>
<member name="M:FsEx.IntTup.#ctor(System.Double,System.Double,System.Double)">
<summary>
 multiplies x and y with precMult before casting to two integers
</summary>
</member>
<member name="T:FsEx.IntTup">
<summary>
A struct of two integers
use operator (===) for fast equality test
Avoid using this struct in Fsharp.Core functions like: List.contains value. boxing will ocure
Better: List.exists (fun v -&gt; v === value)
</summary>
</member>
<member name="M:FsEx.IntRef.op_BangPlusPlus(Microsoft.FSharp.Core.FSharpRef{System.Int32})">
<summary>
Increment ref cell and return new incremented integer value
</summary>
</member>
<member name="M:FsEx.Util.t3``3(``0,``1,``2)">
<summary>
Get third element of triple (tuple of three element)
</summary>
</member>
<member name="M:FsEx.Util.t2``3(``0,``1,``2)">
<summary>
Get second element of triple (tuple of three element)
</summary>
</member>
<member name="M:FsEx.Util.t1``3(``0,``1,``2)">
<summary>
Get first element of triple (tuple of three element)
</summary>
</member>
<member name="M:FsEx.Util.op_BarGreaterGreater``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
Apply function, like |&gt; , but ignore result. 
Return original input
</summary>
</member>
<member name="M:FsEx.Util.op_BarQmark``1(``0,``0)">
<summary>
Returns the value on the left unless it is null, then it returns the value on the right.
</summary>
</member>
<member name="M:FsEx.UtilMath.stepedFloat(System.Double,System.Double)">
<summary>
NumericSteping:Converts floats to floats within defined float step sizes, (always rounding down like the int function)
</summary>
</member>
<member name="M:FsEx.UtilMath.stepedInt(System.Int32,System.Double)">
<summary>
NumericSteping:Converts floats to ints within defined integer step sizes, (always rounding down like the int function)
</summary>
</member>
<member name="M:FsEx.UtilMath.precInt(System.Double,System.Double)">
<summary>
NumericSteping: Converts floats to ints, devides by precicion
</summary>
</member>
<member name="M:FsEx.UtilMath.asBinaryString(System.Int32)">
<summary>
Converts an Int32 to a string of 32 characters of &apos;1&apos; or &apos;0&apos;.
</summary>
</member>
<member name="M:FsEx.UtilMath.roundDownToNextLogSteps(System.Int32,System.Double)">
<summary>
Rounds to the next smaller (closer to zero) number on logaritmic scale
Define scale by giving amount of steps(int) to double or half a value.
</summary>
</member>
<member name="M:FsEx.UtilMath.roundUpToNextLogSteps(System.Int32,System.Double)">
<summary>
Rounds to the next biggest (away from zero) number on logaritmic scale.
Define scale by giving amount of steps(int) to double or half a value.
</summary>
</member>
<member name="M:FsEx.UtilMath.normalize``6(``0,``4,``1)">
<summary>
Given the min and max value and a test value,  (val-min) / (max-min)
Returns the relative  position  of the test value between min (= 0.0) and (max = 1.0),
can also be bigger than 1.0
</summary>
</member>
<member name="M:FsEx.UtilMath.clamp``1(``0,``0,``0)">
<summary>
* min -&gt; max -&gt; value -&gt; clamped value.  to make sure a value is within a given range
</summary>
</member>
<member name="M:FsEx.UtilMath.toDegrees(System.Double)">
<summary>
converts Angels from Radians to Degrees
</summary>
</member>
<member name="M:FsEx.UtilMath.toRadians(System.Double)">
<summary>
converts Angels from Degrees to Radians
</summary>
</member>
<member name="M:FsEx.UtilMath.areSame(System.Double,System.Double,System.Double)">
<summary>
Compares two floating point numbers to be within a tolerance for equality
</summary>
</member>
<member name="M:FsEx.UtilMath.areSameRel(System.Double,System.Double,System.Double)">
<summary>
Compares two floating point numbers within a relative tolerance for equality. 
The comparing tolerance is calculated as:  relativeTolerance * (the smaller of the two float arguments).
</summary>
</member>
<member name="M:FsEx.UtilMath.randomStandardDeviation(System.Double,System.Double)">
<summary>
given mean  and standardDeviation returns a random value from this Gaussian distribution
if mean is 0 and stDev is 1 then 99% of values are  are within -2.3 to +2.3 ; 70% within -1 to +1
</summary>
</member>
<member name="M:FsEx.UtilMath.isNanOrInf(System.Double)">
<summary>
Test is a floating point value is Infinity or Not a Number
</summary>
</member>
<member name="M:FsEx.UtilMath.op_DivideDot(System.Int32,System.Int32)">
<summary>
Gives a float from int / int division
&lt;c&gt;(float(i)) / (float(j))&lt;/c&gt; 
</summary>
</member>
<member name="M:FsEx.UtilMath.op_MultiplyDot(System.Int32,System.Double)">
<summary>
Allows ints to be multiplied by floats
&lt;c&gt;int(round(float(i) * f))&lt;/c&gt; 
</summary>
</member>
<member name="M:FsEx.UtilMath.floatOfObj``1(``0)">
<summary>
Get Float from any input. This helper enables more generic code in parsing sequences
</summary>
</member>
<member name="M:FsEx.UtilMath.parseFloatEnDe(System.String)">
<summary>
First tries to parses english float (period as decimal separator),
if this fails tries to parse german floats,(comma as decimal separator)
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_DotGreaterDot``1(System.Boolean,``0,``0)">
<summary>
For inner expressions: like this: min &lt;. x .&lt;. y .&lt; max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_DotLessDot``1(System.Boolean,``0,``0)">
<summary>
For inner expressions: like this: min &lt;. x .&lt;. y .&lt; max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_DotGreater``1(System.Boolean,``0,``0)">
<summary>
Point must be at middle of expression: like this: min &lt;. x .&lt; max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_DotLess``1(System.Boolean,``0,``0)">
<summary>
Point must be at middle of expression: like this: min &lt;. x .&lt; max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_GreaterDot``1(``0,``0)">
<summary>
Point must be at middle of expression: like this: min &lt;. x .&lt; max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_LessDot``1(``0,``0)">
<summary>
Point must be at middle of expression: like this: min &lt;. x .&lt; max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_DotGreaterEqualsDot``1(System.Boolean,``0,``0)">
<summary>
for inner expressions: like this: min &lt;. x .&lt;. y .&lt; max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_DotLessEqualsDot``1(System.Boolean,``0,``0)">
<summary>
for inner expressions: like this: min &lt;. x .&lt;. y .&lt; max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_DotGreaterEquals``1(System.Boolean,``0,``0)">
<summary>
Point must be at middle of expression: like this: min &lt;=. x .&lt;= max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_DotLessEquals``1(System.Boolean,``0,``0)">
<summary>
Point must be at middle of expression: like this: min &lt;=. x .&lt;= max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_GreaterEqualsDot``1(``0,``0)">
<summary>
Point must be at middle of expression: like this: min &lt;=. x .&lt;= max
</summary>
</member>
<member name="M:FsEx.CompareOperators.op_LessEqualsDot``1(``0,``0)">
<summary>
Point must be at middle of expression: like this: min &lt;=. x .&lt;= max
</summary>
</member>
<member name="T:FsEx.CompareOperators">
<summary>
Operators for chaining compare operations like: &lt;c&gt; 1 &lt;. x .&lt; 9 &lt;/c&gt;
or &lt;c&gt; 0 &lt;. x .&lt;. y .&lt; 99 &lt;/c&gt;
</summary>
</member>
<member name="M:FsEx.MinMaxSort.diff``2(``0,``0)">
<summary>
Gets the positiv differnce between 2 numbers. 
Avoids the integer( or byte) overflow and underflow risk of &quot;abs(a-b)&quot;
</summary>
</member>
<member name="M:FsEx.MinMaxSort.sort3By``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``0,``0)">
<summary>
If any are equal after Function is applied then the the order is kept
</summary>
</member>
<member name="M:FsEx.MinMaxSort.sort3``1(``0,``0,``0)">
<summary>
If any are equal then the the order is kept
</summary>
</member>
<member name="M:FsEx.MinMaxSort.sort2By``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``0)">
<summary>
If they are equal then the the order is kept
</summary>
</member>
<member name="M:FsEx.MinMaxSort.sort2``1(``0,``0)">
<summary>
If they are equal then the the order is kept
</summary>
</member>
<member name="M:FsEx.MinMaxSort.maxBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``0)">
<summary>
If both are equal then the first is returned
</summary>
</member>
<member name="M:FsEx.MinMaxSort.minBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``0)">
<summary>
If both are equal then the first is returned
</summary>
</member>
<member name="M:FsEx.TypeExtensionsObject.Object.get_ToNiceString(System.Object)">
<summary>
A property like the ToString() method, 
But with richer formationg for collections
</summary>
</member>
<member name="M:FsEx.TypeExtensionsObject.printFull``1(``0)">
<summary>
 prints FsEx.NiceString.toNiceStringFull
</summary>
</member>
<member name="M:FsEx.TypeExtensionsObject.print``1(``0)">
<summary>
 prints FsEx.NiceString.toNiceString
</summary>
</member>
<member name="M:FsEx.NiceString.toNiceStringFull``1(``0)">
<summary>
 Nice formating for floats , some Rhino Objects and sequences of any kind, all items including nested items are printed out.
</summary>
</member>
<member name="M:FsEx.NiceString.toNiceStringFullWithFormater``1(``0,Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.FSharpOption{System.String}})">
<summary>
 Nice formating for floats , some Rhino Objects and sequences of any kind, all items including nested items are printed out.
 use externalFormater for types defined in other assemblies alowed
</summary>
</member>
<member name="M:FsEx.NiceString.toNiceString``1(``0)">
<summary>
 Nice formating for floats , some Rhino Objects and sequences of any kind, first four items are printed out.
 set NiceString.toNiceStringMaxItemsPerSeq to other value if more or less shall be shown (default is 4)
 set NiceString.toNiceStringMaxDepth to change how deep nested lists are printed (default is 2)
</summary>
</member>
<member name="M:FsEx.NiceString.toNiceStringWithFormater``1(``0,Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.FSharpOption{System.String}})">
<summary>
 Nice formating for floats  and sequences of any kind, first four items are printed out.
 use externalFormater for types defined in other assemblies alowed
 set NiceString.toNiceStringMaxItemsPerSeq to other value if more or less shall be shown (default is 4)
 set NiceString.toNiceStringMaxDepth to change how deep nested lists are printed (default is 2)
</summary>
</member>
<member name="P:FsEx.NiceString.sb">
<summary>
 The internal stringbuilder for recursive function
</summary>
</member>
<member name="M:FsEx.NiceString.singleToString(System.Single)">
<summary>
Formating with automatic precision 
e.g.: 0 digits behind comma if above 1000
</summary>
</member>
<member name="M:FsEx.NiceString.floatToString(System.Double)">
<summary>
Formating with automatic precision 
e.g.: 0 digits behind comma if above 1000 
</summary>
</member>
<member name="M:FsEx.TypeExtensionsStructs.DateTime.get_nowStrLong.Static">
<summary>
Current UTC date and time as yyyy-MM-dd_HH-mm-fff. inludes 3 digits of miliseconds
</summary>
</member>
<member name="M:FsEx.TypeExtensionsStructs.DateTime.get_nowStrUtc.Static">
<summary>
Current UTC date and time as yyyy-MM-dd_HH-mm_UTC
</summary>
</member>
<member name="M:FsEx.TypeExtensionsStructs.DateTime.get_nowStr.Static">
<summary>
Current local date and time as yyyy-MM-dd_HH-mm
</summary>
</member>
<member name="M:FsEx.TypeExtensionsStructs.DateTime.get_todayStr.Static">
<summary>
Current date as yyyy-MM-dd
</summary>
</member>
<member name="M:FsEx.TypeExtensionsStructs.Single.get_ToNiceString(System.Single)">
<summary>
 with automatic formating of display precision depending on float size
</summary>
</member>
<member name="M:FsEx.TypeExtensionsStructs.Double.get_ToNiceString(System.Double)">
<summary>
 with automatic formating of display precision depending on float size
</summary>
</member>
<member name="M:FsEx.TypeExtensionsStructs.Double.get_ToInt(System.Double)">
<summary>
converts int to float including rounding: 
int(round(x))
</summary>
</member>
<member name="M:FsEx.Color.makeDarker(System.Double,System.Drawing.Color)">
<summary>
 * make a color darker by perecentage (value between 0.0 to 1.0) (1.0 = black, 0.0 = current color) 
</summary>
</member>
<member name="M:FsEx.Color.makeLighter(System.Double,System.Drawing.Color)">
<summary>
 * make a color lighter by perecentage (value between 0.0 to 1.0) (1.0 = white, 0.0 = current color) 
</summary>
</member>
<member name="M:FsEx.Color.randomColorForRhino">
<summary>
 *generates a Random color with high saturation probability, exluding yellow colors
</summary>
</member>
<member name="M:FsEx.Color.randomColor">
<summary>
 *generates a Random color 
</summary>
</member>
<member name="M:FsEx.Color.HSLfromColor(System.Drawing.Color)">
<summary>
 *Given a Drawing.Color , returns Hue,Saturation,Luminance in range of 0.0-1.0
</summary>
</member>
<member name="M:FsEx.Color.colorFromInterval(System.Double)">
<summary>
 val = value between 0.0 to 1.0, will get clamped
 returns color value from gradient blue to green  to yellow to red, excludes purple        
</summary>
</member>
<member name="M:FsEx.Color.colorFromHSL(System.Double,System.Double,System.Double)">
<summary>
 *Given Hue,Saturation,Luminance in range of 0.0 to 1.0, returns a Drawing.Color 
</summary>
</member>
<member name="M:FsEx.TypeExtensionsColor.Color.AreEqualARGB.Static(System.Drawing.Color,System.Drawing.Color)">
<summary>
Compare two colors only by Alpha, Red, Green and Blue values ignoring other fields such as IsNamedColor
</summary>
</member>
<member name="M:FsEx.TypeExtensionsColor.Color.EqualsARGB(System.Drawing.Color,System.Drawing.Color)">
<summary>
Compare to another color only by Alpha, Red, Green and Blue values ignoring other fields such as IsNamedColor        
</summary>
</member>
<member name="M:FsEx.String.low1(System.String)">
<summary>
First letter of string to Lowercase
</summary>
</member>
<member name="M:FsEx.String.up1(System.String)">
<summary>
First letter of string to Uppercase
</summary>
</member>
<member name="M:FsEx.String.betweenIncl(System.String,System.String,System.String)">
<summary>
Finds text betwween two strings, includes delimiters on middle string 
betweenIncl between &quot;X&quot; &quot;T&quot; &quot;cXabTk&quot; = &quot;c&quot;, &quot;XabT&quot;, &quot;k&quot;
returns three empty strings if not both found 
</summary>
</member>
<member name="M:FsEx.String.between(System.String,System.String,System.String)">
<summary>
finds text betwween two strings
between &quot;X&quot; &quot;T&quot; &quot;cXabTk&quot; = &quot;c&quot;, &quot;ab&quot;, &quot;k&quot;
returns three empty strings if not both found 
</summary>
</member>
<member name="M:FsEx.String.replace(System.String,System.String,System.String)">
<summary>
Replaces parts of the charcters in a string , inText.Replace(toReplace, replaceWith)
</summary>
</member>
<member name="M:FsEx.String.trimStart(System.String)">
<summary>
Trims whitspace at start, like s.TrimStart()
</summary>
</member>
<member name="M:FsEx.String.trimEnd(System.String)">
<summary>
Trims whitspace at end, like s.TrimEnd()
</summary>
</member>
<member name="M:FsEx.String.trim(System.String)">
<summary>
Trims whitspace at beginnig and end, like s.Trim()
</summary>
</member>
<member name="M:FsEx.String.split2(System.String,System.String)">
<summary>
split string into two elements, if splitter not found first string is same , second string is empty 
like : string.Split( [| spliter |],2, StringSplitOptions.RemoveEmptyEntries) in if xs.Length &gt; 1 then xs.[0],xs.[1] else s,&quot;&quot;
</summary>
</member>
<member name="M:FsEx.String.splitKeep(System.String,System.String)">
<summary>
split string, Keep Empty Entries
like : string.Split([| spliter |], StringSplitOptions.None)  
</summary>
</member>
<member name="M:FsEx.String.split(System.String,System.String)">
<summary>
split string, Remove Empty Entries
like: string.Split([| spliter |], StringSplitOptions.RemoveEmptyEntries)
</summary>
</member>
<member name="M:FsEx.String.before(System.String,System.String)">
<summary>
Returns everytrhing before a given splitting string.
Or full string if splitter not present
</summary>
</member>
<member name="M:FsEx.TypeExtensionsString.String.Slice(System.String,System.Int32,System.Int32)">
<summary>
Allows for negative indices too.
</summary>
</member>
<member name="M:FsEx.TypeExtensionsString.String.GetItem(System.String,System.Int32)">
<summary>
Allows for negtive index too (like Python)
</summary>
</member>
<member name="M:FsEx.TypeExtensionsArray.[]`1.Slice``1(``0[],System.Int32,System.Int32)">
<summary>
Allows for negative indices too.
The resulting array includes the end index.
</summary>
</member>
<member name="M:FsEx.TypeExtensionsArray.[]`1.SetItem``1(``0[],System.Int32,``0)">
<summary>
Allows for negtive index too (like Python)
</summary>
</member>
<member name="M:FsEx.TypeExtensionsArray.[]`1.GetItem``1(``0[],System.Int32)">
<summary>
Allows for negtive index too (like Python)
</summary>
</member>
<member name="M:FsEx.TypeExtensionsArray.[]`1.get_Last``1(``0[])">
<summary>
 last item in Array
</summary>
</member>
<member name="M:FsEx.TypeExtensionsArray.[]`1.get_LastIndex``1(``0[])">
<summary>
 like this.Length - 1
</summary>
</member>
<member name="M:FsEx.ResizeArray.rotate``1(System.Int32,System.Collections.Generic.List{``0})">
<summary>
Considers List cirular and move elements up or down
 e.g.: rotate +1 [ a, b, c, d] = [ d, a, b, c]
 e.g.: rotate -1 [ a, b, c, d] = [ b, c, d, a]
</summary>
</member>
<member name="M:FsEx.ResizeArray.unzip``2(System.Collections.Generic.List{System.Tuple{``0,``1}})">
<summary>
Split an array of pairs into two arrays.
</summary>
</member>
<member name="M:FsEx.ResizeArray.zip``2(System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Combine the two arrays into an array of pairs. The two arrays must have equal lengths, 
otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is raised..
</summary>
</member>
<member name="M:FsEx.ResizeArray.tryFindIndexi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.List{``0})">
<summary>
Return the index of the first element in the array
that satisfies the given predicate.        
</summary>
</member>
<member name="M:FsEx.ResizeArray.tryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return the index of the first element in the array
that satisfies the given predicate.
</summary>
</member>
<member name="M:FsEx.ResizeArray.singleton``1(``0)">
<summary>
Return an array containing the given element.
</summary>
</member>
<member name="M:FsEx.ResizeArray.scanBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.List{``0},``1)">
<summary>
Like &lt;c&gt;foldBack&lt;/c&gt;, but return both the intermediary and final results.
</summary>
</member>
<member name="M:FsEx.ResizeArray.scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.List{``1})">
<summary>
Like &lt;c&gt;fold&lt;/c&gt;, but return the intermediary and final results.
</summary>
</member>
<member name="M:FsEx.ResizeArray.mapi2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Build a new collection whose elements are the results of applying the given function
to the corresponding elements of the two collections pairwise.  The two input
arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
raised.
</summary>
</member>
<member name="M:FsEx.ResizeArray.iteri2``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Apply the given function to pair of elements drawn from matching indices in two arrays,
also passing the index of the elements. The two arrays must have the same lengths, 
otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is raised.
</summary>
</member>
<member name="M:FsEx.ResizeArray.isEmpty``1(System.Collections.Generic.List{``0})">
<summary>
Return True if the given array is empty, otherwise False.        
</summary>
</member>
<member name="M:FsEx.ResizeArray.forall2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Test elements of the two arrays pairwise to see if all pairs of elements satisfy the given predicate.
Raise &lt;c&gt;ArgumentException&lt;/c&gt; if the arrays have different lengths.
</summary>
</member>
<member name="M:FsEx.ResizeArray.foldBack2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1},``2)">
<summary>
Apply a function to pairs of elements drawn from the two collections, right-to-left, 
threading an accumulator argument through the computation.  The two input
arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
raised.
</summary>
</member>
<member name="M:FsEx.ResizeArray.fold2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Apply a function to pairs of elements drawn from the two collections, 
left-to-right, threading an accumulator argument
through the computation.  The two input
arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
raised.
</summary>
</member>
<member name="M:FsEx.ResizeArray.reduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.List{``0})">
<summary>
Apply a function to each element of the array, threading an accumulator argument
through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then 
computes &lt;c&gt;f i0 (...(f iN-1 iN))&lt;/c&gt;. Raises ArgumentException if the array has size zero.        
</summary>
</member>
<member name="M:FsEx.ResizeArray.reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.List{``0})">
<summary>
Apply a function to each element of the array, threading an accumulator argument
through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
then computes &lt;c&gt;f (... (f i0 i1)...) iN&lt;/c&gt;. Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:FsEx.ResizeArray.findIndexi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.List{``0})">
<summary>
Return the index of the first element in the array
that satisfies the given predicate. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if 
none of the elements satisfy the predicate.
</summary>
</member>
<member name="M:FsEx.ResizeArray.findIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return the index of the first element in the array
that satisfies the given predicate. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if 
none of the elements satisfy the predicate.
</summary>
</member>
<member name="M:FsEx.ResizeArray.exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Test elements of the two arrays pairwise to see if any pair of element satisfies the given predicate.
Raise ArgumentException if the arrays have different lengths.
</summary>
</member>
<member name="M:FsEx.ResizeArray.sortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
Sort in place the elements using the key extractor and generic comparison on the keys.
</summary>
</member>
<member name="M:FsEx.ResizeArray.sort``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},System.Collections.Generic.List{``0})">
<summary>
Sort in place the elements using the given comparison function.
</summary>
</member>
<member name="M:FsEx.ResizeArray.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
Build a &lt;c&gt;ResizeArray&lt;/c&gt; from the given elements.
</summary>
</member>
<member name="M:FsEx.ResizeArray.toSeq``1(System.Collections.Generic.List{``0})">
<summary>
Return a view of the array as an enumerable object.
</summary>
</member>
<member name="M:FsEx.ResizeArray.ofArray``1(``0[])">
<summary>
Build a &lt;c&gt;ResizeArray&lt;/c&gt; from the given elements.
</summary>
</member>
<member name="M:FsEx.ResizeArray.toArray``1(System.Collections.Generic.List{``0})">
<summary>
Return a fixed-length array containing the elements of the input &lt;c&gt;ResizeArray&lt;/c&gt;.
</summary>
</member>
<member name="M:FsEx.ResizeArray.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.List{``1})">
<summary>
Apply a function to each element of the collection, threading an accumulator argument
through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
then computes &lt;c&gt;f (... (f s i0)...) iN&lt;/c&gt;
</summary>
</member>
<member name="M:FsEx.ResizeArray.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.List{``0},``1)">
<summary>
Apply a function to each element of the array, threading an accumulator argument
through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then 
computes &lt;c&gt;f i0 (...(f iN s))&lt;/c&gt;.
</summary>
</member>
<member name="M:FsEx.ResizeArray.rev``1(System.Collections.Generic.List{``0})">
<summary>
Return a new array with the elements in reverse order.
</summary>
</member>
<member name="M:FsEx.ResizeArray.partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Split the collection into two collections, containing the 
elements for which the given predicate returns True and False
respectively.
</summary>
</member>
<member name="M:FsEx.ResizeArray.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return a new collection containing only the elements of the collection
for which the given predicate returns True.
</summary>
</member>
<member name="M:FsEx.ResizeArray.choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array. Return
the array comprised of the results &apos;x&apos; for each element where
the function returns &lt;c&gt;Some(x)&lt;/c&gt;.
</summary>
</member>
<member name="M:FsEx.ResizeArray.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Build a new collection whose elements are the results of applying the given function
to the corresponding elements of the two collections pairwise.  The two input
arrays must have the same lengths.
</summary>
</member>
<member name="M:FsEx.ResizeArray.iter2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Apply the given function to two arrays simultaneously. The
two arrays must have the same lengths, otherwise an Invalid Argument exception is
raised.
</summary>
</member>
<member name="M:FsEx.ResizeArray.tryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return the first element for which the given function returns True.
Return None if no such element exists.
</summary>
</member>
<member name="M:FsEx.ResizeArray.tryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to successive elements, returning the first
result where function returns Some(x) for some x.
</summary>
</member>
<member name="M:FsEx.ResizeArray.find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return the first element for which the given function returns True.
Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:FsEx.ResizeArray.forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Test if all elements of the array satisfy the given predicate.
If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; and &quot;j0...jN&quot;
then computes &lt;c&gt;p i0 &amp;&amp; ... &amp;&amp; p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:FsEx.ResizeArray.exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Test if any element of the array satisfies the given predicate.
If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
then computes &lt;c&gt;p i0 or ... or p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:FsEx.ResizeArray.iteri``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array.  The integer passed to the
function indicates the index of element.        
</summary>
</member>
<member name="M:FsEx.ResizeArray.mapi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Collections.Generic.List{``0})">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array. The integer index passed to the
function indicates the index of element being transformed.
</summary>
</member>
<member name="M:FsEx.ResizeArray.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array.
</summary>
</member>
<member name="M:FsEx.ResizeArray.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array. 
</summary>
</member>
<member name="M:FsEx.ResizeArray.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
Build an array from the given list.
</summary>
</member>
<member name="M:FsEx.ResizeArray.toList``1(System.Collections.Generic.List{``0})">
<summary>
Build a list from the given array.
</summary>
</member>
<member name="M:FsEx.ResizeArray.copy``1(System.Collections.Generic.List{``0})">
<summary>
Build a new array that contains the elements of the given array.
</summary>
</member>
<member name="M:FsEx.ResizeArray.fill``1(System.Collections.Generic.List{``0},System.Int32,System.Int32,``0)">
<summary>
Fill a range of the collection with the given element.
</summary>
</member>
<member name="M:FsEx.ResizeArray.sub``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
Build a new array that contains the given subrange specified by
starting index and length.
</summary>
</member>
<member name="M:FsEx.ResizeArray.append``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
<summary>
Build a new array that contains the elements of the first array followed by the elements of the second array.
</summary>
</member>
<member name="M:FsEx.ResizeArray.concat``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.List{``0}})">
<summary>
Build a new array that contains the elements of each of the given list of arrays.
</summary>
</member>
<member name="M:FsEx.ResizeArray.blit``1(System.Collections.Generic.List{``0},System.Int32,System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
Read a range of elements from the first array and write them into the second.
</summary>
</member>
<member name="M:FsEx.ResizeArray.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
Create an array by calling the given generator on each index.
</summary>
</member>
<member name="M:FsEx.ResizeArray.create``1(System.Int32,``0)">
<summary>
Create an array whose elements are all initially the given value.
</summary>
</member>
<member name="M:FsEx.ResizeArray.set``1(System.Collections.Generic.List{``0},System.Int32,``0)">
<summary>
Set the value of an element in the collection. You can also use the syntax &lt;c&gt;arr.[idx] &lt;- e&lt;/c&gt;.
However this function allows for negtive index too (like Python)
</summary>
</member>
<member name="M:FsEx.ResizeArray.get``1(System.Collections.Generic.List{``0},System.Int32)">
<summary>
Fetch an element from the collection.  You can also use the syntax &lt;c&gt;arr.[idx]&lt;/c&gt;.
However this function allows for negtive index too (like Python)
</summary>
</member>
<member name="M:FsEx.ResizeArray.length``1(System.Collections.Generic.List{``0})">
<summary>
Return the length of the collection.  You can also use property &lt;c&gt;arr.Length&lt;/c&gt;.
</summary>
</member>
<member name="M:FsEx.ResizeArray.MinMax.sort3f``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},``0,``0,``0)">
<summary>
If any are equal then the the order is kept
</summary>
</member>
<member name="T:FsEx.ResizeArray.MinMax">
<summary>
 for finding 
</summary>
</member>
<member name="T:FsEx.ResizeArray">
<summary>
Generic operations on the type System.Collections.Generic.List, which is called ResizeArray in the F# libraries.
</summary>
</member>
<member name="M:FsEx.TypeExtensionsResizeArray.List`1.SetItem``1(System.Collections.Generic.List{``0},System.Int32,``0)">
<summary>
Allows for negtive index too (like Python)
</summary>
</member>
<member name="M:FsEx.TypeExtensionsResizeArray.List`1.GetItem``1(System.Collections.Generic.List{``0},System.Int32)">
<summary>
Allows for negtive index too (like Python)
</summary>
</member>
<member name="M:FsEx.TypeExtensionsResizeArray.List`1.GetSlice``1(System.Collections.Generic.List{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
Allows for negtive slice index too ( -1 = last element), 
returns a shallow copy including the end index.
</summary>
</member>
<member name="M:FsEx.TypeExtensionsCollections.Dictionary`2.get_Items``2(System.Collections.Generic.Dictionary{``0,``1})">
<summary>
Returns a lazy seq of key and value tuples
</summary>
</member>
<member name="M:FsEx.TypeExtensionsCollections.Dictionary`2.Pop``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
<summary>
Get a value and remove it from Dictionary, like *.pop() in Python         
</summary>
</member>
<member name="M:FsEx.Seq.iPrevThisNext``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
Yields looped Seq of (index, previous, this, next): from (0, last, first, second)  upto (lastIndex, second-last, last, first)
The length of the resulting seq is the same as the input seq.
Use Seq.skip.Last afterwerds or Seq.windowed if you don&apos;t want a looped seqence.
</summary>
</member>
<member name="M:FsEx.Seq.prevThisNext``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
Yields looped Seq of (previous, this, next): from (last, first, second)  upto (second-last, last, first)
The length of the resulting seq is the same as the input seq.
Use Seq.skip.Last afterwerds or Seq.windowed if you don&apos;t want a looped seqence.
</summary>
</member>
<member name="M:FsEx.Seq.lastFast``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 faster implemetation of Seq.last till F# 4.8 is out
</summary>
</member>
<member name="M:FsEx.Seq.iThisNext``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
Yields looped Seq of (index,this, next) from (0,first, second)  upto (lastIndex, last, first)
The length of the resulting seq is the same as the input seq.
Use Seq.skip.Last afterwerds or Seq.windowed if you don&apos;t want a looped seqence.
</summary>
</member>
<member name="M:FsEx.Seq.thisNext``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
Yields looped Seq of (this, next) from (first, second)  upto (last, first)
The length of the resulting seq is the same as the input seq.
Use Seq.skip.Last afterwerds or Seq.windowed if you don&apos;t want a looped seqence.
</summary>
</member>
<member name="M:FsEx.Seq.skipLast``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
Yields the Seq without the last element
</summary>
</member>
<member name="M:FsEx.Seq.rotate``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
Considers sequence cirular and move elements up or down
 e.g.: rotate +1 [ a, b, c, d] = [ d, a, b, c]
 e.g.: rotate -1 [ a, b, c, d] = [ b, c, d, a]
</summary>
</member>
<member name="M:FsEx.Seq.slice``1(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
Allows for negative indices too, -1 is the last element.
The resulting seq includes the item at slice-ending-index. like F# range expressions include the last integer e.g.: 0..5
</summary>
</member>
<member name="M:FsEx.TypeExtensionsSeq.IEnumerable`1.GetSlice``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
Allows for negative indices too, like Python, -1 is the last element.
The resulting seq includes the item at slice-ending-index. like F# range expressions include the last integer e.g.: 0..5
</summary>
</member>
<member name="M:FsEx.TypeExtensionsSeq.IEnumerable`1.set_Item``1(System.Collections.Generic.IEnumerable{``0},System.Int32,``0)">
<summary>
Allows for negative indices too, like Python, -1 is the last element.
</summary>
</member>
<member name="M:FsEx.TypeExtensionsSeq.IEnumerable`1.get_Item``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
<summary>
Allows for negative indices too, like Python, -1 is the last element.
</summary>
</member>
<member name="M:FsEx.TypeExtensionsSeq.IEnumerable`1.get_Last``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Last item in Seq
</summary>
</member>
<member name="M:FsEx.TypeExtensionsSeq.IEnumerable`1.get_LastIndex``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Like Seq.length - 1
</summary>
</member>
<member name="M:FsEx.TypeExtensionsSeq.fastLast``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 faster implemetation of Seq.last , keep till F# 4.8 is out
</summary>
</member>
<member name="M:FsEx.TypeExtensionsSeq.negIdx(System.Int32,System.Int32)">
<summary>
 Converts negative indices to positive ones 
 e.g.: -1 is  last item .
</summary>
</member>
<member name="M:FsEx.TypeExtensionsSeq.saveIdx(System.Int32,System.Int32)">
<summary>
 Any int will give a valid index for given collection size.
</summary>
</member>
<member name="M:FsEx.TypeExtensionsIList.IList`1.GetSlice``1(System.Collections.Generic.IList{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
Allows for negative indices too.
The resulting List includes the item at slice ending index.
</summary>
</member>
<member name="M:FsEx.TypeExtensionsIList.IList`1.SetItem``1(System.Collections.Generic.IList{``0},System.Int32,``0)">
<summary>
Allows for negtive index too (like Python)
</summary>
</member>
<member name="M:FsEx.TypeExtensionsIList.IList`1.GetItem``1(System.Collections.Generic.IList{``0},System.Int32)">
<summary>
Allows for negtive index too (like Python)
</summary>
</member>
<member name="M:FsEx.TypeExtensionsIList.IList`1.get_Last``1(System.Collections.Generic.IList{``0})">
<summary>
 last item in Array
</summary>
</member>
<member name="M:FsEx.TypeExtensionsIList.IList`1.get_LastIndex``1(System.Collections.Generic.IList{``0})">
<summary>
 like this.Count - 1
</summary>
</member>
<member name="M:FsEx.NonBoxingEqualityOperators.op_EqualsBangEquals``1(``0,``0)">
<summary>
This NotEquals operator (=!=) is overloaded to always use the generic System.IEquatable&lt;&apos;T&gt;
This avoids boxing of custom structs when comparing with (&lt;&gt;). A significant performance improvement.
</summary>
</member>
<member name="M:FsEx.NonBoxingEqualityOperators.op_EqualsEqualsEquals``1(``0,``0)">
<summary>
This Equals operator (===) always uses the generic System.IEquatable&lt;&apos;T&gt;
This avoids boxing of custom structs when comparing with (=). A significant performance improvement.
</summary>
</member>
<member name="M:FsEx.NonBoxingEqualityOperatorOverloads.op_BangEquals``1(``0,``0)">
<summary>
The original NotEquals operator (&lt;&gt;) is overloaded to always use the generic System.IEquatable&lt;&apos;T&gt;
This avoids boxing of custom structs when comparing. A significant performance improvement.
Use (!=) for types that don&apos;t have System.IEquatable&lt;&apos;T&gt; implemented or any type if you dont mind performance.
</summary>
</member>
<member name="M:FsEx.NonBoxingEqualityOperatorOverloads.op_EqualsEquals``1(``0,``0)">
<summary>
The orignal Equals operator (=) is overloaded to always use the generic System.IEquatable&lt;&apos;T&gt;
This avoids boxing of custom structs when comparing. A significant performance improvement.
Use this operator (==) for types that don&apos;t have System.IEquatable&lt;&apos;T&gt; implemented or any type if you dont mind performance.
</summary>
</member>
<member name="M:FsEx.NonBoxingEqualityOperatorOverloads.op_Inequality``1(``0,``0)">
<summary>
The NotEquals operator (&lt;&gt;) is overloaded to always use the generic System.IEquatable&lt;&apos;T&gt;
This avoids boxing of custom structs when comparing. A significant performance improvement.
Use (!=) for types that don&apos;t have System.IEquatable&lt;&apos;T&gt; implemented.
</summary>
</member>
<member name="M:FsEx.NonBoxingEqualityOperatorOverloads.op_Equality``1(``0,``0)">
<summary>
The Equals operator (=) is overloaded to always use the generic System.IEquatable&lt;&apos;T&gt;
This avoids boxing of custom structs when comparing. A significant performance improvement.
Use (==) for types that don&apos;t have System.IEquatable&lt;&apos;T&gt; implemented.
</summary>
</member>
<member name="T:FsEx.NonBoxingEqualityOperatorOverloads">
<summary>
Opening this module improves the performance of equality tests (=) and (&lt;&gt;) on custom structs significantly.
But for types that don&apos;t have System.IEquatable&lt;&apos;T&gt; implemented you will now have to use (==) and (!=).
Use #nowarn &quot;86&quot;to disable warnings
</summary>
</member>
<member name="M:FsEx.ResizeArrayBuilder.resizeArray``1">
<summary>
 Computational Expression:  use &apos;yield&apos; to add alements to a ResizeArray (= Collections.Generic.List).
</summary>
</member>
<member name="P:FsEx.StringBufferBuilder.stringBuffer">
<summary>
Computational Expression:  
use &apos;yield&apos; to append text
and &apos;yield!&apos; (with an exclamation mark)  to append text followed by a new line character.
accepts ints and floats too. (including nice Formating)
</summary>
</member>
<member name="T:FsEx.MaybeBuilder.MaybeBuilder">
<summary>
 The maybe monad. 
</summary>
</member>
<member name="P:FsEx.MaybeBuilder.maybe">
<summary>
 A maybe monad. 
</summary>
</member>
<member name="M:FsEx.PrintDistribution.sprintDistributionByStepSizeOffset(System.String,System.Double,System.Double,System.Double,System.Collections.Generic.IEnumerable{System.Double})">
<summary>
* units as string (&quot;mm&quot;?) -&gt; scale for Bars ( ~0.5 to ~2.0) -&gt; stepSize (float) -&gt; offset for scale (float) -&gt;list of floats -&gt; returns string
</summary>
</member>
<member name="M:FsEx.PrintDistribution.sprintDistributionByStepSize(System.String,System.Double,System.Double,System.Collections.Generic.IEnumerable{System.Double})">
<summary>
* units as string (&quot;mm&quot;?) -&gt; scale for Bars ( ~0.5 to ~2.0) -&gt; stepSize (float) -&gt; list of floats -&gt; returns string
</summary>
</member>
<member name="M:FsEx.PrintDistribution.sprintDistribution(System.String,System.Double,System.Int32,System.Collections.Generic.IEnumerable{System.Double})">
<summary>
* units as string (&quot;mm&quot;?) -&gt; scale for Bars ( ~0.5 to ~2.0) -&gt; substeps (int 5 to 30) -&gt; list of floats -&gt; returns string
</summary>
</member>
</members>
</doc>

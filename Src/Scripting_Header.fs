namespace Rhino.Scripting

open Rhino

// leave all these open statements here! even if they are unused, they are needed when all files are combined into one during the build.
open System
open System.Globalization
open System.Collections.Generic
open Microsoft.FSharp.Core.LanguagePrimitives
open Rhino.Geometry
open Rhino.ApplicationSettings
open Rhino.Scripting.RhinoScriptingUtils


// ------- Abbreviations so that declarations are not so long:

/// OptionalAttribute for member parameters
type internal OPT = Runtime.InteropServices.OptionalAttribute

/// DefaultParameterValueAttribute for member parameters
type internal DEF =  Runtime.InteropServices.DefaultParameterValueAttribute


// This file and all other files with the name Scripting_**.fs will be combined into one large file called AutoGeneratedCode/AllScriptingFilesCombinedIntoOne_DontEditThisFile.fs before compiling.
// This is done via the script combineIntoOneFile.fsx that is invoked as part of the build process.
// This build process is needed because F# extension members don't work in C#, and C# extension members via Extension attribute show as instance members when used in F#.
// Autocomplete would not work well if this file has 20k lines while being edited.

/// A static class with static methods providing functions identical to RhinoScript in Python or VBscript
[<AbstractClass; Sealed>]
type RhinoScriptSyntax private () =

    // static class, use these attributes [<AbstractClass; Sealed>] to match C# static class
    // and make it visible in C# // https://stackoverflow.com/questions/13101995/defining-static-classes-in-f

    /// The current active Rhino document (= the file currently open)
    static member Doc = State.Doc

    /// Object Table of the current active Rhino document
    static member Ot = State.Ot

    /// A Dictionary to store state between scripting session.
    /// Use RhinoScriptSyntax.Sticky.Clear() to reset it.
    /// Similar to scriptingcontext.sticky dictionary in Rhino Python.
    static member val Sticky = new Dict<string, obj>() with get

    /// An Integer Enum of Object types.
    /// To be used in object selection functions such as rs.GetObjects().
    static member val Filter = new ObjectFilterEnum ()

    /// Tests to see if the user has pressed the escape key.
    /// Raises an OperationCanceledException.
    static member EscapeTest() : unit = // [<OPT;DEF(true)>]throwException:bool, [<OPT;DEF(false)>]reset:bool) : bool =
        RhinoApp.Wait() //does not need to be on  UI thread
        if State.EscapePressed  then
            State.EscapePressed <- false //always reset is needed otherwise in next run of script will not be reset
            raise ( OperationCanceledException("Esc key was pressed and caught via RhinoScriptSyntax.EscapeTest()"))


    /// <summary>Clamps a value between a lower and an upper bound.</summary>
    /// <param name="minVal">(float) The lower bound.</param>
    /// <param name="maxVal">(float) The upper bound.</param>
    /// <param name="value">(float) The value to clamp.</param>
    /// <returns>(float) The clamped value.</returns>
    static member Clamp (minVal:float, maxVal:float, value:float) : float =
        if minVal > maxVal then  RhinoScriptingException.Raise "Clamp: minValue %A must be less than maxValue %A" minVal maxVal
        max minVal (min maxVal value)

    /// <summary>Like the Python 'xrange' function for integers, this creates a range of floating point values.
    /// The last or stop value will NOT be included in the range as per Python semantics; this is different from F# semantics on range expressions.</summary>
    /// <param name="start">(float) The first value of the range.</param>
    /// <param name="stop">(float) The end of the range. The last value will not be included in the range (Python semantics).</param>
    /// <param name="step">(float) The step size between two values.</param>
    /// <returns>(float seq) A lazy sequence of floats.</returns>
    static member FxrangePython (start:float, stop:float, step:float) : float seq =
        if isNanOrInf start then RhinoScriptingException.Raise "FxrangePython: NaN or Infinity, start=%f, step=%f, stop=%f" start step stop
        if isNanOrInf step  then RhinoScriptingException.Raise "FxrangePython: NaN or Infinity, start=%f, step=%f, stop=%f" start step stop
        if isNanOrInf stop  then RhinoScriptingException.Raise "FxrangePython: NaN or Infinity, start=%f, step=%f, stop=%f" start step stop
        let range = stop - start
                    |> BitConverter.DoubleToInt64Bits
                    |> (+) 15L // to make sure stop value is included in Range, this will then explicitly be removed below to match python semantics
                    |> BitConverter.Int64BitsToDouble
        let steps = range/step - 1.0 // -1 to make sure stop value is not included(python semantics different from F# semantics on range expressions)
        if isNanOrInf steps then RhinoScriptingException.Raise "FxrangePython range/step in frange: %f / %f is NaN Infinity, start=%f, stop=%f" range step start stop

        if steps < 0.0 then
            RhinoScriptingException.Raise "FxrangePython: Stop value cannot be reached: start=%f, step=%f, stop=%f (steps:%f)" start step stop steps //or Seq.empty
        else
            // the actual algorithm:
            let rec floatRange (start, i, steps) =
                seq { if i <= steps then
                        yield start + i*step
                        yield! floatRange (start, (i + 1.0), steps) } // tail recursive !
            floatRange (start, 0.0, steps)

    /// <summary>Like the Python 'range' function for integers, this creates a range of floating point values.
    /// The last or stop value will NOT be included in the range as per Python semantics; this is different from F# semantics on range expressions.</summary>
    /// <param name="start">(float) The first value of the range.</param>
    /// <param name="stop">(float) The end of the range. The last value will not be included in the range (Python semantics).</param>
    /// <param name="step">(float) The step size between two values.</param>
    /// <returns>(float ResizeArray) A resizable array of floats.</returns>
    static member FrangePython (start:float, stop:float, step:float) : float ResizeArray =
        RhinoScriptSyntax.FxrangePython (start, stop, step) |> ResizeArray

    /// <summary>Adds any geometry object (struct or class) to the Rhino document.
    /// Works not only on any subclass of GeometryBase but also on Point3d, Line, Arc, and similar structs.</summary>
    /// <param name="geo">The geometry object.</param>
    /// <param name="layerIndex">(int) The layer index.</param>
    /// <param name="objectName">(string) Default value: <c>""</c>. The object name.</param>
    /// <param name="userTextKeysAndValues">(string*string seq) Default value: <c>[]</c>. List of key-value pairs for user text.</param>
    /// <param name="stringSafetyCheck">(bool) Optional, default value: <c>true</c>. Checks that object name and user text do not include line returns, tabs, or leading/trailing whitespace.</param>
    /// <param name="collapseParents">(bool) Optional, default value: <c>false</c>. Collapse parent layers in the Layer UI.</param>
    /// <returns>(Guid) The Guid of the added object.</returns>
    static member Add (  geo:'T
                      ,  layerIndex:int // don't make it  optional , so that method overload resolution works for rs.Add(..)
                      ,  [<OPT;DEF("")>]objectName:string
                      ,  [<OPT;DEF(null:seq<string*string>)>]userTextKeysAndValues:seq<string*string>
                      ,  [<OPT;DEF(true)>]stringSafetyCheck:bool
                      ,  [<OPT;DEF(false:bool)>]collapseParents:bool
                      ) : Guid =
        let attr =
            if layerIndex = -1 && objectName="" && isNull userTextKeysAndValues  then
                null
            else
                let a = new DocObjects.ObjectAttributes()
                a.LayerIndex <- layerIndex
                if objectName <> "" then
                    if stringSafetyCheck && not <|  Util.isAcceptableStringId( objectName, false) then // TODO or enforce goodStringID ?
                        RhinoScriptingException.Raise "Add: objectName the string '%s' cannot be used as key. See RhinoScriptSyntax.IsGoodStringId. You can use checkStrings=false parameter to bypass some of these restrictions." objectName
                    a.Name <- objectName
                if notNull userTextKeysAndValues then
                    for k,v in userTextKeysAndValues do
                        if stringSafetyCheck then
                            if not <|  Util.isAcceptableStringId( k, false) then // TODO or enforce goodStringID ?
                                RhinoScriptingException.Raise "Add: SetUserText the string '%s' cannot be used as key. See RhinoScriptSyntax.IsGoodStringId. You can use checkStrings=false parameter to bypass some of these restrictions." k
                            if not <|  Util.isAcceptableStringId( v, false) then
                                RhinoScriptingException.Raise "Add: SetUserText the string '%s' cannot be used as value. See RhinoScriptSyntax.IsGoodStringId. You can use checkStrings=false parameter to bypass some of these restrictions." v
                        if not <| a.SetUserString(k,v) then
                            RhinoScriptingException.Raise "Add: failed to set key value pair '%s' and '%s' " k v
                if collapseParents then
                    State.Doc.Layers.[layerIndex].IsExpanded <- false
                a

        match box geo with
        | :? GeometryBase as g ->  State.Doc.Objects.Add(g,attr)
        // now the structs:
        | :? Point3d     as pt->   State.Doc.Objects.AddPoint(pt,attr)
        | :? Point3f     as pt->   State.Doc.Objects.AddPoint(pt,attr)
        | :? Line        as ln->   State.Doc.Objects.AddLine(ln,attr)
        | :? Arc         as a->    State.Doc.Objects.AddArc(a,attr)
        | :? Circle      as c->   State.Doc.Objects.AddCircle(c,attr)
        | :? Ellipse     as e->    State.Doc.Objects.AddEllipse(e,attr)
        | :? Polyline    as pl ->  State.Doc.Objects.AddPolyline(pl,attr)
        | :? Box         as b ->   State.Doc.Objects.AddBox(b,attr)
        | :? BoundingBox as b ->   State.Doc.Objects.AddBox(Box(b),attr)
        | :? Sphere      as b ->   State.Doc.Objects.AddSphere(b,attr)
        | :? Cylinder    as cl ->  State.Doc.Objects.AddSurface (cl.ToNurbsSurface(),attr)
        | :? Cone        as c ->   State.Doc.Objects.AddSurface (c.ToNurbsSurface(),attr)
        | _ -> RhinoScriptingException.Raise $"RhinoScriptSyntax.Add: object of type {geo.GetType().FullName} not implemented yet"

    /// <summary>Adds any geometry object (struct or class) to the Rhino document.
    /// Works not only on any subclass of GeometryBase but also on Point3d, Line, Arc, and similar structs.</summary>
    /// <param name="geo">The geometry object.</param>
    /// <param name="layer">(string) Optional. The layer name; parent layers separated by '::'.</param>
    /// <param name="objectName">(string) Optional, default value: <c>""</c>. The object name.</param>
    /// <param name="userTextKeysAndValues">(string*string seq) Optional, default value: <c>[]</c>. List of key-value pairs for user text.</param>
    /// <param name="layerColor">(Drawing.Color) Optional, default value: <c>UtilLayer.randomLayerColor()</c>. The color for the layer. The layer color will NOT be changed if the layer already exists.</param>
    /// <param name="stringSafetyCheck">(bool) Optional, default value: <c>true</c>. Checks that object name and user text do not include line returns, tabs, or leading/trailing whitespace.</param>
    /// <param name="collapseParents">(bool) Optional, default value: <c>false</c>. Collapse parent layers in the Layer UI.</param>
    /// <returns>(Guid) The Guid of the added object.</returns>
    static member Add (  geo:'T
                      ,  [<OPT;DEF("")>]layer:string
                      ,  [<OPT;DEF("")>]objectName:string
                      ,  [<OPT;DEF(null:seq<string*string>)>]userTextKeysAndValues:seq<string*string>
                      ,  [<OPT;DEF(Drawing.Color():Drawing.Color)>]layerColor:Drawing.Color
                      ,  [<OPT;DEF(true)>]stringSafetyCheck:bool
                      ,  [<OPT;DEF(false:bool)>]collapseParents:bool
                      ) : Guid =
        let layCorF =
            if layer<>""then
                if layerColor.IsEmpty then
                    UtilLayer.getOrCreateLayer(layer, UtilLayer.randomLayerColor, UtilLayer.ByParent, UtilLayer.ByParent, true, collapseParents) // TODO or disallow all Unicode ?
                else
                    UtilLayer.getOrCreateLayer(layer, (fun () -> layerColor), UtilLayer.ByParent, UtilLayer.ByParent, true, collapseParents)// TODO or disallow all Unicode ?
            else
                UtilLayer.LayerFound State.Doc.Layers.CurrentLayerIndex

        let layIdx =
            match layCorF with
            |UtilLayer.LayerCreated ci -> ci
            |UtilLayer.LayerFound fi ->  fi
                (*
                // now update the layer color if one is given, even if the layer exists already
                if layerColor.IsEmpty then
                    fi
                else
                    let lay = State.Doc.Layers.[fi]
                    if not <| lay.Color.EqualsARGB(layerColor) then
                        lay.Color <- layerColor
                    fi
                *)

        let g = RhinoScriptSyntax.Add( geo, layIdx, objectName, userTextKeysAndValues, stringSafetyCheck)
        g




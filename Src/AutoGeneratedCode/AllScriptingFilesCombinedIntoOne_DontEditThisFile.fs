namespace Rhino.Scripting

open Rhino


// leave all these open statements here! even if they are unused, they are needed when all files are combined into one during the build.
open System
open System.Globalization
open System.Collections.Generic
open Microsoft.FSharp.Core.LanguagePrimitives

open Rhino.Geometry
open Rhino.ApplicationSettings

// open FsEx
// open FsEx.UtilMath
// open FsEx.SaveIgnore
// open FsEx.CompareOperators




// ------- Abbreviations so that declarations are not so long:

/// OptionalAttribute for member parameters
type internal OPT = Runtime.InteropServices.OptionalAttribute

/// DefaultParameterValueAttribute for member parameters
type internal DEF =  Runtime.InteropServices.DefaultParameterValueAttribute


// This file and all other files with the name Scripting_**.fs will be combined into one large file called AutoGeneratedCode/AllScriptingFilesCombinedIntoOne_DontEditThisFile.fs before compiling.
// This is done via the script combineIntoOneFile.fsx that is invoked as part of the build process.
// This build process is needed because F# extension members don't work in C#, and C# extension members via Extension attribute show as instance members when used in F#.
// Autocomplete would not work well if this file has 20k lines while being edited.

/// A static class with static methods providing functions identical to RhinoScript in Python or VBscript
[<AbstractClass; Sealed>]
type RhinoScriptSyntax private () =

    // static class, use these attributes [<AbstractClass; Sealed>] to match C# static class
    // and make in visible in C# // https://stackoverflow.com/questions/13101995/defining-static-classes-in-f

    /// The current active Rhino document (= the file currently open)
    static member Doc = State.Doc

    /// Object Table of the current active Rhino document
    static member Ot = State.Ot

    /// A Dictionary to store state between scripting session.
    /// Use RhinoScriptSyntax.Sticky.Clear() to reset it.
    /// Similar to scriptingcontext.sticky dictionary in Rhino Python.
    static member val Sticky = new Dict<string, obj>() with get

    /// An Integer Enum of Object types.
    /// To be use in object selection functions such as rs.GetObjects().
    static member val Filter = new ObjectFilterEnum ()

    /// Tests to see if the user has pressed the escape key.
    /// Raises an OperationCanceledException.
    static member EscapeTest() : unit = // [<OPT;DEF(true)>]throwException:bool, [<OPT;DEF(false)>]reset:bool) : bool =
        RhinoApp.Wait() //does not need to be on  UI thread
        if State.EscapePressed  then
            State.EscapePressed <- false //always reset is needed otherwise in next run of script will not be reset
            raise ( OperationCanceledException("Esc key was pressed and caught via RhinoScriptSyntax.EscapeTest()"))


    ///<summary>Clamps a value between a lower and an upper bound.</summary>
    ///<param name="minVal">(float) The lower bound</param>
    ///<param name="maxVal">(float) The upper bound</param>
    ///<param name="value">(float) The value to clamp</param>
    ///<returns>(float) The clamped value.</returns>
    static member Clamp (minVal:float, maxVal:float, value:float) : float =
        if minVal > maxVal then  RhinoScriptingException.Raise "RhinoScriptSyntax.Clamp: minValue %A must be less than maxValue %A" minVal maxVal
        max minVal (min maxVal value)


    ///<summary>Like the Python 'xrange' function for integers this creates a range of floating point values.
    ///    The last or stop value will NOT be included in range as per python semantics, this is different from F# semantics on range expressions.
    ///    Use FsEx.UtilMath.floatRange(...) to include stop value in range.</summary>
    ///<param name="start">(float) first value of range</param>
    ///<param name="stop">(float) end of range (The last value will not be included in range, Python semantics.)</param>
    ///<param name="step">(float) step size between two values</param>
    ///<returns>(float seq) a lazy seq of floats.</returns>
    static member FxrangePython (start:float, stop:float, step:float) : float seq =
        if isNanOrInf start then RhinoScriptingException.Raise "RhinoScriptSyntax.FxrangePython: NaN or Infinity, start=%f, step=%f, stop=%f" start step stop
        if isNanOrInf step  then RhinoScriptingException.Raise "RhinoScriptSyntax.FxrangePython: NaN or Infinity, start=%f, step=%f, stop=%f" start step stop
        if isNanOrInf stop  then RhinoScriptingException.Raise "RhinoScriptSyntax.FxrangePython: NaN or Infinity, start=%f, step=%f, stop=%f" start step stop
        let range = stop - start
                    |> BitConverter.DoubleToInt64Bits
                    |> (+) 15L // to make sure stop value is included in Range, this will then explicitly be removed below to match python semantics
                    |> BitConverter.Int64BitsToDouble
        let steps = range/step - 1.0 // -1 to make sure stop value is not included(python semantics different from F# semantics on range expressions)
        if isNanOrInf steps then RhinoScriptingException.Raise "RhinoScriptSyntax.FxrangePython range/step in frange: %f / %f is NaN Infinity, start=%f, stop=%f" range step start stop

        if steps < 0.0 then
            RhinoScriptingException.Raise "RhinoScriptSyntax.FxrangePython: Stop value cannot be reached: start=%f, step=%f, stop=%f (steps:%f)" start step stop steps //or Seq.empty
        else
            // the actual algorithm:
            let rec floatRange (start, i, steps) =
                seq { if i <= steps then
                        yield start + i*step
                        yield! floatRange (start, (i + 1.0), steps) } // tail recursive !
            floatRange (start, 0.0, steps)

    ///<summary>Like the Python 'range' function for integers this creates a range of floating point values.
    ///    This last or stop value will NOT be included in range as per python semantics, this is different from F# semantics on range expressions.
    ///    Use FsEx.UtilMath.floatRange(...) to include stop value in range.</summary>
    ///<param name="start">(float) first value of range</param>
    ///<param name="stop">(float) end of range( The last value will not be included in range, Python semantics.)</param>
    ///<param name="step">(float) step size between two values</param>
    ///<returns>(float ResizeArray).</returns>
    static member FrangePython (start:float, stop:float, step:float) : float ResizeArray =
        RhinoScriptSyntax.FxrangePython (start, stop, step) |> ResizeArray

    ///<summary>Adds any geometry object (struct or class) to the Rhino document.
    /// works not only on any subclass of GeometryBase but also on Point3d, Line, Arc and similar structs </summary>
    ///<param name="geo">the Geometry</param>
    ///<param name="layerIndex">(int) LayerIndex</param>
    ///<param name="objectName">(string) Default Value: <c>""</c>, object name</param>
    ///<param name="userTextKeysAndValues">(string*string seq) Default Value: <c>[]</c>, list of key value pairs for user text</param>
    ///<param name="stringSafetyCheck">(bool) Optional, default value: <c>true</c>. Check object name and usertext do not include line returns, tabs, and leading or trailing whitespace.</param>
    ///<param name="collapseParents">(bool) Optional, default value: <c>false</c>. Collapse parent layers in Layer UI </param>
    ///<returns>(Guid) The Guid of the added Object.</returns>
    static member Add (  geo:'T
                      ,  layerIndex:int // don't make it  optional , so that method overload resolution works for rs.Add(..)
                      ,  [<OPT;DEF("")>]objectName:string
                      ,  [<OPT;DEF(null:seq<string*string>)>]userTextKeysAndValues:seq<string*string>
                      ,  [<OPT;DEF(true)>]stringSafetyCheck:bool
                      ,  [<OPT;DEF(false:bool)>]collapseParents:bool
                      ) : Guid =
        let attr =
            if layerIndex = -1 && objectName="" && isNull userTextKeysAndValues  then
                null
            else
                let a = new DocObjects.ObjectAttributes()
                a.LayerIndex <- layerIndex
                if objectName <> "" then
                    if stringSafetyCheck && not <|  Util.isAcceptableStringId( objectName, false) then // TODO or enforce goodStringID ?
                        RhinoScriptingException.Raise "RhinoScriptSyntax.Add: objectName the string '%s' cannot be used as key. See RhinoScriptSyntax.IsGoodStringId. You can use checkStrings=false parameter to bypass some of these restrictions." objectName
                    a.Name <- objectName
                if notNull userTextKeysAndValues then
                    for k,v in userTextKeysAndValues do
                        if stringSafetyCheck then
                            if not <|  Util.isAcceptableStringId( k, false) then // TODO or enforce goodStringID ?
                                RhinoScriptingException.Raise "RhinoScriptSyntax.Add: SetUserText the string '%s' cannot be used as key. See RhinoScriptSyntax.IsGoodStringId. You can use checkStrings=false parameter to bypass some of these restrictions." k
                            if not <|  Util.isAcceptableStringId( v, false) then
                                RhinoScriptingException.Raise "RhinoScriptSyntax.Add: SetUserText the string '%s' cannot be used as value. See RhinoScriptSyntax.IsGoodStringId. You can use checkStrings=false parameter to bypass some of these restrictions." v
                        if not <| a.SetUserString(k,v) then
                            RhinoScriptingException.Raise "RhinoScriptSyntax.Add: failed to set key value pair '%s' and '%s' " k v
                if collapseParents then
                    State.Doc.Layers.[layerIndex].IsExpanded <- false
                a

        match box geo with
        | :? GeometryBase as g ->  State.Doc.Objects.Add(g,attr)
        // now the structs:
        | :? Point3d     as pt->   State.Doc.Objects.AddPoint(pt,attr)
        | :? Point3f     as pt->   State.Doc.Objects.AddPoint(pt,attr)
        | :? Line        as ln->   State.Doc.Objects.AddLine(ln,attr)
        | :? Arc         as a->    State.Doc.Objects.AddArc(a,attr)
        | :? Circle      as c->    State.Doc.Objects.AddCircle(c,attr)
        | :? Ellipse     as e->    State.Doc.Objects.AddEllipse(e,attr)
        | :? Polyline    as pl ->  State.Doc.Objects.AddPolyline(pl,attr)
        | :? Box         as b ->   State.Doc.Objects.AddBox(b,attr)
        | :? BoundingBox as b ->   State.Doc.Objects.AddBox(Box(b),attr)
        | :? Sphere      as b ->   State.Doc.Objects.AddSphere(b,attr)
        | :? Cylinder    as cl ->  State.Doc.Objects.AddSurface (cl.ToNurbsSurface(),attr)
        | :? Cone        as c ->   State.Doc.Objects.AddSurface (c.ToNurbsSurface(),attr)
        | _ -> RhinoScriptingException.Raise $"RhinoScriptSyntax.Add: object of type {geo.GetType().FullName} not implemented yet"

    ///<summary>Adds any geometry object (struct or class) to the Rhino document.
    ///   Works not only on any subclass of GeometryBase but also on Point3d, Line, Arc and similar structs </summary>
    ///<param name="geo">the Geometry</param>
    ///<param name="layer">(string) Optional, Layer Name, parent layer separated by '::' </param>
    ///<param name="objectName">(string) Optional, default value: <c>""</c>. The object name</param>
    ///<param name="userTextKeysAndValues">(string*string seq) Optional, default value: <c>[]</c>. list of key value pairs for user text</param>
    ///<param name="layerColor">(Drawing.Color) Optional, default value: <c>FsEx.Color.randomForRhino()</c>Color for layer. The layer color will NOT be changed even if the layer exists already</param>
    ///<param name="stringSafetyCheck">(bool) Optional, default value: <c>true</c>. Check object name and usertext do not include line returns, tabs, and leading or trailing whitespace.</param>
    ///<param name="collapseParents">(bool) Optional, default value: <c>false</c>. Collapse parent layers in Layer UI </param>
    ///<returns>(Guid) The Guid of the added Object.</returns>
    static member Add (  geo:'T
                      ,  [<OPT;DEF("")>]layer:string
                      ,  [<OPT;DEF("")>]objectName:string
                      ,  [<OPT;DEF(null:seq<string*string>)>]userTextKeysAndValues:seq<string*string>
                      ,  [<OPT;DEF(Drawing.Color():Drawing.Color)>]layerColor:Drawing.Color
                      ,  [<OPT;DEF(true)>]stringSafetyCheck:bool
                      ,  [<OPT;DEF(false:bool)>]collapseParents:bool
                      ) : Guid =
        let layCorF =
            if layer<>""then
                if layerColor.IsEmpty then
                    UtilLayer.getOrCreateLayer(layer, UtilLayer.randomLayerColor, UtilLayer.ByParent, UtilLayer.ByParent, true, collapseParents) // TODO or disallow all Unicode ?
                else
                    UtilLayer.getOrCreateLayer(layer, (fun () -> layerColor), UtilLayer.ByParent, UtilLayer.ByParent, true, collapseParents)// TODO or disallow all Unicode ?
            else
                UtilLayer.LayerFound State.Doc.Layers.CurrentLayerIndex

        let layIdx =
            match layCorF with
            |UtilLayer.LayerCreated ci -> ci
            |UtilLayer.LayerFound fi ->  fi
                (*
                // now update the layer color if one is given, even if the layer exists already
                if layerColor.IsEmpty then
                    fi
                else
                    let lay = State.Doc.Layers.[fi]
                    if not <| lay.Color.EqualsARGB(layerColor) then
                        lay.Color <- layerColor
                    fi
                *)

        let g = RhinoScriptSyntax.Add( geo, layIdx, objectName, userTextKeysAndValues, stringSafetyCheck)
        g



    //---End of header marker: don't change: {@$%^&*()*&^%$@}



    // TODO all the functions taking a generic parameter should not be called coerce but rather try convert ?? no ?
    // TODO none of the coerce function should take generic parameter, just a few overloads


    //---------------------------------------------------
    //-----------------Coerce and TryCoerce pairs -------
    //---------------------------------------------------



    ///<summary>Attempt to get a Guids from input.</summary>
    ///<param name="objectId">object , Guid or string</param>
    ///<returns>a Guid Option.</returns>
    static member TryCoerceGuid (objectId:'T) : Guid option=
        match box objectId with
        | :? Guid  as g -> if Guid.Empty = g then None else Some g
        | :? DocObjects.RhinoObject as o -> Some o.Id
        | :? DocObjects.ObjRef      as o -> Some o.ObjectId
        | :? string  as s -> let ok, g = Guid.TryParse s in  if ok then Some g else None
        | _ -> None

    ///<summary>Attempt to get a Guids from input.</summary>
    ///<param name="input">object , Guid or string</param>
    ///<returns>Guid. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceGuid(input:'T) : Guid =
        match box input with
        | :? Guid  as g -> if Guid.Empty = g then RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceGuid: Guid is Empty"  else g
        | :? Option<Guid>  as go -> if go.IsNone || Guid.Empty = go.Value then RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceGuid: Guid is Empty or None: %A" input else go.Value //from UI functions
        | :? string  as s -> try Guid.Parse s with _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceGuid: string '%s' can not be converted to a Guid" s
        | :? DocObjects.RhinoObject as o -> o.Id
        | :? DocObjects.ObjRef      as o -> o.ObjectId
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceGuid: %A can not be converted to a Guid" input


    ///<summary>Attempt to get RhinoObject from the document with a given objectId.</summary>
    ///<param name="objectId">object Identifier (Guid or string)</param>
    ///<returns>a RhinoObject Option</returns>
    static member TryCoerceRhinoObject (objectId:Guid) : DocObjects.RhinoObject option =
        match State.Doc.Objects.FindId(objectId) with
        | null -> None
        | o    -> Some o

    ///<summary>Attempt to get RhinoObject from the document with a given objectId.</summary>
    ///<param name="objectId">(Guid) Object Identifier </param>
    ///<returns>a RhinoObject, Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceRhinoObject(objectId:Guid) : DocObjects.RhinoObject =
        match RhinoScriptSyntax.TryCoerceRhinoObject objectId with
        |Some o -> o
        |None ->
            if Guid.Empty = objectId then    RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceRhinoObject failed on empty Guid"
            else                             RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceRhinoObject: The Guid %O was not found in the Current Object table." objectId

    ///<summary>Attempt to get GeometryBase class from given Guid. Fails on empty Guid.</summary>
    ///<param name="objectId">geometry Identifier (Guid)</param>
    ///<returns>a Rhino.Geometry.GeometryBase Option</returns>
    static member TryCoerceGeometry (objectId:Guid) :GeometryBase option =
        match State.Doc.Objects.FindId(objectId) with
        | null -> None
        | o -> Some o.Geometry

    ///<summary>Attempt to get GeometryBase class from given input.</summary>
    ///<param name="objectId">(Guid) geometry Identifier </param>
    ///<returns>(Rhino.Geometry.GeometryBase. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceGeometry(objectId:Guid) : GeometryBase =
        if Guid.Empty = objectId then RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceGeometry failed on empty Guid"
        let o = State.Doc.Objects.FindId(objectId)
        if isNull o then RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceGeometry failed: Guid %O not found in Object table." objectId
        o.Geometry

    ///<summary>Attempt to get Rhino LightObject from the document with a given objectId.</summary>
    ///<param name="objectId">(Guid) light Identifier</param>
    ///<returns>a Rhino.Geometry.Light. Option.</returns>
    static member TryCoerceLight (objectId:Guid) : Light option =
        match RhinoScriptSyntax.CoerceGeometry objectId with
        | :? Geometry.Light as l -> Some l
        | _ -> None

    ///<summary>Attempt to get Rhino LightObject from the document with a given objectId.</summary>
    ///<param name="objectId">(Guid) light Identifier</param>
    ///<returns>a  Rhino.Geometry.Light. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceLight (objectId:Guid) : Light =
        match RhinoScriptSyntax.CoerceGeometry objectId with
        | :? Geometry.Light as l -> l
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceLight failed on: %s " (Nice.str objectId)


    ///<summary>Attempt to get Mesh class from given Guid. Fails on empty Guid.</summary>
    ///<param name="objectId">Mesh Identifier (Guid)</param>
    ///<returns>a Rhino.Geometry.Surface Option.</returns>
    static member TryCoerceMesh (objectId:Guid) : Mesh option =
        match State.Doc.Objects.FindId(objectId) with
            | null -> None
            | o ->
                match o.Geometry with
                | :? Mesh as m -> Some m
                | _ -> None

    ///<summary>Attempt to get Mesh geometry from the document with a given objectId.</summary>
    ///<param name="objectId">object Identifier (Guid or string)</param>
    ///<returns>(Rhino.Geometry.Mesh. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceMesh(objectId:Guid) : Mesh =
        match RhinoScriptSyntax.TryCoerceMesh(objectId) with
        | Some m -> m
        | None -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceMesh failed on: %s " (Nice.str objectId)

    ///<summary>Attempt to get Surface class from given Guid. Fails on empty Guid.</summary>
    ///<param name="objectId">Surface Identifier (Guid)</param>
    ///<returns>a Rhino.Geometry.Surface Option.</returns>
    static member TryCoerceSurface (objectId:Guid) : Surface option =
        match State.Doc.Objects.FindId(objectId) with
        | null -> None
        | o ->
            match o.Geometry with
            | :? Surface as c -> Some c
            | :? Brep as b ->
                if b.Faces.Count = 1 then Some (b.Faces.[0] :> Surface)
                else None
            //| :? Extrusion as e -> // covered by Surface
            //     let b = e.ToBrep()
            //     if b.Faces.Count = 1 then Some (b.Faces.[0] :> Surface)
            //     else None
            | _ -> None

    ///<summary>Attempt to get Surface geometry from the document with a given objectId.</summary>
    ///<param name="objectId">the object's Identifier</param>
    ///<returns>(Rhino.Geometry.Surface. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceSurface(objectId:Guid) : Surface =
        match RhinoScriptSyntax.CoerceGeometry(objectId) with
        | :? Surface as c -> c
        | :? Brep as b ->
            if b.Faces.Count = 1 then b.Faces.[0] :> Surface
            else RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceSurface failed on %O from Brep with %d Faces" objectId b.Faces.Count
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceSurface failed on: %O " objectId

    ///<summary>Attempt to get a Polysurface or Brep class from given Guid. Works on Extrusions too. Fails on empty Guid.</summary>
    ///<param name="objectId">Polysurface Identifier (Guid)</param>
    ///<returns>a Rhino.Geometry.Mesh Option.</returns>
    static member TryCoerceBrep (objectId:Guid) : Brep option =
        match State.Doc.Objects.FindId(objectId) with
            | null -> None
            | o ->
                match o.Geometry with
                | :? Brep as b ->  Some b
                | :? Extrusion as b -> Some (b.ToBrep(true))
                | _ -> None

    ///<summary>Attempt to get Polysurface geometry from the document with a given objectId.</summary>
    ///<param name="objectId">objectId (Guid or string) to be RhinoScriptSyntax.Coerced into a brep</param>
    ///<returns>(Rhino.Geometry.Brep. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceBrep(objectId:Guid) : Brep  =
        match RhinoScriptSyntax.TryCoerceBrep(objectId) with
        | Some b -> b
        | None -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceBrep failed on: %s " (Nice.str objectId)

    ///<summary>Attempt to get Curve geometry from the document with a given objectId.</summary>
    ///<param name="objectId">objectId (Guid or string) to be RhinoScriptSyntax.Coerced into a Curve</param>
    ///<param name="segmentIndex">(int) Optional, index of segment to retrieve. To ignore segmentIndex give -1 as argument</param>
    ///<returns>a Rhino.Geometry.Curve Option.</returns>
    static member TryCoerceCurve(objectId:Guid,[<OPT;DEF(-1)>]segmentIndex:int) : Curve option =
        let geo = RhinoScriptSyntax.CoerceGeometry objectId
        if segmentIndex < 0 then
            match geo with
            | :? Curve as c -> Some c
            | _ -> None
        else
            match geo with
            | :? PolyCurve as c ->
                let crv = c.SegmentCurve(segmentIndex)
                if isNull crv then None
                else Some crv
            | :? Curve as c -> Some c
            | _ -> None

    ///<summary>Attempt to get Curve geometry from the document with a given objectId.</summary>
    ///<param name="objectId">objectId (Guid or string) to be RhinoScriptSyntax.Coerced into a Curve</param>
    ///<param name="segmentIndex">(int) Optional, index of segment to retrieve. To ignore segmentIndex give -1 as argument</param>
    ///<returns>(Rhino.Geometry.Curve. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceCurve(objectId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : Curve =
        if segmentIndex < 0 then
            match RhinoScriptSyntax.CoerceGeometry(objectId) with
            | :? Curve as c -> c
            | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceCurve failed on: %s " (Nice.str objectId)
        else
            match RhinoScriptSyntax.CoerceGeometry(objectId) with
            | :? PolyCurve as c ->
                let crv = c.SegmentCurve(segmentIndex)
                if isNull crv then RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceCurve failed on segment index %d for %s" segmentIndex  (Nice.str objectId)
                crv
            | :? Curve as c -> c
            | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceCurve failed for %s"  (Nice.str objectId)


    ///<summary>Attempt to get Rhino Line Geometry using the current Documents Absolute Tolerance.</summary>
    ///<param name="line">Line, two points or Guid</param>
    ///<returns>Geometry.Line. Raises a RhinoScriptingException if coerce failed.</returns>
    static member TryCoerceLine(line:'T) : Line option =
        match box line with
        | :? Line as l -> Some l
        | :? Curve as crv ->
            if crv.IsLinear(State.Doc.ModelAbsoluteTolerance) then Some <|  Line(crv.PointAtStart, crv.PointAtEnd)
                else None
        | :? Guid as g ->
            match State.Doc.Objects.FindId(g).Geometry with
            | :? LineCurve as l -> Some l.Line
            | :? Curve as crv ->
                if crv.IsLinear(State.Doc.ModelAbsoluteTolerance) then Some <| Line(crv.PointAtStart, crv.PointAtEnd)
                else None
            | _ -> None
        | :? (Point3d*Point3d) as ab -> let a, b = ab in Some <| Line(a, b)
        |_ -> None

    ///<summary>Attempt to get Rhino Line Geometry using the current Documents Absolute Tolerance.</summary>
    ///<param name="line">Line, two points or Guid</param>
    ///<returns>Geometry.Line, Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceLine(line:'T) : Line=
        match RhinoScriptSyntax.TryCoerceLine(line) with
        | Some a -> a
        | None -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceLine failed on: %s " (Nice.str line)

    ///<summary>Attempt to get Rhino Arc Geometry using the current Documents Absolute Tolerance.
    /// does not return circles as arcs.</summary>
    ///<param name="arc">Guid, RhinoObject or Curve </param>
    ///<returns>a Geometry.Arc Option.</returns>
    static member TryCoerceArc(arc:'T) : Arc option=
        match box arc with
        | :? Arc as a -> Some(a)
        | :? Curve as crv ->
            let a = ref (new Arc())
            let ok = crv.TryGetArc(a,State.Doc.ModelAbsoluteTolerance)
            if ok then Some( !a )
            else None
        | :? Guid as g ->
            match State.Doc.Objects.FindId(g).Geometry with
            | :? Curve as crv ->
                let a = ref (new Arc())
                let ok = crv.TryGetArc(a,State.Doc.ModelAbsoluteTolerance)
                if ok then Some( !a )
                else None
            | _ -> None
        |_ -> None

    ///<summary>Attempt to get Rhino Arc Geometry using the current Documents Absolute Tolerance.
    /// does not return circles as arcs.</summary>
    ///<param name="arc">Guid, RhinoObject or Curve </param>
    ///<returns>Geometry.Arc, Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceArc(arc:'T) : Arc=
        match RhinoScriptSyntax.TryCoerceArc(arc) with
        | Some a -> a
        | None -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceArc failed on: %s " (Nice.str arc)


    ///<summary>Attempt to get Rhino Circle Geometry using the current Documents Absolute Tolerance.</summary>
    ///<param name="cir">Guid, RhinoObject or Curve </param>
    ///<returns>a Geometry.Circle Option.</returns>
    static member TryCoerceCircle(cir:'T) : Circle option=
        match box cir with
        | :? Circle as a -> Some(a)
        | :? Curve as crv ->
            let a = ref (new Circle())
            let ok = crv.TryGetCircle(a,State.Doc.ModelAbsoluteTolerance)
            if ok then Some( !a )
            else None
        | :? Guid as g ->
            match State.Doc.Objects.FindId(g).Geometry with
            | :? Curve as crv ->
                let a = ref (new Circle())
                let ok = crv.TryGetCircle(a,State.Doc.ModelAbsoluteTolerance)
                if ok then Some( !a )
                else None
            | _ -> None
        |_ -> None

    ///<summary>Attempt to get Rhino Circle Geometry using the current Documents Absolute Tolerance.</summary>
    ///<param name="circ">Guid, RhinoObject or Curve </param>
    ///<returns>Geometry.Circle, Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceCircle(circ:'T) : Circle=
        match RhinoScriptSyntax.TryCoerceCircle(circ) with
        | Some a -> a
        | None -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceCircle failed on: %s " (Nice.str circ)

    ///<summary>Attempt to get Rhino Ellipse Geometry using the current Documents Absolute Tolerance.</summary>
    ///<param name="cir">Guid, RhinoObject or Curve </param>
    ///<returns>a Geometry.Ellipse Option.</returns>
    static member TryCoerceEllipse(cir:'T) : Ellipse option=
        match box cir with
        | :? Ellipse as a -> Some(a)
        | :? Curve as crv ->
            let a = ref (new Ellipse())
            let ok = crv.TryGetEllipse(a,State.Doc.ModelAbsoluteTolerance)
            if ok then Some( !a )
            else None
        | :? Guid as g ->
            match State.Doc.Objects.FindId(g).Geometry with
            | :? Curve as crv ->
                let a = ref (new  Ellipse())
                let ok = crv.TryGetEllipse(a,State.Doc.ModelAbsoluteTolerance)
                if ok then Some( !a )
                else None
            | _ -> None
        |_ -> None

    ///<summary>Attempt to get Rhino Ellipse Geometry using the current Documents Absolute Tolerance.</summary>
    ///<param name="ellipse">Guid, RhinoObject or Curve </param>
    ///<returns>Geometry.Ellipse, Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceEllipse(ellipse:'T) : Ellipse=
        match RhinoScriptSyntax.TryCoerceEllipse(ellipse) with
        | Some a -> a
        | None -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceEllipse failed on: %s " (Nice.str ellipse)

    ///<summary>Attempt to get Rhino Polyline Geometry.</summary>
    ///<param name="poly">Guid, RhinoObject or Curve </param>
    ///<returns>a Geometry.Polyline Option.</returns>
    static member TryCoercePolyline(poly:'T) : Polyline option=
        match box poly with
        | :? Polyline as a -> Some(a)
        | :? PolylineCurve as crv -> Some <| crv.ToPolyline()
        | :? Curve as crv ->
                let a : ref<Polyline> = ref null
                let ok = crv.TryGetPolyline(a)
                if ok then Some( !a )
                else None
        | :? Guid as g ->
            match State.Doc.Objects.FindId(g).Geometry with
            | :? Curve as crv ->
                let a : ref<Polyline> = ref null
                let ok = crv.TryGetPolyline(a)
                if ok then Some( !a )
                else None
            | _ -> None
        |_ -> None

    ///<summary>Attempt to get Rhino Polyline Geometry.</summary>
    ///<param name="poly">Guid, RhinoObject or Curve </param>
    ///<returns>a Geometry.Polyline Option.</returns>
    static member CoercePolyline(poly:'T) : Polyline =
        match RhinoScriptSyntax.TryCoercePolyline poly with
        |None -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoercePolyline failed on: %s " (Nice.str poly)
        |Some pl -> pl


    //----------------------------------------------------
    //---------------Coerce only (no TryCoerce) ----------  TODO: add TryCoerce ?
    //----------------------------------------------------


    ///<summary>Attempt to get Rhino LayerObject from the document for a given full name.</summary>
    ///<param name="name">(string) The layer's name.</param>
    ///<returns>DocObjects.Layer </returns>
    static member CoerceLayer (name:string) : DocObjects.Layer =
        let i = State.Doc.Layers.FindByFullPath(name, RhinoMath.UnsetIntIndex)
        if i = RhinoMath.UnsetIntIndex then
            let lay = State.Doc.Layers.FindName name
            if isNull lay then
                RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceLayer: could not find a layer named '%s'" name
            else
                lay
        else
            State.Doc.Layers.[i]


    ///<summary>Attempt to get Rhino LayerObject from the document with a given objectId.</summary>
    ///<param name="layerId">(Guid) The layer's Guid.</param>
    ///<returns>DocObjects.Layer</returns>
    static member CoerceLayer (layerId:Guid) : DocObjects.Layer=
        if layerId = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceLayer: input Guid is Guid.Empty"
        let l = State.Doc.Layers.FindId(layerId)
        if isNull l then
            if notNull (State.Doc.Objects.FindId(layerId)) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceLayer works on  Guid of a Layer Object, not the Guid of a Document Object (with Geometry) '%s'" (Nice.str layerId)
            else
                RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceLayer: could not find Guid %O in State.Doc.Layer table'" layerId
        l

    ///<summary>Returns the Rhino Block instance object for a given Id.</summary>
    ///<param name="objectId">(Guid) Id of block instance</param>
    ///<returns>(DocObjects.InstanceObject) block instance object.</returns>
    static member CoerceBlockInstanceObject(objectId:Guid) : DocObjects.InstanceObject =
        match RhinoScriptSyntax.CoerceRhinoObject(objectId) with
        | :? DocObjects.InstanceObject as b -> b
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceBlockInstanceObject: unable to coerce Block InstanceObject from '%s'" (Nice.str objectId)



    //-------------------views ---------------------


    ///<summary>Attempt to get Rhino View Object from the name of the view, can be a standard or page view.</summary>
    /// <param name="nameOrId">(string or Guid) Name or Guid the view, empty string will return the Active view</param>
    /// <returns>a State.Doc.View Option.</returns>
    static member TryCoerceView (nameOrId:'T) : Option<Display.RhinoView> =
        match box nameOrId with
        | :? Guid as g ->
            let viewObj = State.Doc.Views.Find(g)
            if isNull viewObj then
                None
            else
                Some viewObj
        | :? string as view ->
            if isNull view then
                None
            elif view = "" then
                Some State.Doc.Views.ActiveView
            else
                let allViews =
                    State.Doc.Views.GetViewList(includeStandardViews=true, includePageViews=true)
                    |> Array.filter (fun v-> v.MainViewport.Name = view)
                if allViews.Length = 1 then
                    Some allViews.[0]
                else
                    None
        | _ -> None


    ///<summary>Attempt to get Rhino View Object from the name of the view, can be a standard or page view.</summary>
    ///<param name="nameOrId">(string or Guid) Name or Guid the view, empty string will return the Active view</param>
    ///<returns>a State.Doc.View object. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceView (nameOrId:'T) : Display.RhinoView =
        match box nameOrId with
        | :? Guid as g ->
            let viewObj = State.Doc.Views.Find(g)
            if isNull viewObj then
                RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceView: could not CoerceView from '%O'" g
            else
                viewObj
        | :? string as view ->
            if isNull view then
                RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceView: failed on null for view name input" // or State.Doc.Views.ActiveView
            elif view = "" then
                State.Doc.Views.ActiveView
            else
                let allViews =
                    State.Doc.Views.GetViewList(includeStandardViews=true, includePageViews=true)
                    |> Array.filter (fun v-> v.MainViewport.Name = view)
                if allViews.Length = 1 then
                    allViews.[0]
                else
                    RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceView: could not CoerceView '%s'" view
        | _ ->
            RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceView: Cannot get view from %A" nameOrId






    ///<summary>Attempt to get Rhino Page (or Layout) View Object from the name of the Layout.</summary>
    ///<param name="nameOrId">(string) Name of the Layout</param>
    ///<returns>a State.Doc.View object. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoercePageView (nameOrId:'T) : Display.RhinoPageView =
        match box nameOrId with
        | :? Guid as g ->
            let view = State.Doc.Views.Find(g)
            if isNull view then RhinoScriptingException.Raise "RhinoScriptSyntax.CoercePageView: could not CoerceView  from '%O'" g
            else
                try view :?> Display.RhinoPageView
                with _  -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoercePageView: the view found '%s' is not a page view" view.MainViewport.Name

        | :? string as view ->
            if isNull view then RhinoScriptingException.Raise "RhinoScriptSyntax.CoercePageView: failed on null for view name input" // or State.Doc.Views.ActiveView
            else
                let allViews = State.Doc.Views.GetPageViews()|> Array.filter (fun v-> v.PageName = view)
                if allViews.Length = 1 then allViews.[0]
                elif allViews.Length > 1 then RhinoScriptingException.Raise "RhinoScriptSyntax.CoercePageView: more than one page called '%s'" view
                else  RhinoScriptingException.Raise "RhinoScriptSyntax.CoercePageView: Layout called '%s' not found" view

        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoercePageView: Cannot get view from %O" nameOrId

    ///<summary>Attempt to get Detail view rectangle Geometry.</summary>
    ///<param name="objectId">(Guid) objectId of Detail object</param>
    ///<returns>a Geometry.DetailView. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceDetailView (objectId:Guid) : DetailView =
        match RhinoScriptSyntax.CoerceGeometry objectId with
        | :?  DetailView as a -> a
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceDetailView failed on %s"  (Nice.str objectId)

    ///<summary>Attempt to get Detail view rectangle Object.</summary>
    ///<param name="objectId">(Guid) objectId of Detail object</param>
    ///<returns>a DocObjects.DetailViewObject. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceDetailViewObject (objectId:Guid) : DocObjects.DetailViewObject =
        match RhinoScriptSyntax.CoerceRhinoObject objectId with
        | :?  DocObjects.DetailViewObject as a -> a
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceDetailViewObject failed on %s"  (Nice.str objectId)


    //-------Annotation ----


    ///<summary>Attempt to get TextDot Geometry.</summary>
    ///<param name="objectId">(Guid) objectId of TextDot object</param>
    ///<returns>a Geometry.TextDot. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceTextDot (objectId:Guid) : TextDot =
        match RhinoScriptSyntax.CoerceGeometry objectId with
        | :?  TextDot as a -> a
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceTextDot failed on: %s " (Nice.str objectId)

    ///<summary>Attempt to get TextEntity Geometry (for the text Object use rs.CoerceTextObject) .</summary>
    ///<param name="objectId">(Guid) objectId of TextEntity object</param>
    ///<returns>a Geometry.TextEntity. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceTextEntity (objectId:Guid) : TextEntity =
        match RhinoScriptSyntax.CoerceGeometry objectId with
        | :?  TextEntity as a -> a
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceTextEntity failed on: %s " (Nice.str objectId)


    ///<summary>Attempt to get Rhino TextObject Annotation Object.</summary>
    ///<param name="objectId">(Guid) objectId of TextObject</param>
    ///<returns>(DocObjects.TextObject. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceTextObject (objectId:Guid) : DocObjects.TextObject =
        match RhinoScriptSyntax.CoerceRhinoObject objectId with
        | :?  DocObjects.TextObject as a -> a
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceTextObject failed on: %s " (Nice.str objectId)

    ///<summary>Attempt to get Hatch Geometry.</summary>
    ///<param name="objectId">(Guid) objectId of Hatch object</param>
    ///<returns>a Geometry.CoerceHatch. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceHatch (objectId:Guid) : Hatch =
        match RhinoScriptSyntax.CoerceGeometry objectId with
        | :?  Hatch as a -> a
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceHatch failed on: %s " (Nice.str objectId)


    ///<summary>Attempt to get Rhino Hatch Object.</summary>
    ///<param name="objectId">(Guid) objectId of Hatch object</param>
    ///<returns>(DocObjects.HatchObject. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceHatchObject (objectId:Guid) : DocObjects.HatchObject =
        match RhinoScriptSyntax.CoerceRhinoObject objectId with
        | :?  DocObjects.HatchObject as a -> a
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceHatchObject failed on: %s " (Nice.str objectId)

    ///<summary>Attempt to get Rhino Annotation Base Object.</summary>
    ///<param name="objectId">(Guid) objectId of annotation object</param>
    ///<returns>(DocObjects.AnnotationObjectBase. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceAnnotation (objectId:Guid) : DocObjects.AnnotationObjectBase =
        match RhinoScriptSyntax.CoerceRhinoObject objectId with
        | :?  DocObjects.AnnotationObjectBase as a -> a
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceAnnotation failed on: %s " (Nice.str objectId)


    ///<summary>Attempt to get Rhino Leader Annotation Object.</summary>
    ///<param name="objectId">(Guid) objectId of Leader object</param>
    ///<returns>(DocObjects.LeaderObject. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceLeader (objectId:Guid) : DocObjects.LeaderObject =
        match RhinoScriptSyntax.CoerceRhinoObject objectId with
        | :?  DocObjects.LeaderObject as a -> a
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceLeader failed on: %s " (Nice.str objectId)

    ///<summary>Attempt to get Rhino LinearDimension Annotation Object.</summary>
    ///<param name="objectId">(Guid) objectId of LinearDimension object</param>
    ///<returns>(DocObjects.LinearDimensionObject. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceLinearDimension (objectId:Guid) : DocObjects.LinearDimensionObject =
        match RhinoScriptSyntax.CoerceRhinoObject objectId with
        | :?  DocObjects.LinearDimensionObject as a -> a
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceLinearDimension failed on: %s " (Nice.str objectId)

    //---------Geometry ------------


    ///<summary>Converts input into a Rhino.Geometry.Point3d if possible.</summary>
    ///<param name="pt">Input to convert, Point3d, Vector3d, Point3f, Vector3f, str, Guid, or seq</param>
    ///<returns>a Rhino.Geometry.Point3d, Raises a RhinoScriptingException if coerce failed.</returns>
    static member Coerce3dPoint(pt:'T) : Point3d =
        let inline  point3dOf3(x:^x, y:^y, z:^z) =
            try Point3d(float (x), float(y), float(z))
            with _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.Coerce3dPoint: Could not Coerce the 3 values %O, %O and %O to a Point3d" x y z
        let b = box pt
        match b with
        | :? Point3d    as pt                 -> pt
        | :? Point3f    as pt                 -> Point3d(pt)
        //| :? Vector3d   as v                  -> Point3d(v) //don't confuse vectors and points !
        | :? DocObjects.PointObject as po     -> po.PointGeometry.Location
        | :? TextDot as td                    -> td.Point
        | :? (float*float*float) as xyz       -> let x, y, z = xyz in Point3d(x, y, z)
        | :? (decimal*decimal*decimal) as xyz -> let x, y, z = xyz in Point3d(float(x), float(y), float(z))
        | :? (single*single*single) as xyz    -> let x, y, z = xyz in Point3d(float(x), float(y), float(z))
        | :? (int*int*int) as xyz             -> let x, y, z = xyz in Point3d(float(x), float(y), float(z))
        | _ ->
            try
                match b with
                | :? (Point3d option) as pto   -> pto.Value // from UI function
                | :? option<Guid> as go      -> ((State.Doc.Objects.FindId(go.Value).Geometry) :?> Point).Location
                | :? (string*string*string) as xyz  -> let x, y, z = xyz in Point3d(parseFloatEnDe(x), parseFloatEnDe(y), parseFloatEnDe(z))
                | :? Guid as g ->  ((State.Doc.Objects.FindId(g).Geometry) :?> Point).Location
                | :? seq<float>  as xyz  ->  point3dOf3(Seq.item 0 xyz, Seq.item 3 xyz, Seq.item 2 xyz)
                | :? seq<int>  as xyz  ->    point3dOf3(Seq.item 0 xyz, Seq.item 3 xyz, Seq.item 2 xyz)
                | :? seq<string> as xyz  ->  point3dOf3(Seq.item 0 xyz, Seq.item 3 xyz, Seq.item 2 xyz)
                | :? string as s  ->
                    let xs = s.Split(';')
                    if Seq.length xs > 2 then
                        Point3d(parseFloatEnDe(Seq.item 0 xs), parseFloatEnDe(Seq.item 1 xs), parseFloatEnDe(Seq.item 2 xs))
                    else
                        let ys = s.Split(',')
                        Point3d(parseFloatEnDe(Seq.item 0 ys), parseFloatEnDe(Seq.item 1 ys), parseFloatEnDe(Seq.item 2 ys))
                |_ -> RhinoScriptingException.Raise "RhinoScriptSyntax.Coerce3dPoint failed on: %s " (Nice.str pt)
            with _ ->
                RhinoScriptingException.Raise "RhinoScriptSyntax.Coerce3dPoint failed on: %s " (Nice.str pt)

    ///<summary>Attempt to get Rhino Point Object.</summary>
    ///<param name="objectId">(Guid) objectId of Point object</param>
    ///<returns>a DocObjects.PointObject, Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoercePointObject (objectId:Guid) : DocObjects.PointObject =
        match RhinoScriptSyntax.CoerceRhinoObject objectId with
        | :?  DocObjects.PointObject as a -> a
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoercePointObject failed on: %s " (Nice.str objectId)

    ///<summary>Convert input into a Rhino.Geometry.Point2d if possible.</summary>
    ///<param name="point">input to convert, Point3d, Vector3d, Point3f, Vector3f, str, Guid, or seq</param>
    ///<returns>a Rhino.Geometry.Point2d, Raises a RhinoScriptingException if coerce failed.</returns>
    static member Coerce2dPoint(point:'T) : Point2d =
        match box point with
        | :? Point2d    as point -> point
        | :? Point3d    as point -> Point2d(point.X, point.Y)
        | :? (float*float) as xy  -> let x, y = xy in Point2d(x, y)
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.Coerce2dPoint: could not Coerce: Could not convert %A to a Point2d"  point

    ///<summary>Convert input into a Rhino.Geometry.Vector3d if possible.</summary>
    ///<param name="vec">input to convert, Point3d, Vector3d, Point3f, Vector3f, str, Guid, or seq</param>
    ///<returns> a Rhino.Geometry.Vector3d, Raises a RhinoScriptingException if coerce failed.</returns>
    static member Coerce3dVector(vec:'T) : Vector3d =
        let inline vecOf3(x:^x, y:^y, z:^z) =
            try Vector3d(float (x), float(y), float(z))
            with _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.Coerce3dVector: Could not Coerce %O, %O and %O to Vector3d" x y z
        let b = box vec
        match b with
        | :? Vector3d   as v                  -> v
        | :? Vector3f   as v                  -> Vector3d(v)
        | :? (float*float*float) as xyz       -> let x, y, z = xyz in Vector3d(x, y, z)
        | :? (decimal*decimal*decimal) as xyz -> let x, y, z = xyz in Vector3d(float(x), float(y), float(z))
        | :? (single*single*single) as xyz    -> let x, y, z = xyz in Vector3d(float(x), float(y), float(z))
        | :? (int*int*int) as xyz             -> let x, y, z = xyz in Vector3d(float(x), float(y), float(z))
        | _ ->
            try
                match b with
                | :? Guid as g ->  (State.Doc.Objects.FindId(g).Geometry :?> LineCurve).Line.Direction
                | :? (Vector3d option) as v   -> v.Value // from UI function
                | :? option<Guid> as go      -> (State.Doc.Objects.FindId(go.Value).Geometry :?> LineCurve).Line.Direction
                | :? (string*string*string) as xyz  -> let x, y, z = xyz in Vector3d(parseFloatEnDe(x), parseFloatEnDe(y), parseFloatEnDe(z))
                | :? seq<float>  as xyz  ->  vecOf3(Seq.item 0 xyz, Seq.item 3 xyz, Seq.item 2 xyz)
                | :? seq<int>  as xyz  ->    vecOf3(Seq.item 0 xyz, Seq.item 3 xyz, Seq.item 2 xyz)
                | :? seq<string> as xyz  ->  vecOf3(Seq.item 0 xyz, Seq.item 3 xyz, Seq.item 2 xyz)
                | :? string as s  ->
                    let xs = s.Split(';')
                    if Seq.length xs > 2 then
                        Vector3d(parseFloatEnDe(Seq.item 0 xs), parseFloatEnDe(Seq.item 1 xs), parseFloatEnDe(Seq.item 2 xs))
                    else
                        let ys = s.Split(',')
                        Vector3d(parseFloatEnDe(Seq.item 0 ys), parseFloatEnDe(Seq.item 1 ys), parseFloatEnDe(Seq.item 2 ys))
                |_ -> RhinoScriptingException.Raise "RhinoScriptSyntax.Coerce3dVector failed on: %s " (Nice.str vec)
            with _ ->
                RhinoScriptingException.Raise "RhinoScriptSyntax.Coerce3dVector failed on: %s " (Nice.str vec)



    ///<summary>Convert input into a Rhino.Geometry.Plane if possible.</summary>
    ///<param name="plane">Plane, point, list, tuple</param>
    ///<returns>(Rhino.Geometry.Plane. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoercePlane(plane:'T) : Plane =
        match box plane with
        | :? Plane  as plane -> plane
        | _ ->
            try
                let pt = RhinoScriptSyntax.Coerce3dPoint(plane)
                let mutable pl = Plane.WorldXY
                pl.Origin <- pt
                pl
            with _ ->
                RhinoScriptingException.Raise "RhinoScriptSyntax.CoercePlane failed on: %s " (Nice.str plane)

    ///<summary>Convert input into a Rhino.Geometry.Transform Transformation Matrix if possible.</summary>
    ///<param name="xForm">object to convert</param>
    ///<returns>(Rhino.Geometry.Transform. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceXform(xForm:'T) : Transform =
        match box xForm with
        | :? Transform  as xForm -> xForm
        | :? seq<seq<float>>  as xss -> // TODO verify row, column order !!
                let mutable t= Transform()
                try
                    for c, xs in Seq.indexed xss do
                        for r, x in Seq.indexed xs do
                            t.[c, r] <- x
                with
                    | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceXform: seq<seq<float>> %s can not be converted to a Transformation Matrix" (Nice.str xForm)
                t
        | :? ``[,]``<float>  as xss -> // TODO verify row, column order !!
                let mutable t= Transform()
                try
                    xss|> Array2D.iteri (fun i j x -> t.[i, j]<-x)
                with
                    | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceXform: Array2D %s can not be converted to a Transformation Matrix" (Nice.str xForm)
                t
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceXform: could not CoerceXform %s can not be converted to a Transformation Matrix" (Nice.str xForm)



    ///<summary>Attempt to get Surface geometry from the document with a given objectId.</summary>
    ///<param name="objectId">the object's Identifier</param>
    ///<returns>(Rhino.Geometry.Surface. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceNurbsSurface(objectId:Guid) : NurbsSurface =
        match RhinoScriptSyntax.CoerceGeometry(objectId) with
        | :? NurbsSurface as s -> s
        | :? Surface as c -> c.ToNurbsSurface()
        | :? Brep as b ->
            if b.Faces.Count = 1 then (b.Faces.[0] :> Surface).ToNurbsSurface()
            else RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceNurbsSurface failed on %s from Brep with %d Faces" (Nice.str objectId)   b.Faces.Count
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceNurbsSurface failed on: %O "  objectId



    ///<summary>Attempt to get Rhino PointCloud Geometry.</summary>
    ///<param name="objectId">(Guid) objectId of PointCloud object</param>
    ///<returns>a Geometry.PointCloud. Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoercePointCloud (objectId:Guid) : PointCloud =
        match RhinoScriptSyntax.CoerceGeometry objectId with
        | :?  PointCloud as a -> a
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoercePointCloud failed on: %s " (Nice.str objectId)


    ///<summary>Attempt to get a System.Drawing.Color also works on natural language color strings see Drawing.ColorTranslator.FromHtml.</summary>
    ///<param name="color">string, tuple with  or 3 or 4 items</param>
    ///<returns>System.Drawing.Color in ARGB form (not as named color) this will provide better comparison to other colors.
    /// For example the named color Red is not equal to fromRGB(255, 0, 0). Raises a RhinoScriptingException if coerce failed.</returns>
    static member CoerceColor(color:'T) : Drawing.Color =
        match box color with
        | :? Drawing.Color  as c -> Drawing.Color.FromArgb(int c.A, int c.R, int c.G, int c.B) //https://stackoverflow.com/questions/20994753/compare-two-color-objects
        | :? (int*int*int) as rgb       ->
            let red , green, blue   = rgb
            if red  <0 || red  >255 then RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceColor: cannot create color form red %d, blue %d and green %d" red green blue
            if green<0 || green>255 then RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceColor: cannot create color form red %d, blue %d and green %d" red green blue
            if blue <0 || blue >255 then RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceColor: cannot create color form red %d, blue %d and green %d" red green blue
            Drawing.Color.FromArgb( red, green, blue)

        | :? (int*int*int*int) as argb  ->
            let alpha, red , green, blue   = argb
            if red  <0 || red  >255 then RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceColor: cannot create color form red %d, blue %d and green  %d alpha %d" red green blue alpha
            if green<0 || green>255 then RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceColor: cannot create color form red %d, blue %d and green  %d alpha %d" red green blue alpha
            if blue <0 || blue >255 then RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceColor: cannot create color form red %d, blue %d and green  %d alpha %d" red green blue alpha
            if alpha<0 || alpha >255 then RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceColor: cannot create color form red %d, blue %d and green %d alpha %d" red green blue alpha
            Drawing.Color.FromArgb(alpha, red, green, blue)
        | :? string  as s ->
            try
                let c = Drawing.ColorTranslator.FromHtml(s)
                Drawing.Color.FromArgb(int c.A, int c.R, int c.G, int c.B)// convert to unnamed color
            with _ ->
                //try
                //    let c = Drawing.Color.FromName(s) // for invalid names ( a hex string) this still returns named color black !!
                //    Drawing.Color.FromArgb(int c.A, int c.R, int c.G, int c.B)// convert to unnamed color
                //with _ ->
                    RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceColor:: could not Coerce %A to a Color" color

                //     try Windows.Media.ColorConverter.ConvertFromString(s)
                //     with _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.: could not Coerce %A to a Color" c
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceColor:: could not Coerce %A to a Color" color

    //<summary>Attempt to get a Sequence of Guids from input</summary>
    //<param name="Ids">list of Guids</param>
    //<returns>Guid seq) Fails on bad input</returns>
    //static member CoerceGuidList(Ids:'T) : seq<Guid> =
    //    match box Ids with
    //    | :? Guid  as g -> if Guid.Empty = g then fail() else [|g|] :> seq<Guid>
    //    | :? seq<obj> as gs ->
    //                        try
    //                            gs |> Seq.map RhinoScriptSyntax.CoerceGuid
    //                        with _ ->
    //                            RhinoScriptingException.Raise "RhinoScriptSyntax.: could not CoerceGuidList: %A can not be converted to a Sequence(IEnumerable) of Guids" Ids
    //    | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.CoerceGuidList: could not CoerceGuidList: %A can not be converted to a Sequence(IEnumerable) of Guids" Ids

        //<summary>Convert input into a Rhino.Geometry.Point3d sequence if possible</summary>
    //<param name="points">input to convert, list of , Point3d, Vector3d, Point3f, Vector3f, str, Guid, or seq</param>
    //<returns>(Rhino.Geometry.Point3d seq) Fails on bad input</returns>
    //static member Coerce3dPointList(points:'T) : Point3d seq=
    //    try Seq.map RhinoScriptSyntax.Coerce3dPoint points //|> Seq.cache
    //    with _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.Coerce3dPointList: could not Coerce: Could not convert %A to a list of 3d points"  points

    //<summary>Convert input into a Rhino.Geometry.Point3d sequence if possible</summary>
    //<param name="points">input to convert, list of , Point3d, Vector3d, Point3f, Vector3f, str, Guid, or seq</param>
    //<returns>(Rhino.Geometry.Point2d seq) Fails on bad input</returns>
    //static member Coerce2dPointList(points:'T) : Point2d seq=
    //    try Seq.map RhinoScriptSyntax.Coerce2dPoint points //|> Seq.cache
    //    with _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.Coerce2dPointList: could not Coerce: Could not convert %A to a list of 2d points"  points

    //---End of header marker: don't change: {@$%^&*()*&^%$@}




    ///<summary>Add a new layer to the document. If it does not exist yet.
    /// By default Ambiguous Unicode characters are not allowed in layer name. This can be changed via optional parameter.
    /// If layers or parent layers exist already color, visibility and locking parameters are ignored.</summary>
    ///<param name="name">(string) Optional, The name of the new layer. If omitted, Rhino automatically  generates the layer name.</param>
    ///<param name="color">(Drawing.Color) Optional, A Red-Green-Blue color value. If omitted a random (non yellow)  color wil be chosen.</param>
    ///<param name="visible">(int) Optional, default value: <c>2</c>
    ///   Layer visibility:
    ///   0 = explicitly Off (even if parent is already Off)
    ///   1 = On and turn parents on too
    ///   2 = inherited from parent, or On by default</param>
    ///<param name="locked">(int) Optional, default value: <c>2</c>
    ///   Layer locking state:
    ///   0 = Unlocked this and parents
    ///   1 = explicitly Locked (even if parent is already Locked)
    ///   2 = inherited from parent, or Unlocked default</param>
    ///<param name="parent">(string) Optional, Name of existing or non existing parent layer. </param>
    ///<param name="allowAllUnicode">(bool) Optional, Allow ambiguous Unicode characters too </param>
    ///<param name="collapseParents">(bool) Optional, Collapse parent layers in Layer UI </param>
    ///<returns>(int) The index in the layer table. Do Doc.Layers.[i].FullPath to get the full name of the new layer.
    /// E.g. The function rs.Add can then take this layer index.</returns>
    static member AddLayer( [<OPT;DEF(null:string)>]name:string
                          , [<OPT;DEF(Drawing.Color())>]color:Drawing.Color
                          , [<OPT;DEF(2)>]visible:int
                          , [<OPT;DEF(2)>]locked:int
                          , [<OPT;DEF(null:string)>]parent:string
                          , [<OPT;DEF(false:bool)>]allowAllUnicode:bool
                          , [<OPT;DEF(false:bool)>]collapseParents:bool) : int =

        let col = if color.IsEmpty then UtilLayer.randomLayerColor else (fun () -> color)
        if notNull parent && isNull name then
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddLayer if parent name is given (%s) the child name must be given too." parent

        let vis =   match visible with
                    | 0 ->  UtilLayer.Off
                    | 1 ->  UtilLayer.On
                    | 2 ->  UtilLayer.ByParent
                    | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.AddLayer Bad value vor Visibility: %d, it may be 0, 1 or 2" visible
        let loc =   match locked with
                    | 0 ->  UtilLayer.Off
                    | 1 ->  UtilLayer.On
                    | 2 ->  UtilLayer.ByParent
                    | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.AddLayer Bad value vor Locked: %d, it may be 0, 1 or 2" locked

        if isNull name then
            //State.Doc.Layers.[UtilLayer.createDefaultLayer(col, true, false)].FullPath
            UtilLayer.createDefaultLayer(col, true, false)
        else
            let names = if isNull parent then name else parent+ "::" + name
            let fOrC  = UtilLayer.getOrCreateLayer(names, col, vis, loc, allowAllUnicode, collapseParents)
            //State.Doc.Layers.[i].FullPath
            fOrC.Index


    ///<summary>Returns the full layer name of an object.
    /// parent layers are separated by <c>::</c>.</summary>
    ///<param name="objectId">(Guid) The identifier of the object</param>
    ///<returns>(string) The object's current layer.</returns>
    static member ObjectLayer(objectId:Guid) : string = //GET
        let obj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let index = obj.Attributes.LayerIndex
        State.Doc.Layers.[index].FullPath

    ///<summary>Modifies the layer of an object , optionally creates layer if it does not exist yet.</summary>
    ///<param name="objectId">(Guid) The identifier of the object</param>
    ///<param name="layer">(string) Name of an existing layer</param>
    ///<param name="createLayerIfMissing">(bool) Optional, default value: <c>false</c> Set true to create Layer if it does not exist yet.</param>
    ///<param name="allowAllUnicode">(bool) Optional, Allow Ambiguous Unicode characters too </param>
    ///<param name="collapseParents">(bool) Optional, Collapse parent layers in Layer UI </param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectLayer( objectId:Guid
                             , layer:string
                             ,[<OPT;DEF(false)>]createLayerIfMissing:bool
                             ,[<OPT;DEF(false:bool)>]allowAllUnicode:bool
                             ,[<OPT;DEF(false:bool)>]collapseParents:bool) : unit = //SET
        let obj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let layerIndex =
            if createLayerIfMissing then  UtilLayer.getOrCreateLayer(layer, UtilLayer.randomLayerColor, UtilLayer.ByParent, UtilLayer.ByParent, allowAllUnicode,collapseParents).Index
            else                          RhinoScriptSyntax.CoerceLayer(layer).Index
        obj.Attributes.LayerIndex <- layerIndex
        obj.CommitChanges() |> ignore
        State.Doc.Views.Redraw()

    ///<summary>Modifies the layer of multiple objects, optionally creates layer if it does not exist yet.</summary>
    ///<param name="objectIds">(Guid seq) The identifiers of the objects</param>
    ///<param name="layer">(string) Name of an existing layer</param>
    ///<param name="createLayerIfMissing">(bool) Optional, default value: <c>false</c> Set true to create Layer if it does not exist yet.</param>
    ///<param name="allowUnicode">(bool) Optional, Allow Ambiguous Unicode characters too </param>
    ///<param name="collapseParents">(bool) Optional, Collapse parent layers in Layer UI </param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectLayer( objectIds:Guid seq
                             , layer:string
                             , [<OPT;DEF(false)>]createLayerIfMissing:bool
                             , [<OPT;DEF(false:bool)>]allowUnicode:bool
                             , [<OPT;DEF(false:bool)>]collapseParents:bool) : unit = //MULTISET
        let layerIndex =
            if createLayerIfMissing then  UtilLayer.getOrCreateLayer(layer, UtilLayer.randomLayerColor, UtilLayer.ByParent, UtilLayer.ByParent, allowUnicode, collapseParents).Index
            else                          RhinoScriptSyntax.CoerceLayer(layer).Index
        for objectId in objectIds do
            let obj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            obj.Attributes.LayerIndex <- layerIndex
            obj.CommitChanges() |> ignore
        State.Doc.Views.Redraw()

    ///<summary>Modifies the layer of an object.</summary>
    ///<param name="objectId">(Guid) The identifier of the object</param>
    ///<param name="layerIndex">(int) Index of layer in layer table</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectLayer(objectId:Guid, layerIndex:int) : unit = //SET
        let obj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if layerIndex < 0 || layerIndex >= State.Doc.Layers.Count then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectLayer: Setting it via index failed. bad index '%d' (max %d) on: %s " layerIndex State.Doc.Layers.Count (Nice.str objectId)
        if State.Doc.Layers.[layerIndex].IsDeleted then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectLayer: Setting it via index failed.  index '%d' is deleted.  on: %s " layerIndex  (Nice.str objectId)
        obj.Attributes.LayerIndex <- layerIndex
        obj.CommitChanges() |> ignore
        State.Doc.Views.Redraw()

    ///<summary>Modifies the layer of multiple objects, optionally creates layer if it does not exist yet.</summary>
    ///<param name="objectIds">(Guid seq) The identifiers of the objects</param>
    ///<param name="layerIndex">(int) Index of layer in layer table</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectLayer(objectIds:Guid seq, layerIndex:int) : unit = //MULTISET
        if layerIndex < 0 || layerIndex >= State.Doc.Layers.Count then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectLayer: Setting it via index failed. bad index '%d' (max %d) on %d objects " layerIndex State.Doc.Layers.Count (Seq.length objectIds)
        if State.Doc.Layers.[layerIndex].IsDeleted then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectLayer: Setting it via index failed.  index '%d' is deleted.  on %d objects" layerIndex  (Seq.length objectIds)
        for objectId in objectIds do
            let obj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            obj.Attributes.LayerIndex <- layerIndex
            obj.CommitChanges() |> ignore
        State.Doc.Views.Redraw()

    ///<summary>Changes the Name of a layer if than name is yet non existing. Fails if layer exists already. Currently only ASCII characters are allowed.</summary>
    ///<param name="currentLayerName">(string) The name an existing layer to rename</param>
    ///<param name="newLayerName">(string) The new name</param>
    ///<param name="allowUnicode">(bool) Optional, Allow ambiguous Unicode characters too </param>
    ///<returns>(unit) void, nothing.</returns>
    static member ChangeLayerName( currentLayerName:string
                                 , newLayerName:string
                                 , [<OPT;DEF(false:bool)>]allowUnicode:bool ) : unit =
        let i = State.Doc.Layers.FindByFullPath(currentLayerName, RhinoMath.UnsetIntIndex)
        if i = RhinoMath.UnsetIntIndex then
            RhinoScriptingException.Raise "RhinoScriptSyntax.ChangeLayerName: could not FindByFullPath Layer from currentLayerName: '%s'" currentLayerName
        else
            UtilLayer.failOnBadShortLayerName (newLayerName, newLayerName, allowUnicode)
            let lay = State.Doc.Layers.[i]
            let ps = lay.FullPath.Split( [|"::"|], StringSplitOptions.RemoveEmptyEntries) //|> ResizeArray.ofArray
            ps.Last <- newLayerName
            let np = String.concat "::" ps
            let ni = State.Doc.Layers.FindByFullPath(np, RhinoMath.UnsetIntIndex)
            if ni >= 0 then
                RhinoScriptingException.Raise "RhinoScriptSyntax.ChangeLayerName: could not rename Layer '%s' to '%s', it already exists." currentLayerName np
            else
                lay.Name <- newLayerName


    ///<summary>Returns the current layer.</summary>
    ///<returns>(string) The full name of the current layer.</returns>
    static member CurrentLayer() : string = //GET
        State.Doc.Layers.CurrentLayer.FullPath


    ///<summary>Changes the current layer.</summary>
    ///<param name="layer">(string) The name of an existing layer to make current</param>
    ///<returns>(unit) void, nothing.</returns>
    static member CurrentLayer(layer:string) : unit = //SET
        let i = State.Doc.Layers.FindByFullPath(layer, RhinoMath.UnsetIntIndex)
        if i = RhinoMath.UnsetIntIndex then RhinoScriptingException.Raise "RhinoScriptSyntax.CurrentLayer: could not FindByFullPath Layer from name'%s'" layer
        if not<|  State.Doc.Layers.SetCurrentLayerIndex(i, quiet=true) then RhinoScriptingException.Raise "RhinoScriptSyntax.CurrentLayer Set CurrentLayer to %s failed" layer

    ///<summary>Removes an existing layer from the document. The layer to be removed
    ///    cannot be the current layer. Unlike the PurgeLayer method, the layer must
    ///    be empty, or contain no objects, before it can be removed. Any layers that
    ///    are children of the specified layer will also be removed if they are also
    ///    empty.</summary>
    ///<param name="layer">(string) The name of an existing empty layer</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member DeleteLayer(layer:string) : bool =
        let i = State.Doc.Layers.FindByFullPath(layer, RhinoMath.UnsetIntIndex)
        if i = RhinoMath.UnsetIntIndex then RhinoScriptingException.Raise "RhinoScriptSyntax.DeleteLayer: could not FindByFullPath Layer from name'%s'" layer
        State.Doc.Layers.Delete(i, quiet=true)


    ///<summary>Expands or Collapses a layer. Expanded layers can be viewed in Rhino's layer dialog.
    /// Use the functions rs.UnCollapseLayer and rs.CollapseLayer to expand and collapse their children too.</summary>
    ///<param name="layer">(string) Name of the layer to expand</param>
    ///<param name="expand">(bool) True to expand, False to collapse</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ExpandLayer(layer:string, expand:bool) : unit =
        let i = State.Doc.Layers.FindByFullPath(layer, RhinoMath.UnsetIntIndex)
        if i = RhinoMath.UnsetIntIndex then RhinoScriptingException.Raise "RhinoScriptSyntax.ExpandLayer: could not FindByFullPath Layer from name'%s'" layer
        let layer = State.Doc.Layers.[i]
        if layer.IsExpanded <> expand then
            layer.IsExpanded <- expand



    ///<summary>Verifies the existence of a layer in the document.</summary>
    ///<param name="layer">(string) The name of a layer to search for</param>
    ///<returns>(bool) True on success, otherwise False.</returns>
    static member IsLayer(layer:string) : bool =
        let i = State.Doc.Layers.FindByFullPath(layer, RhinoMath.UnsetIntIndex)
        i <> RhinoMath.UnsetIntIndex


    ///<summary>Checks if the objects on a layer can be changed (normal).</summary>
    ///<param name="layer">(string) The name of an existing layer</param>
    ///<returns>(bool) True on success, otherwise False.</returns>
    static member IsLayerChangeable(layer:string) : bool =
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        let rc = layer.IsVisible && not layer.IsLocked
        rc


    ///<summary>Checks if a layer is a child of another layer.</summary>
    ///<param name="layer">(string) The name of the layer to test against</param>
    ///<param name="test">(string) The name to the layer to test</param>
    ///<returns>(bool) True on success, otherwise False.</returns>
    static member IsLayerChildOf(layer:string, test:string) : bool =
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        let test = RhinoScriptSyntax.CoerceLayer(test)
        test.IsChildOf(layer)


    ///<summary>Checks if a layer is the current layer.</summary>
    ///<param name="layer">(string) The name of an existing layer</param>
    ///<returns>(bool) True on success, otherwise False.</returns>
    static member IsLayerCurrent(layer:string) : bool =
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        layer.Index = State.Doc.Layers.CurrentLayerIndex


    ///<summary>Checks if an existing layer is empty, or contains no objects.</summary>
    ///<param name="layer">(string) The name of an existing layer</param>
    ///<returns>(bool) True on success, otherwise False.</returns>
    static member IsLayerEmpty(layer:string) : bool =
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        let rhobjs = State.Doc.Objects.FindByLayer(layer)
        isNull rhobjs || rhobjs.Length = 0


    ///<summary>Checks if a layer is expanded. Expanded layers can be viewed in
    ///    Rhino's layer dialog.</summary>
    ///<param name="layer">(string) The name of an existing layer</param>
    ///<returns>(bool) True on success, otherwise False.</returns>
    static member IsLayerExpanded(layer:string) : bool =
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        layer.IsExpanded


    ///<summary>Checks if a layer is locked
    /// persistent or non persistent locking return true
    /// via layer.IsLocked.</summary>
    ///<param name="layer">(string) The name of an existing layer</param>
    ///<returns>(bool) True on success, otherwise False.</returns>
    static member IsLayerLocked(layer:string) : bool =
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        layer.IsLocked


    ///<summary>Checks if a layer is on.</summary>
    ///<param name="layer">(string) The name of an existing layer</param>
    ///<returns>(bool) True on success, otherwise False.</returns>
    static member IsLayerOn(layer:string) : bool =
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        layer.IsVisible


    ///<summary>Checks if an existing layer is selectable (normal and reference).</summary>
    ///<param name="layer">(string) The name of an existing layer</param>
    ///<returns>(bool) True on success, otherwise False.</returns>
    static member IsLayerSelectable(layer:string) : bool =
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        layer.IsVisible && not layer.IsLocked


    ///<summary>Checks if a layer is a parent of another layer.</summary>
    ///<param name="layer">(string) The name of the layer to test against</param>
    ///<param name="test">(string) The name to the layer to test</param>
    ///<returns>(bool) True on success, otherwise False.</returns>
    static member IsLayerParentOf(layer:string, test:string) : bool =
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        let test = RhinoScriptSyntax.CoerceLayer(test)
        test.IsParentOf(layer)


    ///<summary>Checks if a layer is from a reference file.</summary>
    ///<param name="layer">(string) The name of an existing layer</param>
    ///<returns>(bool) True on success, otherwise False.</returns>
    static member IsLayerReference(layer:string) : bool =
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        layer.IsReference


    ///<summary>Checks if a layer is visible.</summary>
    ///<param name="layer">(string) The name of an existing layer</param>
    ///<returns>(bool) True on success, otherwise False.</returns>
    static member IsLayerVisible(layer:string) : bool =
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        layer.IsVisible


    ///<summary>Returns the number of immediate child layers of a layer.</summary>
    ///<param name="layer">(string) The name of an existing layer</param>
    ///<returns>(int) The number of immediate child layers.</returns>
    static member LayerChildCount(layer:string) : int =
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        let children = layer.GetChildren()
        if notNull children then children.Length
        else 0


    ///<summary>Returns the immediate child layers of a layer. ( excluding children of children) </summary>
    ///<param name="layer">(string) The name of an existing layer</param>
    ///<returns>(string ResizeArray) List of children layer names.</returns>
    static member LayerChildren(layer:string) : string ResizeArray =
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        let children = layer.GetChildren()
        if notNull children then
            let ls = ResizeArray()
            for child in children do
                ls.Add(child.FullPath)
            ls
        else ResizeArray() //empty list


    ///<summary>Returns all (immediate and descendent) child and grand child layers of a layer.</summary>
    ///<param name="layer">(string) The name of an existing layer</param>
    ///<returns>(string ResizeArray) List of children layer names.</returns>
    static member LayerChildrenAll(layer:string) : string ResizeArray =
        let rec loop (l:DocObjects.Layer) =
            seq{
                let children = l.GetChildren()
                if notNull children then
                    for child in children do
                        yield child
                        yield! loop child } //recurse
        layer
        |> RhinoScriptSyntax.CoerceLayer
        |> loop
        |> Seq.map ( fun l -> l.FullPath)
        |> ResizeArray

    ///<summary>Returns the color of a layer.</summary>
    ///<param name="layer">(string) Name of an existing layer</param>
    ///<returns>(Drawing.Color) The current color value .</returns>
    static member LayerColor(layer:string) : Drawing.Color = //GET
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        layer.Color

    ///<summary>Changes the color of a layer.</summary>
    ///<param name="layer">(string) Name of an existing layer</param>
    ///<param name="color">(Drawing.Color) The new color value</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LayerColor(layer:string, color:Drawing.Color) : unit = //SET
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        layer.Color <- color
        State.Doc.Views.Redraw()


    ///<summary>Returns the number of layers in the document.</summary>
    ///<returns>(int) The number of layers in the document.</returns>
    static member LayerCount() : int =
        State.Doc.Layers.ActiveCount


    ///<summary>Return identifiers of all layers in the document.</summary>
    ///<returns>(Guid ResizeArray) The identifiers of all layers in the document.</returns>
    static member LayerIds() : Guid ResizeArray =
        State.Doc.Layers
        |> Seq.filter (fun layer -> not layer.IsDeleted)
        |> Seq.map (fun layer -> layer.Id)
        |> ResizeArray


    ///<summary>Returns the line type of a layer.</summary>
    ///<param name="layer">(string) Name of an existing layer</param>
    ///<returns>(string) Name of the current line type.</returns>
    static member LayerLinetype(layer:string) : string = //GET
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        let index = layer.LinetypeIndex
        State.Doc.Linetypes.[index].Name


    ///<summary>Changes the line type of a layer.</summary>
    ///<param name="layer">(string) Name of an existing layer</param>
    ///<param name="lineType">(string) Name of a line type</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LayerLinetype(layer:string, lineType:string) : unit = //SET
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        let mutable index = layer.LinetypeIndex
        if lineType = State.Doc.Linetypes.ContinuousLinetypeName then
            index <- -1
        else
            let lt = State.Doc.Linetypes.FindName(lineType)
            if lt|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.LayerLinetype not found. layer:'%s' line typ:'%s'" layer.FullPath lineType
            index <- lt.LinetypeIndex
        layer.LinetypeIndex <- index
        State.Doc.Views.Redraw()


    ///<summary>Returns the visible property of a layer,
    ///  if layer is on but invisible because of a parent that is off this returns false.</summary>
    ///<param name="layer">(string) Name of existing layer</param>
    ///<returns>(bool) The current layer visibility.</returns>
    static member LayerVisible(layer:string) : bool = //GET
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        let rc = layer.IsVisible
        rc


    ///<summary>Makes a layer visible.</summary>
    ///<param name="layer">(string) Name of existing layer</param>
    ///<param name="forceVisible">(bool) Optional, default value: <c>true</c>
    ///     Turn on parent layers too if needed. True by default</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LayerVisibleSetTrue(layer:string, [<OPT;DEF(true)>]forceVisible:bool) : unit =
        let lay = RhinoScriptSyntax.CoerceLayer(layer)
        UtilLayer.visibleSetTrue(lay,forceVisible)
        State.Doc.Views.Redraw()

    ///<summary>Makes a layer invisible.</summary>
    ///<param name="layer">(string) Name of existing layer</param>
    ///<param name="persist">(bool) Optional, default value: <c>false</c>
    ///     Turn layer persistently off? even if it is already invisible because of a parent layer that is turned off.
    ///     By default already invisible layers are not changed</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LayerVisibleSetFalse(layer:string,  [<OPT;DEF(false)>]persist:bool) : unit =
        let lay = RhinoScriptSyntax.CoerceLayer(layer)
        UtilLayer.visibleSetFalse(lay,persist)
        State.Doc.Views.Redraw()

    (*
    ///<summary>Changes the visible property of a layer.</summary>
    ///<param name="layer">(string) Name of existing layer</param>
    ///<param name="visible">(bool) New visible state</param>
    ///<param name="forcevisibleOrDonotpersist">(bool)
    ///    If visible is True then turn parent layers on if True.
    ///    If visible is False then do not persist if True</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LayerVisible(layer:string, visible:bool, [<OPT;DEF(false)>]forcevisibleOrDonotpersist:bool) : unit = //SET
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        layer.IsVisible <- visible
        if visible && forcevisibleOrDonotpersist then
            State.Doc.Layers.ForceLayerVisible(layer.Id) |> ignore
        if not visible && not forcevisibleOrDonotpersist then
            if layer.ParentLayerId <> Guid.Empty then
                layer.SetPersistentVisibility(visible)
            // layer.CommitChanges() |> ignore //obsolete !!
        State.Doc.Views.Redraw()
    *)


    ///<summary>Turn a layer off if visible, does nothing if parent layer is already invisible. .</summary>
    ///<param name="layer">(string) Name of existing layer</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LayerOff(layer:string) : unit =
        RhinoScriptSyntax.LayerVisibleSetFalse(layer, persist=false)

    ///<summary>Turn a layer on if not  visible , enforces visibility  of parents.</summary>
    ///<param name="layer">(string) Name of existing layer</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LayerOn(layer:string) : unit = //SET
        RhinoScriptSyntax.LayerVisibleSetTrue(layer, forceVisible=true)

    ///<summary>Returns the locked property of a layer,
    ///  if layer is unlocked but parent layer is locked this still returns true.</summary>
    ///<param name="layer">(string) Name of existing layer</param>
    ///<returns>(bool) The current layer visibility.</returns>
    static member LayerLocked(layer:string) : bool =
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        let rc = layer.IsLocked //not same as // https://github.com/mcneel/rhinoscriptsyntax/pull/193 // TODO ??
        rc

    ///<summary>Makes a layer locked.</summary>
    ///<param name="layer">(string) Name of existing layer</param>
    ///<param name="forceLocked">(bool) Optional, default value: <c>false</c>
    ///     Lock layer even if it is already locked via a parent layer</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LayerLockedSetTrue(layer:string, [<OPT;DEF(false)>]forceLocked:bool) : unit =
        let lay = RhinoScriptSyntax.CoerceLayer(layer)
        UtilLayer.lockedSetTrue(lay,forceLocked)
        State.Doc.Views.Redraw()

    ///<summary>Makes a layer unlocked.</summary>
    ///<param name="layer">(string) Name of existing layer</param>
    ///<param name="parentsToo">(bool) Optional, default value: <c>true</c>
    ///     Unlock parent layers to if needed</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LayerLockedSetFalse(layer:string,  [<OPT;DEF(true)>]parentsToo:bool) : unit =
        let lay = RhinoScriptSyntax.CoerceLayer(layer)
        UtilLayer.lockedSetFalse(lay,parentsToo)
        State.Doc.Views.Redraw()


    ///<summary>Unlocks a layer and all parents if needed .</summary>
    ///<param name="layer">(string) Name of existing layer</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LayerUnlock(layer:string) : unit =
        RhinoScriptSyntax.LayerLockedSetFalse(layer, parentsToo=true)

    ///<summary>Locks a layer if it is not already locked via a parent.</summary>
    ///<param name="layer">(string) Name of existing layer</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LayerLock(layer:string) : unit = //SET
        RhinoScriptSyntax.LayerLockedSetTrue(layer, forceLocked=false)

    (*
    ///<summary>Changes the locked mode of a layer, enforces persistent locking.</summary>
    ///<param name="layer">(string) Name of an existing layer</param>
    ///<param name="locked">(bool) New layer locked mode</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LayerLocked(layer:string, locked:bool) : unit = //SET
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        if layer.ParentLayerId <> Guid.Empty then
            let l = layer.GetPersistentLocking()
            if l <> locked then
                layer.SetPersistentLocking(locked)
                State.Doc.Views.Redraw()
        else
            if locked <> layer.IsLocked then
                layer.IsLocked <- locked
                State.Doc.Views.Redraw()
    *)


    ///<summary>Returns the material index of a layer. A material index of -1
    /// indicates that no material has been assigned to the layer. Thus, the layer
    /// will use Rhino's default layer material.</summary>
    ///<param name="layer">(string) Name of existing layer</param>
    ///<returns>(int) a zero-based material index.</returns>
    static member LayerMaterialIndex(layer:string) : int = //GET
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        layer.RenderMaterialIndex

    ///<summary>Changes the material index of a layer. A material index of -1
    /// indicates that no material has been assigned to the layer. Thus, the layer
    /// will use Rhino's default layer material.</summary>
    ///<param name="layer">(string) Name of existing layer</param>
    ///<param name="index">(int) The new material index</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LayerMaterialIndex(layer:string, index:int) : unit = //SET
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        if  index >= -1 then
            layer.RenderMaterialIndex <- index
            State.Doc.Views.Redraw()



    ///<summary>Returns the identifier of a layer given the layer's name.</summary>
    ///<param name="layer">(string) Name of existing layer</param>
    ///<returns>(Guid) The layer's identifier.</returns>
    static member LayerId(layer:string) : Guid =
        let idx = State.Doc.Layers.FindByFullPath(layer, RhinoMath.UnsetIntIndex)
        if idx = RhinoMath.UnsetIntIndex then RhinoScriptingException.Raise "RhinoScriptSyntax.LayerId not found for name %s" layer
        State.Doc.Layers.[idx].Id



    ///<summary>Return the name of a layer given it's identifier.</summary>
    ///<param name="layerId">(Guid) Layer identifier</param>
    ///<param name="fullPath">(bool) Optional, default value: <c>true</c>
    ///    Return the full path name `True` or short name `False`</param>
    ///<returns>(string) The layer's name.</returns>
    static member LayerName(layerId:Guid, [<OPT;DEF(true)>]fullPath:bool) : string =
        let layer = RhinoScriptSyntax.CoerceLayer(layerId)
        if fullPath then layer.FullPath
        else layer.Name


    ///<summary>Returns the names of all layers in the document.</summary>
    ///<returns>(string ResizeArray) list of layer names.</returns>
    static member LayerNames() : string ResizeArray =
        let rc = ResizeArray()
        for layer in State.Doc.Layers do
            if not layer.IsDeleted then rc.Add(layer.FullPath)
        rc


    ///<summary>Returns the current display order index of a layer as displayed in Rhino's
    ///    layer dialog box. A display order index of -1 indicates that the current
    ///    layer dialog filter does not allow the layer to appear in the layer list.</summary>
    ///<param name="layer">(string) Name of existing layer</param>
    ///<returns>(int) zero based index of layer.</returns>
    static member LayerOrder(layer:string) : int =
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        layer.SortIndex


    ///<summary>Returns the print color of a layer. Layer print colors are
    /// represented as RGB colors.</summary>
    ///<param name="layer">(string) Name of existing layer</param>
    ///<returns>(Drawing.Color) The current layer print color.</returns>
    static member LayerPrintColor(layer:string) : Drawing.Color = //GET
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        let rc = layer.PlotColor
        rc

    ///<summary>Changes the print color of a layer. Layer print colors are
    /// represented as RGB colors.</summary>
    ///<param name="layer">(string) Name of existing layer</param>
    ///<param name="color">(Drawing.Color) New print color</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LayerPrintColor(layer:string, color:Drawing.Color) : unit = //SET
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        //color = RhinoScriptSyntax.CoerceColor(color)
        layer.PlotColor <- color
        State.Doc.Views.Redraw()



    ///<summary>Returns the print width of a layer. Print width is specified
    /// in millimeters. A print width of 0.0 denotes the "default" print width.</summary>
    ///<param name="layer">(string) Name of existing layer</param>
    ///<returns>(float) The current layer print width.</returns>
    static member LayerPrintWidth(layer:string) : float = //GET
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        let rc = layer.PlotWeight
        rc

    ///<summary>Changes the print width of a layer. Print width is specified
    /// in millimeters. A print width of 0.0 denotes the "default" print width.</summary>
    ///<param name="layer">(string) Name of existing layer</param>
    ///<param name="width">(float) New print width</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LayerPrintWidth(layer:string, width:float) : unit = //SET
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        let rc = layer.PlotWeight
        if width <> rc then
            layer.PlotWeight <- width
            State.Doc.Views.Redraw()



    ///<summary>Return the parent layer of a layer or empty string if no parent present.</summary>
    ///<param name="layer">(string) Name of an existing layer</param>
    ///<returns>(string) The name of the current parent layer or empty string if no parent present.</returns>
    static member ParentLayer(layer:string) : string = //GET
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        if layer.ParentLayerId = Guid.Empty then ""
        else
            let oldparentlayer = State.Doc.Layers.FindId(layer.ParentLayerId)
            if isNull oldparentlayer then "" // TODO test! is fail better ?
            else
                oldparentlayer.FullPath


    ///<summary>Modify the parent layer of a layer.</summary>
    ///<param name="layer">(string) Name of an existing layer</param>
    ///<param name="parent">(string) Name of new parent layer. To remove the parent layer,
    ///    thus making a root-level layer, specify an empty string</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ParentLayer(layer:string, parent:string) : unit = //SET
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        if parent = "" then
            layer.ParentLayerId <- Guid.Empty
        else
            let parent = RhinoScriptSyntax.CoerceLayer(parent)
            layer.ParentLayerId <- parent.Id


    ///<summary>Removes an existing layer and all its objects from the document.
    /// The layer will be removed even if it contains geometry objects.
    /// The layer to be removed cannot be the current layer.</summary>
    ///<param name="layer">(string) The name of an existing empty layer</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member PurgeLayer(layer:string) : bool =
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        let rc = State.Doc.Layers.Purge( layer.Index, quiet=true)
        State.Doc.Views.Redraw()
        rc

    ///<summary>Removes all empty layers from the document. Even if it is current</summary>
    ///<param name="keepCurrent">(bool) Optional, default value: <c>true</c>
    ///    'true' to keep the current Layer even if empty
    ///    'false' to remove current layer too if its empty. Any other non empty layer might be the new current</param>
    ///<returns>(unit) void, nothing.</returns>
    static member PurgeEmptyLayers([<OPT;DEF(true)>]keepCurrent:bool) : unit =
        let taken=Collections.Generic.HashSet<Guid>()
        let Layers = State.Doc.Layers
        let mutable nonEmptyIndex = -1
        let rec addLoop(g:Guid)=
            if g <> Guid.Empty then
                taken.Add(g)|> ignore
                addLoop (Layers.FindId(g).ParentLayerId) // recurse

        for o in State.Doc.Objects do
            if not o.IsDeleted then
                let i = o.Attributes.LayerIndex
                nonEmptyIndex <- i
                let l = Layers.[i]
                addLoop l.Id

        let c = Layers.CurrentLayer.Id
        // deal with current layers
        // either keep
        if keepCurrent then
            addLoop c
        //or try to set it to another one thats not empty
        elif taken.Count > 0  && taken.DoesNotContain c && nonEmptyIndex > -1 then
            // change current layer to a non empty one:
            Layers.SetCurrentLayerIndex(nonEmptyIndex, quiet=true ) |> ignore

        // now delete them all
        for i = Layers.Count - 1 downto 0 do
            let l = Layers.[i]
            if not l.IsDeleted then
                if taken.DoesNotContain (l.Id) then
                    Layers.Delete(i, quiet=true) |> ignore // more than one layer might fail to delete if current layer is nested in parents
                    //if i <> Layers.CurrentLayerIndex then
                    //    if not <| Layers.Delete(i, quiet=true) then
                    //        //if Layers |> Seq.filter ( fun l -> not l.IsDeleted) |> Seq.length > 1 then
                    //        RhinoScriptingException.Raise "RhinoScriptSyntax.PurgeEmptyLayers: failed to delete layer '%s' " l.FullPath // the last layer can't be deleted so don't raise exception
        State.Doc.Views.Redraw()


    ///<summary>Renames an existing layer.</summary>
    ///<param name="oldName">(string) Original layer name</param>
    ///<param name="newName">(string) New layer name</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RenameLayer(oldName:string, newName:string) : unit =
        if oldName <> newName then
            let layer = RhinoScriptSyntax.CoerceLayer(oldName)
            layer.Name <- newName // TODO test with bad chars in layer string

    ///<summary>Collapse a layer in UI if it has children. This is the opposite of rs.ExpandLayer(..) </summary>
    ///<param name="layerName">(string) full or short layer name</param>
    ///<param name="childrenToo">(bool) Optional, default value: <c>false</c>
    ///    'true' to collapse any child layers too.
    ///    'false' to not change the parents layers collapse state.(default)</param>
    ///<returns>(unit) void, nothing.</returns>
    static member CollapseLayer(layerName:string, [<OPT;DEF(false)>]childrenToo:bool) : unit =
        let layer = RhinoScriptSyntax.CoerceLayer(layerName)
        if childrenToo then
            let rec collapse (l:DocObjects.Layer) =
                if l.IsExpanded then
                    l.IsExpanded <- false
                for child in l.GetChildren() do
                    collapse child
            collapse layer
        else
            if layer.IsExpanded then
                layer.IsExpanded <- false

    ///<summary>Expand a layer in UI if it has children. This is the opposite of rs.CollapseLayer(..) </summary>
    ///<param name="layerName">(string) full or short layer name</param>
    ///<param name="childrenToo">(bool) Optional, default value: <c>false</c>
    ///    'true' to expand any child layers too.
    ///    'false' to not change the child layers collapse state.(default)</param>
    ///<returns>(unit) void, nothing.</returns>
    static member UnCollapseLayer(layerName:string,[<OPT;DEF(false)>]childrenToo:bool) : unit =
        let layer = RhinoScriptSyntax.CoerceLayer(layerName)
        if childrenToo then
            let rec expand (l:DocObjects.Layer) =
                if not l.IsExpanded then
                    l.IsExpanded <- true
                for child in l.GetChildren() do
                    expand child
            expand layer
        else
            if layer.IsExpanded then
                layer.IsExpanded <- false

    ///<summary>Expand all parent layers in UI if this layer is hidden by a collapsed parent layer.</summary>
    ///<param name="layerName">(string) full or short layer name</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ShowLayer(layerName:string) : unit =
        let rec expand (l:DocObjects.Layer) =
            if not l.IsExpanded then
                l.IsExpanded <- true
            if l.ParentLayerId <> Guid.Empty then
                expand <| State.Doc.Layers.FindId(l.ParentLayerId)

        let layer = RhinoScriptSyntax.CoerceLayer(layerName)
        if layer.ParentLayerId <> Guid.Empty then
            expand <| State.Doc.Layers.FindId(layer.ParentLayerId)

    //---End of header marker: don't change: {@$%^&*()*&^%$@}



    ///<summary>Add new command alias to Rhino Command aliases can be added manually by
    ///    using Rhino's Options command and modifying the contents of the Aliases tab.</summary>
    ///<param name="alias">(string) Name of new command alias. Cannot match command names or existing
    ///    aliases</param>
    ///<param name="macro">(string) The macro to run when the alias is executed</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member AddAlias( alias:string,
                            macro:string) : bool =
        RhinoSync.DoSync (fun () ->
            ApplicationSettings.CommandAliasList.Add(alias, macro))


    ///<summary>Add new path to Rhino's search path list. Search paths can be added by
    ///    using Rhino's Options command and modifying the contents of the files tab.</summary>
    ///<param name="folder">(string) A valid folder, or path, to add</param>
    ///<param name="index">(int) Optional, Zero-based position in the search path list to insert.
    ///    If omitted, path will be appended to the end of the search path list.</param>
    ///<returns>(int) The index where the item was inserted.
    ///    -1 on failure.</returns>
    static member AddSearchPath(    folder:string,
                                    [<OPT;DEF(-1)>]index:int) : int =
        RhinoSync.DoSync (fun () ->
            ApplicationSettings.FileSettings.AddSearchPath(folder, index))


    ///<summary>Returns number of command aliases in Rhino.</summary>
    ///<returns>(int) The number of command aliases in Rhino.</returns>
    static member AliasCount() : int =
        ApplicationSettings.CommandAliasList.Count


    ///<summary>Returns the macro of a command alias.</summary>
    ///<param name="alias">(string) The name of an existing command alias</param>
    ///<returns>(string) The existing macro.</returns>
    static member AliasMacro(alias:string) : string = //GET
        ApplicationSettings.CommandAliasList.GetMacro(alias)

    ///<summary>Modifies the macro of a command alias.</summary>
    ///<param name="alias">(string) The name of an existing command alias</param>
    ///<param name="macro">(string) The new macro to run when the alias is executed.</param>
    ///<returns>(unit) void, nothing.</returns>
    static member AliasMacro(alias:string, macro:string) : unit = //SET
        RhinoSync.DoSync (fun () ->
            ApplicationSettings.CommandAliasList.SetMacro(alias, macro)
            |> ignore)


    ///<summary>Returns a array of command alias names.</summary>
    ///<returns>(string array) a array of command alias names.</returns>
    static member AliasNames() : array<string> =
        RhinoSync.DoSync (fun () ->
            ApplicationSettings.CommandAliasList.GetNames())


    ///<summary>Returns an application interface item's color.</summary>
    ///<param name="item">(int) Item number to either query or modify
    ///    0  = View background
    ///    1  = Major grid line
    ///    2  = Minor grid line
    ///    3  = X-Axis line
    ///    4  = Y-Axis line
    ///    5  = Selected Objects
    ///    6  = Locked Objects
    ///    7  = New layers
    ///    8  = Feedback
    ///    9  = Tracking
    ///    10 = Crosshair
    ///    11 = Text
    ///    12 = Text Background
    ///    13 = Text hover</param>
    ///<returns>(Drawing.Color) The current item color.
    ///    0  = View background
    ///    1  = Major grid line
    ///    2  = Minor grid line
    ///    3  = X-Axis line
    ///    4  = Y-Axis line
    ///    5  = Selected Objects
    ///    6  = Locked Objects
    ///    7  = New layers
    ///    8  = Feedback
    ///    9  = Tracking
    ///    10 = Crosshair
    ///    11 = Text
    ///    12 = Text Background
    ///    13 = Text hover.</returns>
    static member AppearanceColor(item:int) : Drawing.Color = //GET
        if   item = 0 then AppearanceSettings.ViewportBackgroundColor
        elif item = 1 then AppearanceSettings.GridThickLineColor
        elif item = 2 then AppearanceSettings.GridThinLineColor
        elif item = 3 then AppearanceSettings.GridXAxisLineColor
        elif item = 4 then AppearanceSettings.GridYAxisLineColor
        elif item = 5 then AppearanceSettings.SelectedObjectColor
        elif item = 6 then AppearanceSettings.LockedObjectColor
        elif item = 7 then AppearanceSettings.DefaultLayerColor
        elif item = 8 then AppearanceSettings.FeedbackColor
        elif item = 9 then  AppearanceSettings.TrackingColor
        elif item = 10 then AppearanceSettings.CrosshairColor
        elif item = 11 then AppearanceSettings.CommandPromptTextColor
        elif item = 12 then AppearanceSettings.CommandPromptBackgroundColor
        elif item = 13 then AppearanceSettings.CommandPromptHypertextColor
        else RhinoScriptingException.Raise "RhinoScriptSyntax.AppearanceColor: get item %d is out of range" item

    ///<summary>Modifies an application interface item's color.</summary>
    ///<param name="item">(int) Item number to either query or modify
    ///    0  = View background
    ///    1  = Major grid line
    ///    2  = Minor grid line
    ///    3  = X-Axis line
    ///    4  = Y-Axis line
    ///    5  = Selected Objects
    ///    6  = Locked Objects
    ///    7  = New layers
    ///    8  = Feedback
    ///    9  = Tracking
    ///    10 = Crosshair
    ///    11 = Text
    ///    12 = Text Background
    ///    13 = Text hover</param>
    ///<param name="color">(Drawing.Color ) The new color value as System.Drawing.Color</param>
    ///<returns>(unit) void, nothing.</returns>
    static member AppearanceColor(item:int, color:Drawing.Color) : unit = //SET
        RhinoSync.DoSync (fun () ->
            if item = 0 then AppearanceSettings.ViewportBackgroundColor <- color
            elif item = 1 then AppearanceSettings.GridThickLineColor <- color
            elif item = 2 then AppearanceSettings.GridThinLineColor <- color
            elif item = 3 then AppearanceSettings.GridXAxisLineColor <- color
            elif item = 4 then AppearanceSettings.GridYAxisLineColor <- color
            elif item = 5 then AppearanceSettings.SelectedObjectColor <- color
            elif item = 6 then AppearanceSettings.LockedObjectColor <- color
            elif item = 7 then AppearanceSettings.DefaultLayerColor <- color
            elif item = 8 then AppearanceSettings.FeedbackColor <- color
            elif item = 9 then AppearanceSettings.TrackingColor <- color
            elif item = 10 then AppearanceSettings.CrosshairColor <- color
            elif item = 11 then AppearanceSettings.CommandPromptTextColor <- color
            elif item = 12 then AppearanceSettings.CommandPromptBackgroundColor <- color
            elif item = 13 then AppearanceSettings.CommandPromptHypertextColor <- color
            else RhinoScriptingException.Raise "RhinoScriptSyntax.AppearanceColor:: Setting item %d is out of range" item
            State.Doc.Views.Redraw()
            )


    ///<summary>Returns the file name used by Rhino's automatic file saving.</summary>
    ///<returns>(string) The name of the current autosave file.</returns>
    static member AutosaveFile() : string = //GET
        ApplicationSettings.FileSettings.AutoSaveFile

    ///<summary>Changes the file name used by Rhino's automatic file saving.</summary>
    ///<param name="filename">(string) Name of the new autosave file</param>
    ///<returns>(unit) void, nothing.</returns>
    static member AutosaveFile(filename:string) : unit = //SET
        RhinoSync.DoSync (fun () ->
            ApplicationSettings.FileSettings.AutoSaveFile <- filename)


    ///<summary>Returns how often the document will be saved when Rhino's
    /// automatic file saving mechanism is enabled.</summary>
    ///<returns>(float) The current interval in minutes.</returns>
    static member AutosaveInterval() : float = //GET
        ApplicationSettings.FileSettings.AutoSaveInterval.TotalMinutes

    ///<summary>Changes how often the document will be saved when Rhino's
    /// automatic file saving mechanism is enabled.</summary>
    ///<param name="minutes">(float) The number of minutes between saves</param>
    ///<returns>(unit) void, nothing.</returns>
    static member AutosaveInterval(minutes:float) : unit = //SET
        RhinoSync.DoSync (fun () ->
            ApplicationSettings.FileSettings.AutoSaveInterval <- TimeSpan.FromMinutes(minutes))


    ///<summary>Returns the build date of Rhino.</summary>
    ///<returns>(DateTime) The build date of Rhino. Will be converted to a string by most functions.</returns>
    static member BuildDate() : DateTime =
        RhinoApp.BuildDate


    ///<summary>Clears contents of Rhino's command history window. You can view the
    ///    command history window by using the CommandHistory command in Rhino.</summary>
    ///<returns>(unit) void, nothing.</returns>
    static member ClearCommandHistory() : unit =
        RhinoSync.DoSync (fun () ->
            RhinoApp.ClearCommandHistoryWindow())


    ///<summary>Runs a Rhino command macro / script. All Rhino commands can be used in command
    ///    scripts. The command can be a built-in Rhino command or one provided by a
    ///    3rd party plug-in.
    ///    Write command scripts just as you would type the command sequence at the
    ///    Commandline. A space or a new line acts like pressing 'Enter' at the
    ///    Commandline. For more information, see "Scripting" in Rhino help.
    ///    Note, this function is designed to run one command and one command only.
    ///    Do not combine multiple Rhino commands into a single call to this method.
    ///      WRONG:
    ///        rs.Command("_Line _SelLast _Invert")
    ///      CORRECT:
    ///        rs.Command("_Line")
    ///        rs.Command("_SelLast")
    ///        rs.Command("_Invert")
    ///    Also, the exclamation point and space character ( ! ) combination used by
    ///    button macros and batch-driven scripts to cancel the previous command is
    ///    not valid.
    ///      WRONG:
    ///        rs.Command("! _Line _Pause _Pause")
    ///      CORRECT:
    ///        rs.Command("_Line _Pause _Pause")
    ///    In a normal command, when the user enters a command beginning with a '!' , the command exits.
    ///    There is no documented way to get this behavior from within a script command.
    ///
    ///    After the command script has run, you can obtain the identifiers of most
    ///    recently created or changed object by calling RhinoScriptSyntax.LastCreatedObjects().
    ///
    ///    Warnings:
    ///    This kind of command can be very dangerous. Please be sure you understand the following:
    ///    If you are not very familiar with how references work, you should only call Rhino.RhinoApp.RunScript()
    ///     from within a RhinoScriptCommand derived command.
    ///    If you are very familiar with references, then please observe the following rules:
    ///    If you get a reference or pointer to any part of the Rhino run-time database, this reference or pointer
    ///    will not be valid after you call Rhino.RhinoApp.RunScript().
    ///    If you get a reference or a pointer, then call Rhino.RhinoApp.RunScript(), and then use the reference,
    ///    Rhino will probably crash.
    ///    All pointers and references used by the command should be scoped such that they are only valid for the
    ///    time between calls to Rhino.RhinoApp.RunScript().
    ///    This is because Rhino.RhinoApp.RunScript() can change the dynamic arrays in the run-time database.
    ///    The result is that all pointers and references become invalid.
    ///    Be sure to scope your variables between Rhino.RhinoApp.RunScript() calls.
    ///    Never allow references and pointers from one section to be used in another section.</summary>
    ///<param name="commandString">(string) A Rhino command including any arguments</param>
    ///<param name="echo">(bool) Optional, default value: <c>true</c>
    ///    The default command echo mode <c>true</c> will display the commands on the commandline.
    ///    If the command echo mode is set to <c>false</c> the command prompts will not be printed to the Rhino command line.</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member Command (commandString:string, [<OPT;DEF(true)>]echo:bool) : bool =
        RhinoSync.DoSync (fun () ->
            let start = DocObjects.RhinoObject.NextRuntimeSerialNumber
            // RhinoApp.RunScript:
            // Rhino acts as if each character in the script string had been typed in the command prompt.
            // When RunScript is called from a "script runner" command, it completely runs the
            // script before returning. When RunScript is called outside of a command, it returns and the
            // script is run. This way menus and buttons can use RunScript to execute complicated functions
            // see warnings from https://developer.rhino3d.com/guides/rhinocommon/run-rhino-command-from-plugin/
            let rc = RhinoApp.RunScript(commandString, echo)
            let ende = DocObjects.RhinoObject.NextRuntimeSerialNumber
            State.CommandSerialNumbers <- None
            if start<>ende then  State.CommandSerialNumbers <- Some(start, ende)
            rc
            )


    ///<summary>Returns the contents of Rhino's command history window.</summary>
    ///<returns>(string) The contents of Rhino's command history window.</returns>
    static member CommandHistory() : string =
        RhinoSync.DoSync (fun () ->
            RhinoApp.CommandHistoryWindowText)


    ///<summary>Returns the default render plug-in.</summary>
    ///<returns>(string) Name of default renderer.</returns>
    static member DefaultRenderer() : string = //GET
        let mutable objectId = Render.Utilities.DefaultRenderPlugInId
        let mutable plugins = PlugIns.PlugIn.GetInstalledPlugIns()
        plugins.[objectId]

    ///<summary>Changes the default render plug-in.</summary>
    ///<param name="renderer">(string) The name of the renderer to set as default renderer</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member DefaultRenderer(renderer:string) : bool = //SET
        RhinoSync.DoSync (fun () ->
            let objectId = Rhino.PlugIns.PlugIn.IdFromName(renderer)
            Rhino.Render.Utilities.SetDefaultRenderPlugIn(objectId)
            )


    ///<summary>Delete an existing alias from Rhino.</summary>
    ///<param name="alias">(string) The name of an existing alias</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member DeleteAlias(alias:string) : bool =
        ApplicationSettings.CommandAliasList.Delete(alias)


    ///<summary>Removes existing path from Rhino's search path list. Search path items
    ///    can be removed manually by using Rhino's options command and modifying the
    ///    contents of the files tab.</summary>
    ///<param name="folder">(string) A folder to remove</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member DeleteSearchPath(folder:string) : bool =
        RhinoSync.DoSync (fun () ->
            ApplicationSettings.FileSettings.DeleteSearchPath(folder))


    ///<summary>Enables/disables OLE Server Busy/Not Responding dialog boxes.</summary>
    ///<param name="enable">(bool) Whether alerts should be visible (True or False)</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DisplayOleAlerts(enable:bool) : unit =
        RhinoSync.DoSync (fun () ->
            Rhino.Runtime.HostUtils.DisplayOleAlerts( enable )
            )


    ///<summary>Returns edge analysis color displayed by the ShowEdges command.</summary>
    ///<returns>(Drawing.Color) The current edge analysis color.</returns>
    static member EdgeAnalysisColor() : Drawing.Color= //GET
        ApplicationSettings.EdgeAnalysisSettings.ShowEdgeColor

    ///<summary>Modifies edge analysis color displayed by the ShowEdges command.</summary>
    ///<param name="color">(Drawing.Color), optional) The new color for the analysis</param>
    ///<returns>(unit) void, nothing.</returns>
    static member EdgeAnalysisColor(color:Drawing.Color) : unit = //SET
        RhinoSync.DoSync (fun () ->
            ApplicationSettings.EdgeAnalysisSettings.ShowEdgeColor <- color
            )


    ///<summary>Returns edge analysis mode displayed by the ShowEdges command.</summary>
    ///<returns>(int) The current edge analysis mode
    ///    0 - display all edges
    ///    1 - display naked edges.</returns>
    static member EdgeAnalysisMode() : int = //GET
        ApplicationSettings.EdgeAnalysisSettings.ShowEdges

    ///<summary>Modifies edge analysis mode displayed by the ShowEdges command.</summary>
    ///<param name="mode">(int) The new display mode. The available modes are
    ///    0 - display all edges
    ///    1 - display naked edges</param>
    ///<returns>(unit) void, nothing.</returns>
    static member EdgeAnalysisMode(mode:int) : unit = //SET
        RhinoSync.DoSync (fun () ->
            if mode = 1 || mode = 2 then
                ApplicationSettings.EdgeAnalysisSettings.ShowEdges <- mode
            else
                RhinoScriptingException.Raise "RhinoScriptSyntax.EdgeAnalysisMode bad edge analysisMode %d" mode
            )

    ///<summary>Enables or disables Rhino's automatic file saving mechanism.</summary>
    ///<param name="enable">(bool) Optional, default value: <c>true</c>
    ///    The autosave state. If omitted automatic saving is enabled (True)</param>
    ///<returns>(unit) void, nothing.</returns>
    static member EnableAutosave([<OPT;DEF(true)>]enable:bool) : unit =
        RhinoSync.DoSync (fun () ->
            ApplicationSettings.FileSettings.AutoSaveEnabled <- enable)


    ///<summary>Get status of a Rhino plug-in.</summary>
    ///<param name="plugin">(string) The name of the plugin</param>
    ///<returns>(bool) True if set to load silently otherwise False.</returns>
    static member EnablePlugIn(plugin:string) : bool = //GET
        RhinoSync.DoSync (fun () ->
            let objectId = PlugIns.PlugIn.IdFromName(plugin)
            let rc, loadSilent = PlugIns.PlugIn.GetLoadProtection(objectId)
            if rc then loadSilent
            else RhinoScriptingException.Raise "RhinoScriptSyntax.EnablePlugIn: %s GetLoadProtection failed" plugin
            )

    ///<summary>Enables or disables a Rhino plug-in.</summary>
    ///<param name="plugin">(string) The name of the plugin</param>
    ///<param name="enable">(bool) Load silently if True</param>
    ///<returns>(unit) void, nothing.</returns>
    static member EnablePlugIn(plugin:string, enable:bool) : unit = //SET
        RhinoSync.DoSync (fun () ->
            let objectId = Rhino.PlugIns.PlugIn.IdFromName(plugin)
            let rc, _ = Rhino.PlugIns.PlugIn.GetLoadProtection(objectId)
            if rc then PlugIns.PlugIn.SetLoadProtection(objectId, enable)
            else RhinoScriptingException.Raise "RhinoScriptSyntax.EnablePlugIn: %s GetLoadProtection failed" plugin
            )



    ///<summary>Returns the full path to Rhino's executable folder.</summary>
    ///<returns>(string) The full path to Rhino's executable folder.</returns>
    static member ExeFolder() : string =
        ApplicationSettings.FileSettings.ExecutableFolder


    ///<summary>Returns the platform of the Rhino executable , calls System.Environment.Is64BitProcess.</summary>
    ///<returns>(int) 1 for 64 bit, 0 for 32 bit.</returns>
    static member ExePlatform() : int =
        if System.Environment.Is64BitProcess then  1 else  0


    ///<summary>Returns the service release number of the Rhino executable.</summary>
    ///<returns>(int) The service release number of the Rhino executable.</returns>
    static member ExeServiceRelease() : int =
        RhinoApp.ExeServiceRelease


    ///<summary>Returns the major version number of the Rhino executable.</summary>
    ///<returns>(int) The major version number of the Rhino executable.</returns>
    static member ExeVersion() : int =
        RhinoApp.ExeVersion


    ///<summary>Closes the Rhino application.</summary>
    ///<returns>(unit) void, nothing.</returns>
    static member Exit() : unit =
        RhinoSync.DoSync (fun () ->
            RhinoApp.Exit())


    ///<summary>Searches for a file using Rhino's search path. Rhino will look for a file in the following locations:
    ///      1. The current document's folder.
    ///      2. Folder's specified in Options dialog, File tab.
    ///      3. Rhino's System folders.</summary>
    ///<param name="filename">(string) A short file name to search for</param>
    ///<returns>(string) a full path.</returns>
    static member FindFile(filename:string) : string =
        ApplicationSettings.FileSettings.FindFile(filename)


    ///<summary>Returns a scriptable object from a specified plug-in. Not all plug-ins
    ///    contain scriptable objects. Check with the manufacturer of your plug-in
    ///    to see if they support this capability.</summary>
    ///<param name="plugIn">(string) The name of a registered plug-in that supports scripting.
    ///    If the plug-in is registered but not loaded, it will be loaded</param>
    ///<returns>(object) a scriptable plugin object.</returns>
    static member GetPlugInObject(plugIn:string) : obj =
        RhinoApp.GetPlugInObject(plugIn)


    ///<summary>Determines if Rhino is currently running a command. Because Rhino allows
    ///    for transparent commands (commands run from inside of other commands), this
    ///    method returns the total number of active commands.</summary>
    ///<returns>(int) The number of active commands.</returns>
    static member InCommand() : int = // [<OPT;DEF(true)>]ignoreRunners:bool) : int =
        //<param name="ignoreRunners">(bool) Optional, default value: <c>true</c>
        //If True, script running commands, such as
        //  LoadScript, RunScript, and ReadCommandFile will not counted.
        //  If omitted the default is not to count script running command (True)</param>
        //let inCommand (ignoreRunners:bool) :int =
        //<param name="ignoreRunners">ignoreRunners If True, script running commands, such as
        //        LoadScript, RunScript, and ReadCommandFile will not counted.
        //        If omitted the default is not to count script running command (True)</param>
        Commands.Command.GetCommandStack()
        //|> Array.filter (fun i -> if ignoreRunners then  Commands.Command.GetInt(i) <> 1 else true)
        |> Array.length


    ///<summary>The full path to Rhino's installation folder.</summary>
    ///<returns>(string) The full path to Rhino's installation folder.</returns>
    static member InstallFolder() : string =
        ApplicationSettings.FileSettings.InstallFolder.FullName


    ///<summary>Checks if a command alias exists in Rhino.</summary>
    ///<param name="alias">(string) The name of an existing command alias</param>
    ///<returns>(bool) True if exists or False if the alias does not exist.</returns>
    static member IsAlias(alias:string) : bool =
        ApplicationSettings.CommandAliasList.IsAlias(alias)


    ///<summary>Checks if a command exists in Rhino. Useful when scripting commands
    ///    found in 3rd party plug-ins.</summary>
    ///<param name="commandName">(string) The command name to test</param>
    ///<returns>(bool) True if the string is a command or False if it is not a command.</returns>
    static member IsCommand(commandName:string) : bool =
        Commands.Command.IsCommand(commandName)


    ///<summary>Checks if a plug-in is registered.</summary>
    ///<param name="plugin">(string) The unique objectId of the plug-in</param>
    ///<returns>(bool) True if the Guid is registered or False if it is not.</returns>
    static member IsPlugIn(plugin:string) : bool =
        let objectId = Rhino.PlugIns.PlugIn.IdFromName(plugin)
        if objectId = Guid.Empty then false
        else
            let rc, _ , _ = Rhino.PlugIns.PlugIn.PlugInExists(objectId)
            rc


    ///<summary>Returns True if this script is being executed on a Windows platform.</summary>
    ///<returns>(bool) True if currently running on the Widows platform. False if it is not Windows.</returns>
    static member IsRunningOnWindows() : bool =
        Rhino.Runtime.HostUtils.RunningOnWindows


    ///<summary>Returns the name of the last executed command.</summary>
    ///<returns>(string) The name of the last executed command.</returns>
    static member LastCommandName() : string =
        let mutable objectId = Commands.Command.LastCommandId
        Commands.Command.LookupCommandName(objectId, englishName=true)


    ///<summary>Returns the result code for the last executed command.</summary>
    ///<returns>(int) The result code for the last executed command.
    ///    0 = success (command successfully completed)
    ///    1 = cancel (command was cancelled by the user)
    ///    2 = nothing (command did nothing, but was not cancelled)
    ///    3 = failure (command failed due to bad input, computational problem...)
    ///    4 = unknown command (the command was not found).</returns>
    static member LastCommandResult() : int =
        RhinoSync.DoSync (fun () ->
            int(Commands.Command.LastCommandResult))


    ///<summary>Returns the current language used for the Rhino interface. The current
    ///    language is returned as a locale ID, or LCID, value.</summary>
    ///<returns>(int) The current language used for the Rhino interface as a locale ID, or LCID.
    ///    1029  Czech
    ///    1031  German-Germany
    ///    1033  English-United States
    ///    1034  Spanish-Spain
    ///    1036  French-France
    ///    1040  Italian-Italy
    ///    1041  Japanese
    ///    1042  Korean
    ///    1045  Polish.</returns>
    static member LocaleID() : int =
        ApplicationSettings.AppearanceSettings.LanguageIdentifier


    ///<summary>Get status of Rhino's ortho modeling aid.</summary>
    ///<returns>(bool) The current ortho status.</returns>
    static member Ortho() : bool = //GET
        ModelAidSettings.Ortho

    ///<summary>Enables or disables Rhino's ortho modeling aid.</summary>
    ///<param name="enable">(bool) The new enabled status</param>
    ///<returns>(unit) void, nothing.</returns>
    static member Ortho(enable:bool) : unit = //SET
        RhinoSync.DoSync (fun () ->
            ModelAidSettings.Ortho <- enable)


    ///<summary>Get status of Rhino's object snap modeling aid.
    ///    Object snaps are tools for specifying points on existing objects.</summary>
    ///<returns>(bool) The current object snap status.</returns>
    static member Osnap() : bool = //GET
        ModelAidSettings.Osnap

    ///<summary>Enables or disables Rhino's object snap modeling aid.
    ///    Object snaps are tools for specifying points on existing objects.</summary>
    ///<param name="enable">(bool) The new enabled status</param>
    ///<returns>(unit) void, nothing.</returns>
    static member Osnap(enable:bool) : unit = //SET
        RhinoSync.DoSync (fun () ->
            ModelAidSettings.Osnap <- enable)


    ///<summary>Get status of Rhino's dockable object snap bar.</summary>
    ///<returns>(bool) The current visible state.</returns>
    static member OsnapDialog() : bool = //GET
        ModelAidSettings.UseHorizontalDialog

    ///<summary>Shows or hides Rhino's dockable object snap bar.</summary>
    ///<param name="visible">(bool) The new visibility state.</param>
    ///<returns>(unit) void, nothing.</returns>
    static member OsnapDialog(visible:bool) : unit = //SET
        RhinoSync.DoSync (fun () ->
            ModelAidSettings.UseHorizontalDialog <- visible)


    ///<summary>Returns the object snap mode. Object snaps are tools for
    /// specifying points on existing objects.</summary>
    ///<returns>(int) The current object snap mode(s)
    ///    0          None
    ///    2          Near
    ///    8          Focus
    ///    32         Center
    ///    64         Vertex
    ///    128        Knot
    ///    512        Quadrant
    ///    2048       Midpoint
    ///    8192       Intersection
    ///    131072     End
    ///    524288     Perpendicular
    ///    2097152    Tangent
    ///    134217728  Point
    ///    Object snap modes can be added together to set multiple modes.</returns>
    static member OsnapMode() : int = //GET
        int(ModelAidSettings.OsnapModes)

    ///<summary>Sets the object snap mode. Object snaps are tools for
    /// specifying points on existing objects.</summary>
    ///<param name="mode">(int) The object snap mode or modes to set.
    ///    0          None
    ///    2          Near
    ///    8          Focus
    ///    32         Center
    ///    64         Vertex
    ///    128        Knot
    ///    512        Quadrant
    ///    2048       Midpoint
    ///    8192       Intersection
    ///    131072     End
    ///    524288     Perpendicular
    ///    2097152    Tangent
    ///    134217728  Point
    ///    Object snap modes can be added together to set multiple modes</param>
    ///<returns>(unit) void, nothing.</returns>
    static member OsnapMode(mode:int) : unit = //SET
        RhinoSync.DoSync (fun () ->
            ModelAidSettings.OsnapModes <- LanguagePrimitives.EnumOfValue mode)


    ///<summary>Get status of Rhino's planar modeling aid.</summary>
    ///<returns>(bool) The current planar status.</returns>
    static member Planar() : bool = //GET
        ModelAidSettings.Planar

    ///<summary>Enables or disables Rhino's planar modeling aid.</summary>
    ///<param name="enable">(bool) The new enable status.</param>
    ///<returns>(unit) void, nothing.</returns>
    static member Planar(enable:bool) : unit = //SET
        RhinoSync.DoSync (fun () ->
            ModelAidSettings.Planar <- enable)


    ///<summary>Returns the identifier of a plug-in given the plug-in name.</summary>
    ///<param name="plugin">(string) The name  of the plug-in</param>
    ///<returns>(Guid) The  Unique Guid of the plug-in.</returns>
    static member PlugInId(plugin:string) : Guid =
        let objectId = Rhino.PlugIns.PlugIn.IdFromName(plugin)
        if objectId<>Guid.Empty then  objectId
        else RhinoScriptingException.Raise "RhinoScriptSyntax.PlugInId: Plugin %s not found" plugin


    ///<summary>Returns a array of registered Rhino plug-ins.</summary>
    ///<param name="types">(int) Optional, default value: <c>0</c>
    ///    The type of plug-ins to return.
    ///    0 = all
    ///    1 = render
    ///    2 = file export
    ///    4 = file import
    ///    8 = digitizer
    ///    16 = utility.
    ///    If omitted, all are returned</param>
    ///<param name="status">(int) Optional, default value: <c>0</c>
    /// 0 = both loaded and unloaded,
    /// 1 = loaded,
    /// 2 = unloaded. If omitted both status is returned</param>
    ///<returns>(string array) array of registered Rhino plug-ins.</returns>
    static member PlugIns([<OPT;DEF(0)>]types:int, [<OPT;DEF(0)>]status:int) : array<string> =
        let mutable filter = Rhino.PlugIns.PlugInType.Any
        if types = 1 then  filter <- Rhino.PlugIns.PlugInType.Render
        if types = 2 then  filter <- Rhino.PlugIns.PlugInType.FileExport
        if types = 4 then  filter <- Rhino.PlugIns.PlugInType.FileImport
        if types = 8 then  filter <- Rhino.PlugIns.PlugInType.Digitizer
        if types = 16 then filter <- Rhino.PlugIns.PlugInType.Utility
        let loaded = status = 0 || status = 1
        let unloaded = status = 0 || status = 2
        RhinoSync.DoSync (fun () ->
            Rhino.PlugIns.PlugIn.GetInstalledPlugInNames(filter, loaded, unloaded))


    ///<summary>Get status of object snap projection.</summary>
    ///<returns>(bool) The current object snap projection status.</returns>
    static member ProjectOsnaps() : bool = //GET
        ModelAidSettings.ProjectSnapToCPlane

    ///<summary>Enables or disables object snap projection.</summary>
    ///<param name="enable">(bool) The new enabled status.</param>
    static member ProjectOsnaps(enable:bool) : unit = //SET
        RhinoSync.DoSync (fun () ->
            ModelAidSettings.ProjectSnapToCPlane <- enable)


    ///<summary>Change Rhino's command window prompt.</summary>
    ///<param name="message">(string) The new prompt on the commandline</param>
    ///<returns>(unit) void, nothing.</returns>
    static member Prompt(message:string) : unit =
        RhinoSync.DoSync (fun () ->
            RhinoApp.SetCommandPrompt(message))



    ///<summary>Returns current width and height, of the screen of the primary monitor.</summary>
    ///<returns>(int * int) containing two numbers identifying the width and height in pixels.</returns>
    static member ScreenSize() : int * int =
        // let sz = System.Windows.Forms.Screen.PrimaryScreen.Bounds //  TODO: Windows Forms is supported on Mono Mac??  compile separate Assembly for Windows ???
        // sz.Width, sz.Height
        let sz = Eto.Forms.Screen.PrimaryScreen.Bounds
        int sz.Width, int sz.Height


    ///<summary>Returns version of the Rhino SDK supported by the executing Rhino.</summary>
    ///<returns>(int) The version of the Rhino SDK supported by the executing Rhino. Rhino SDK versions are 9 digit numbers in the form of YYYYMMDDn.</returns>
    static member SdkVersion() : int =
        RhinoApp.SdkVersion


    ///<summary>Returns the number of path items in Rhino's search path list.
    ///    See "Options Files settings" in the Rhino help file for more details.</summary>
    ///<returns>(int) The number of path items in Rhino's search path list.</returns>
    static member SearchPathCount() : int =
        ApplicationSettings.FileSettings.SearchPathCount


    ///<summary>Returns all of the path items in Rhino's search path list.
    ///    See "Options Files settings" in the Rhino help file for more details.</summary>
    ///<returns>(string array) list of search paths.</returns>
    static member SearchPathList() : array<string> =
        ApplicationSettings.FileSettings.GetSearchPaths()


    ///<summary>Sends a string of printable characters to Rhino's Commandline.</summary>
    ///<param name="keys">(string) A string of characters to send to the Commandline</param>
    ///<param name="addReturn">(bool) Optional, default value: <c>true</c>
    ///    Append a return character to the end of the string. If omitted an return character will be added (True)</param>
    ///<returns>(unit) void, nothing.</returns>
    static member SendKeystrokes(keys:string, [<OPT;DEF(true)>]addReturn:bool) : unit =
        RhinoSync.DoSync (fun () ->
            RhinoApp.SendKeystrokes(keys, addReturn))


    ///<summary>Get status of Rhino's grid snap modeling aid.</summary>
    ///<returns>(bool) The current grid snap status.</returns>
    static member Snap() : bool = //GET
        ModelAidSettings.GridSnap

    ///<summary>Enables or disables Rhino's grid snap modeling aid.</summary>
    ///<param name="enable">(bool) The new enabled status.</param>
    static member Snap(enable:bool) : unit = //SET
        RhinoSync.DoSync (fun () ->
            ModelAidSettings.GridSnap <- enable)


    ///<summary>Sets Rhino's status bar distance pane.</summary>
    ///<param name="distance">(float) The distance to set the status bar</param>
    ///<returns>(unit) void, nothing.</returns>
    static member StatusBarDistance(distance:float) : unit =
        RhinoSync.DoSync (fun () ->
            UI.StatusBar.SetDistancePane(distance))


    ///<summary>Sets Rhino's status bar message pane.</summary>
    ///<param name="message">(string) The message to display</param>
    ///<returns>(unit) void, nothing.</returns>
    static member StatusBarMessage(message:string) : unit =
        RhinoSync.DoSync (fun () ->
            UI.StatusBar.SetMessagePane(message))


    ///<summary>Sets Rhino's status bar point coordinate pane.</summary>
    ///<param name="point">(Point3d) The 3d coordinates of the status bar</param>
    ///<returns>(unit) void, nothing.</returns>
    static member StatusBarPoint(point:Point3d) : unit =
        RhinoSync.DoSync (fun () ->
            UI.StatusBar.SetPointPane(point))


    ///<summary>Start the Rhino status bar progress meter.</summary>
    ///<param name="label">(string) Short description of the progesss</param>
    ///<param name="lower">(int) Lower limit of the progress meter's range</param>
    ///<param name="upper">(int) Upper limit of the progress meter's range</param>
    ///<param name="embedLabel">(bool) Optional, default value: <c>true</c>
    ///    If true, the label will show inside the meter.
    ///    If false, the label will show to the left of the meter</param>
    ///<param name="showPercent">(bool) Optional, default value: <c>true</c>
    ///    Show the percent complete if True</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member StatusBarProgressMeterShow(label:string, lower:int, upper:int, [<OPT;DEF(true)>]embedLabel:bool, [<OPT;DEF(true)>]showPercent:bool) : bool =
        RhinoSync.DoSync (fun () ->
            let mutable rc = UI.StatusBar.ShowProgressMeter(lower, upper, label, embedLabel, showPercent)
            rc = 1)


    ///<summary>Set the current position of the progress meter.</summary>
    ///<param name="position">(int) The new position in the progress meter</param>
    ///<param name="absolute">(bool) Optional, default value: <c>true</c>
    ///    The position is set absolute (True) or relative (False) to its current position. If omitted the absolute (True) is used</param>
    ///<returns>(unit) void, nothing.</returns>
    static member StatusBarProgressMeterUpdate(position:int, [<OPT;DEF(true)>]absolute:bool) : unit =
        RhinoSync.DoSync (fun () ->
            UI.StatusBar.UpdateProgressMeter(position, absolute)
            |> ignore)


    ///<summary>Hide the progress meter.</summary>
    ///<returns>(unit) void, nothing.</returns>
    static member StatusBarProgressMeterHide() : unit =
        RhinoSync.DoSync (fun () ->
            UI.StatusBar.HideProgressMeter())


    ///<summary>Returns Rhino's default template file. This is the file used
    /// when Rhino starts.</summary>
    ///<returns>(string) The current default template file.</returns>
    static member TemplateFile() : string = //GET
        ApplicationSettings.FileSettings.TemplateFile

    ///<summary>Sets Rhino's default template file. This is the file used
    /// when Rhino starts.</summary>
    ///<param name="filename">(string) The name of the new default template file.</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TemplateFile(filename:string) : unit = //SET
        RhinoSync.DoSync (fun () ->
            ApplicationSettings.FileSettings.TemplateFile <- filename)


    ///<summary>Returns the location of Rhino's template folder.</summary>
    ///<returns>(string) The current template file folder.</returns>
    static member TemplateFolder() : string = //GET
        ApplicationSettings.FileSettings.TemplateFolder

    ///<summary>Sets the location of Rhino's template folder.</summary>
    ///<param name="folder">(string) The location of Rhino's template files. Note, the location must exist</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TemplateFolder(folder:string) : unit = //SET
        RhinoSync.DoSync (fun () ->
            ApplicationSettings.FileSettings.TemplateFolder <- folder)


    ///<summary>Returns the windows handle of Rhino's main window.</summary>
    ///<returns>(IntPtr) The Window's handle of Rhino's main window. IntPtr is a platform-specific type that is used to represent a pointer or a handle.</returns>
    static member WindowHandle() : IntPtr =
        RhinoApp.MainWindowHandle()


    ///<summary>Returns Rhino's working folder (directory).
    /// The working folder is the default folder for all file operations.</summary>
    ///<returns>(string) The current working folder.</returns>
    static member WorkingFolder() : string = //GET
        ApplicationSettings.FileSettings.WorkingFolder

    ///<summary>Sets Rhino's working folder (directory).
    /// The working folder is the default folder for all file operations.</summary>
    ///<param name="folder">(string) The new working folder for the current Rhino session</param>
    ///<returns>(unit) void, nothing.</returns>
    static member WorkingFolder(folder:string) : unit = //SET
        RhinoSync.DoSync (fun () ->
            ApplicationSettings.FileSettings.WorkingFolder <- folder)



    //---End of header marker: don't change: {@$%^&*()*&^%$@}



    ///<summary>Adds a new block definition to the document.</summary>
    ///<param name="objectIds">(Guid seq) Objects that will be included in the block</param>
    ///<param name="basePoint">(Point3d) 3D base point for the block definition</param>
    ///<param name="name">(string) Optional, default value: <c>InstanceDefinitions.GetUnusedInstanceDefinitionName()</c>
    ///    Name of the block definition. If omitted a name will be automatically generated</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>false</c>
    ///    If True, the objectIds will be deleted</param>
    ///<returns>(string) name of new block definition.</returns>
    static member AddBlock(objectIds:Guid seq, basePoint:Point3d, [<OPT;DEF("")>]name:string, [<OPT;DEF(false)>]deleteInput:bool) : string =
        let name = if name="" then State.Doc.InstanceDefinitions.GetUnusedInstanceDefinitionName() else name
        let found = State.Doc.InstanceDefinitions.Find(name)
        let objects = ResizeArray()
        for objectId in objectIds do
            let obj = RhinoScriptSyntax.CoerceRhinoObject(objectId)  //Coerce should not be needed
            if obj.IsReference then  RhinoScriptingException.Raise "RhinoScriptSyntax.AddBlock: cannot add Reference object '%s' to '%s'" (Nice.str objectId) name
            let ot = obj.ObjectType
            if   ot= DocObjects.ObjectType.Light then  RhinoScriptingException.Raise "RhinoScriptSyntax.AddBlock: cannot add Light object '%s' to '%s'" (Nice.str objectId) name
            elif ot= DocObjects.ObjectType.Grip then  RhinoScriptingException.Raise "RhinoScriptSyntax.AddBlock: cannot add Grip object '%s' to '%s'" (Nice.str objectId) name
            elif ot= DocObjects.ObjectType.Phantom then RhinoScriptingException.Raise "RhinoScriptSyntax.AddBlock: cannot add Phantom object '%s' to '%s'" (Nice.str objectId) name
            elif ot= DocObjects.ObjectType.InstanceReference && notNull found then
                let bli = RhinoScriptSyntax.CoerceBlockInstanceObject(objectId) // not obj ?
                let uses, _ = bli.UsesDefinition(found.Index) // _ = nesting
                if uses then RhinoScriptingException.Raise "RhinoScriptSyntax.AddBlock: cannot add Instance Ref object '%s' to '%s'" (Nice.str objectId) name

            objects.Add(obj)
        if objects.Count>0 then
            let geometry = [ for obj in objects -> obj.Geometry]
            let attrs = [ for obj in objects -> obj.Attributes]
            let mutable rc = -1
            if notNull found then
                rc <- if State.Doc.InstanceDefinitions.ModifyGeometry(found.Index, geometry, attrs) then 0 else -1
            else
                rc <- State.Doc.InstanceDefinitions.Add(name, "", basePoint, geometry, attrs)
            if rc >= 0 then
                if deleteInput then
                    for obj in objects do State.Doc.Objects.Delete(obj, quiet=true) |>ignore
                State.Doc.Views.Redraw()
        name


    ///<summary>Returns names of the block definitions that contain a specified block
    ///    definition.</summary>
    ///<param name="blockName">(string) The name of an existing block definition</param>
    ///<returns>(string ResizeArray) A list of block definition names.</returns>
    static member BlockContainers(blockName:string) : string ResizeArray =
        let instDef = State.Doc.InstanceDefinitions.Find(blockName)
        if isNull instDef then  RhinoScriptingException.Raise "RhinoScriptSyntax.BlockContainers: '%s' does not exist in InstanceDefinitionsTable" blockName
        let containers = instDef.GetContainers()
        let rc = ResizeArray()
        for item in containers do
            if not <| item.IsDeleted then  rc.Add(item.Name)
        rc

    ///<summary>Returns number of block definitions that contain a specified
    ///    block definition.</summary>
    ///<param name="blockName">(string) The name of an existing block definition</param>
    ///<returns>(int) The number of block definitions that contain a specified block definition.</returns>
    static member BlockContainerCount(blockName:string) : int =
        (RhinoScriptSyntax.BlockContainers(blockName)).Count


    ///<summary>Returns the number of block definitions in the document.</summary>
    ///<returns>(int) The number of block definitions in the document.</returns>
    static member BlockCount() : int =
        State.Doc.InstanceDefinitions.ActiveCount


    ///<summary>Returns the description of a block definition.</summary>
    ///<param name="blockName">(string) The name of an existing block definition</param>
    ///<returns>(string) The current description.</returns>
    static member BlockDescription(blockName:string) : string = //GET
        let instDef = State.Doc.InstanceDefinitions.Find(blockName)
        if isNull instDef then  RhinoScriptingException.Raise "RhinoScriptSyntax.BlockDescription: '%s' does not exist in InstanceDefinitionsTable" blockName
        instDef.Description

    ///<summary>Sets the description of a block definition.</summary>
    ///<param name="blockName">(string) The name of an existing block definition</param>
    ///<param name="description">(string) The new description</param>
    ///<returns>(unit) void, nothing.</returns>
    static member BlockDescription(blockName:string, description:string) : unit = //SET
        let instDef = State.Doc.InstanceDefinitions.Find(blockName)
        if isNull instDef then  RhinoScriptingException.Raise "RhinoScriptSyntax.BlockDescription:'%s' does not exist in InstanceDefinitionsTable" blockName
        State.Doc.InstanceDefinitions.Modify( instDef, instDef.Name, description, true ) |>ignore


    ///<summary>Counts number of instances of the block in the document.
    ///    Nested instances are not included in the count. Attention this may include deleted blocks.</summary>
    ///<param name="blockName">(string) The name of an existing block definition</param>
    ///<param name="whereToLook">(int) Optional, default value: <c>0</c>
    ///    0 = get top level references in active document.
    ///    1 = get top level and nested references in active document.
    ///      If a block is nested more than once within another block it will be counted only once.
    ///    2 = check for references from other instance definitions, counts every instance of nested block</param>
    ///<returns>(int) The number of instances of the block in the document.</returns>
    static member BlockInstanceCount(blockName:string, [<OPT;DEF(0)>]whereToLook:int) : int =
        let instDef = State.Doc.InstanceDefinitions.Find(blockName)
        if isNull instDef then  RhinoScriptingException.Raise "RhinoScriptSyntax.BlockInstanceCount: '%s' does not exist in InstanceDefinitionsTable" blockName
        let  refs = instDef.GetReferences(whereToLook)
        refs.Length


    ///<summary>Returns the insertion point of a block instance.</summary>
    ///<param name="objectId">(Guid) The identifier of an existing block insertion object</param>
    ///<returns>(Point3d) The insertion 3D point.</returns>
    static member BlockInstanceInsertPoint(objectId:Guid) : Point3d =
        let  instance = RhinoScriptSyntax.CoerceBlockInstanceObject(objectId)
        let  xf = instance.InstanceXform
        let  pt = Point3d(0. , 0. , 0.)
        pt.Transform(xf)
        pt


    ///<summary>Returns the block name of a block instance.</summary>
    ///<param name="objectId">(Guid) The identifier of an existing block insertion object</param>
    ///<returns>(string) The block name of a block instance.</returns>
    static member BlockInstanceName(objectId:Guid) : string =
        let mutable instance = RhinoScriptSyntax.CoerceBlockInstanceObject(objectId)
        let mutable instDef = instance.InstanceDefinition
        instDef.Name


    ///<summary>Returns the identifiers of the inserted instances of a block.</summary>
    ///<param name="blockName">(string) The name of an existing block definition</param>
    ///<param name="whereToLook">(int) Optional, default value: <c>0</c>
    ///    0 = get top level references in active document.
    ///    1 = get top level and nested references in active document.
    ///    2 = check for references from other instance definitions</param>
    ///<returns>(Guid ResizeArray) Ids identifying the instances of a block in the model.</returns>
    static member BlockInstances(blockName:string, [<OPT;DEF(0)>]whereToLook:int) : ResizeArray<Guid> =
        let instDef = State.Doc.InstanceDefinitions.Find(blockName)
        if isNull instDef then  RhinoScriptingException.Raise "RhinoScriptSyntax.BlockInstances: '%s' does not exist in InstanceDefinitionsTable" blockName
        let instances = instDef.GetReferences(whereToLook)
        let rc = ResizeArray(instances.Length)
        for item in instances do rc.Add(item.Id)
        rc


    ///<summary>Returns the location of a block instance relative to the world coordinate
    ///    system origin (0, 0, 0). The position is returned as a 4x4 transformation
    ///    matrix.</summary>
    ///<param name="objectId">(Guid) The identifier of an existing block insertion object</param>
    ///<returns>(Transform) The location, as a transform matrix, of a block instance relative to the world coordinate
    ///    system origin.</returns>
    static member BlockInstanceXform(objectId:Guid) : Transform =
        let  instance = RhinoScriptSyntax.CoerceBlockInstanceObject(objectId)
        instance.InstanceXform


    ///<summary>Returns the names of all block definitions in the document.</summary>
    ///<returns>(string ResizeArray) The names of all block definitions in the document.</returns>
    static member BlockNames() : string ResizeArray =
        let  instDefList = State.Doc.InstanceDefinitions.GetList(true)
        let rc = ResizeArray(instDefList.Length)
        for item in instDefList do rc.Add(item.Name)
        rc




    ///<summary>Returns number of objects that make up a block definition.</summary>
    ///<param name="blockName">(string) Name of an existing block definition</param>
    ///<returns>(int) The number of objects that make up a block definition.</returns>
    static member BlockObjectCount(blockName:string) : int =
        let instDef = State.Doc.InstanceDefinitions.Find(blockName)
        if isNull instDef then  RhinoScriptingException.Raise "RhinoScriptSyntax.BlockObjectCount:'%s' does not exist in InstanceDefinitionsTable" blockName
        instDef.ObjectCount


    ///<summary>Returns identifiers of the objects that make up a block definition.</summary>
    ///<param name="blockName">(string) Name of an existing block definition</param>
    ///<returns>(Guid ResizeArray) list of identifiers.</returns>
    static member BlockObjects(blockName:string) : ResizeArray<Guid> =
        let instDef = State.Doc.InstanceDefinitions.Find(blockName)
        if isNull instDef then  RhinoScriptingException.Raise "RhinoScriptSyntax.BlockObjects: '%s' does not exist in InstanceDefinitionsTable" blockName
        let  rhobjs = instDef.GetObjects()
        let rc = ResizeArray(rhobjs.Length)
        for item in rhobjs do rc.Add(item.Id)
        rc


    ///<summary>Returns path to the source of a linked or embedded block definition.
    ///    A linked or embedded block definition is a block definition that was
    ///    inserted from an external file.</summary>
    ///<param name="blockName">(string) Name of an existing block definition</param>
    ///<returns>(string) path to the linked block.</returns>
    static member BlockPath(blockName:string) : string =
        let instDef = State.Doc.InstanceDefinitions.Find(blockName)
        if isNull instDef then  RhinoScriptingException.Raise "RhinoScriptSyntax.BlockPath: '%s' does not exist in InstanceDefinitionsTable" blockName
        instDef.SourceArchive


    ///<summary>Returns the status of a linked block.</summary>
    ///<param name="blockName">(string) Name of an existing block</param>
    ///<returns>(int) The status of a linked block
    ///    Value Description
    ///    -3    Not a linked block definition.
    ///    -2    The linked block definition's file could not be opened or could not be read.
    ///    -1    The linked block definition's file could not be found.
    ///      0    The linked block definition is up-to-date.
    ///      1    The linked block definition's file is newer than definition.
    ///      2    The linked block definition's file is older than definition.
    ///      3    The linked block definition's file is different than definition.</returns>
    static member BlockStatus(blockName:string) : int =
        let  instDef = State.Doc.InstanceDefinitions.Find(blockName)
        if isNull instDef then  -3
        else int(instDef.ArchiveFileStatus)


    ///<summary>Deletes a block definition and all of it's inserted instances.</summary>
    ///<param name="blockName">(string) Name of an existing block definition</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member DeleteBlock(blockName:string) : bool =
        let instDef = State.Doc.InstanceDefinitions.Find(blockName)
        if isNull instDef then  RhinoScriptingException.Raise "RhinoScriptSyntax.DeleteBlock: '%s' does not exist in InstanceDefinitionsTable" blockName
        let  rc = State.Doc.InstanceDefinitions.Delete(instDef.Index, deleteReferences=true, quiet=false)
        State.Doc.Views.Redraw()
        rc


    ///<summary>Explodes a block instance into it's geometric components. The exploded objects are added to the document. The block instance is deleted</summary>
    ///<param name="objectId">(Guid) The identifier of an existing block insertion object</param>
    ///<param name="explodeNestedInstances">(bool) Optional, default value: <c>false</c>
    ///    By default nested blocks are not exploded</param>
    ///<returns>(Guid array) identifiers for the newly exploded objects.</returns>
    static member ExplodeBlockInstance(objectId:Guid, [<OPT;DEF(false)>]explodeNestedInstances:bool) : array<Guid> =
        let  instance = RhinoScriptSyntax.CoerceBlockInstanceObject(objectId)
        let  guids = State.Doc.Objects.AddExplodedInstancePieces(instance, explodeNestedInstances, deleteInstance = true)
        if guids.Length > 0 then State.Doc.Views.Redraw()
        guids



    ///<summary>Inserts a block whose definition already exists in the document.</summary>
    ///<param name="blockName">(string) Name of an existing block definition</param>
    ///<param name="xForm">(Transform) 4x4 transformation matrix to apply</param>
    ///<returns>(Guid) objectId for the block that was added to the doc.</returns>
    static member InsertBlock2(blockName:string, xForm:Transform) : Guid =
        let instDef = State.Doc.InstanceDefinitions.Find(blockName)
        if isNull instDef then  RhinoScriptingException.Raise "RhinoScriptSyntax.InsertBlock2: '%s' does not exist in InstanceDefinitionsTable" blockName
        let objectId = State.Doc.Objects.AddInstanceObject(instDef.Index, xForm )
        if objectId<>System.Guid.Empty then
            State.Doc.Views.Redraw()
        objectId


    ///<summary>Inserts a block whose definition already exists in the document.</summary>
    ///<param name="blockName">(string) Name of an existing block definition</param>
    ///<param name="insertionPoint">(Point3d) Insertion point for the block</param>
    ///<param name="scale">(Vector3d) Optional, default value: <c>Vector3d(1.0 , 1.0 , 1.0)</c>
    ///    X, y, z scale factors</param>
    ///<param name="angleDegrees">(float) Optional, default value: <c>0</c>
    ///    Rotation angle in degrees</param>
    ///<param name="rotationNormal">(Vector3d) Optional, default value: <c> Vector3d.ZAxis</c>
    ///    The axis of rotation</param>
    ///<returns>(Guid) objectId for the block that was added to the doc.</returns>
    static member InsertBlock(blockName:string, insertionPoint:Point3d, [<OPT;DEF(Vector3d())>]scale:Vector3d, [<OPT;DEF(0.0)>]angleDegrees:float, [<OPT;DEF(Vector3d())>]rotationNormal:Vector3d) : Guid =
        let angleRadians = toRadians(angleDegrees)
        let sc= if scale.IsZero then Vector3d(1. , 1. , 1.) else scale
        let rotationNormal0 = if rotationNormal.IsZero then Vector3d.ZAxis else rotationNormal
        let move = Transform.Translation(insertionPoint.X, insertionPoint.Y, insertionPoint.Z)
        let scale = Transform.Scale(Geometry.Plane.WorldXY, sc.X, sc.Y, sc.Z)
        let rotate = Transform.Rotation(angleRadians, rotationNormal0, Geometry.Point3d.Origin)
        let xForm = move * scale * rotate
        RhinoScriptSyntax.InsertBlock2 (blockName, xForm)


    ///<summary>Checks if the existence of a block definition in the document.</summary>
    ///<param name="blockName">(string) Name of an existing block definition</param>
    ///<returns>(bool) True or False.</returns>
    static member IsBlock(blockName:string) : bool =
        let instDef = State.Doc.InstanceDefinitions.Find(blockName)
        not <| isNull instDef


    ///<summary>Checks if a block definition is embedded, or linked, from an external file.</summary>
    ///<param name="blockName">(string) Name of an existing block definition</param>
    ///<returns>(bool) True or False.</returns>
    static member IsBlockEmbedded(blockName:string) : bool =
        let instDef = State.Doc.InstanceDefinitions.Find(blockName)
        if isNull instDef then  RhinoScriptingException.Raise "RhinoScriptSyntax.IsBlockEmbedded '%s' does not exist in InstanceDefinitionsTable" blockName
        match int( instDef.UpdateType) with
        | 1  -> true //DocObjects.InstanceDefinitionUpdateType.Embedded
        | 2  -> true //DocObjects.InstanceDefinitionUpdateType.LinkedAndEmbedded
        |_-> false


    ///<summary>Checks if an object is a block instance. Returns false for any other rhino object.</summary>
    ///<param name="objectId">(Guid) The identifier of an existing block insertion object</param>
    ///<returns>(bool) True or False.</returns>
    static member IsBlockInstance(objectId:Guid) : bool =
        match RhinoScriptSyntax.CoerceRhinoObject(objectId) with
        | :? DocObjects.InstanceObject as _ -> true
        | _ -> false


    ///<summary>Checks if that a block definition is being used by an inserted instance.</summary>
    ///<param name="blockName">(string) Name of an existing block definition</param>
    ///<param name="whereToLook">(int) Optional, default value: <c>0</c>
    ///    One of the following values
    ///    0 = Check for top level references in active document
    ///    1 = Check for top level and nested references in active document
    ///    2 = Check for references in other instance definitions</param>
    ///<returns>(bool) True or False.</returns>
    static member IsBlockInUse(blockName:string, [<OPT;DEF(0)>]whereToLook:int) : bool =
        let instDef = State.Doc.InstanceDefinitions.Find(blockName)
        if isNull instDef then  RhinoScriptingException.Raise "RhinoScriptSyntax.IsBlockInUse '%s' does not exist in InstanceDefinitionsTable" blockName
        instDef.InUse(whereToLook)


    ///<summary>Checks if that a block definition is from a reference file.</summary>
    ///<param name="blockName">(string) Name of an existing block definition</param>
    ///<returns>(bool) True or False.</returns>
    static member IsBlockReference(blockName:string) : bool =
        let instDef = State.Doc.InstanceDefinitions.Find(blockName)
        if isNull instDef then  RhinoScriptingException.Raise "RhinoScriptSyntax.IsBlockReference '%s' does not exist in InstanceDefinitionsTable" blockName
        instDef.IsReference


    ///<summary>Renames an existing block definition.</summary>
    ///<param name="blockName">(string) Name of an existing block definition</param>
    ///<param name="newName">(string) Name to change to</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member RenameBlock(blockName:string, newName:string) : bool =
        let instDef = State.Doc.InstanceDefinitions.Find(blockName)
        if isNull instDef then  RhinoScriptingException.Raise "RhinoScriptSyntax.RenameBlock '%s' does not exist in InstanceDefinitionsTable" blockName
        let description = instDef.Description
        State.Doc.InstanceDefinitions.Modify(instDef, newName, description, quiet=false)


    ///<summary>Replace the objects inside an existing block definition.</summary>
    ///<param name="blockName">(string) Name of an existing block definition</param>
    ///<param name="newObjects">(string) Objects for replacing existing objects, can be partially the same as current objects too</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>true</c> delete the input objects from document, so that they only exist in the block definition.</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member ReplaceBlockObjects(blockName:string, newObjects:seq<Guid>,[<OPT;DEF(true)>]deleteInput:bool) : bool =
        let instDef = State.Doc.InstanceDefinitions.Find(blockName)
        if isNull instDef then  RhinoScriptingException.Raise "RhinoScriptSyntax.ReplaceBlockObjects '%s' does not exist in InstanceDefinitionsTable" blockName
        let objs  = newObjects |> Seq.map RhinoScriptSyntax.CoerceRhinoObject |> Array.ofSeq // just to be sure its not lazy
        let geos  = objs |> Array.map (fun o-> o.Geometry)
        let attrs = objs |> Array.map (fun o-> o.Attributes)
        if deleteInput then
            let k = State.Doc.Objects.Delete(newObjects, quiet=true)
            let l = Seq.length newObjects
            if k <> l then RhinoScriptingException.Raise "RhinoScriptSyntax.ReplaceBlockObjects failed to delete input on %d out of %s" (l-k) (Nice.str newObjects)
        State.Doc.InstanceDefinitions.ModifyGeometry(instDef.Index,geos,attrs)

    //---End of header marker: don't change: {@$%^&*()*&^%$@}



    ///<summary>Adds an arc Curve to the document.</summary>
    ///<param name="plane">(Plane) Plane on which the arc will lie. The origin of the Plane will be
    ///    the center point of the arc. x-axis of the Plane defines the 0 angle
    ///    direction</param>
    ///<param name="radius">(float) Radius of the arc</param>
    ///<param name="angleDegrees">(float) Interval of arc in degrees</param>
    ///<returns>(Guid) objectId of the new Curve object.</returns>
    static member AddArc(plane:Plane, radius:float, angleDegrees:float) : Guid =
        let radians = toRadians(angleDegrees)
        let arc = Arc(plane, radius, radians)
        let rc = State.Doc.Objects.AddArc(arc)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddArc: Unable to add arc to document.  plane:'%A' radius:'%A' angleDegrees:'%A'" plane radius angleDegrees
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds a 3-point arc Curve to the document.</summary>
    ///<param name="start">(Point3d) Start of the arc</param>
    ///<param name="ende">(Point3d) Endpoint of the arc</param>
    ///<param name="pointOnArc">(Point3d) A point on the arc</param>
    ///<returns>(Guid) objectId of the new Curve object.</returns>
    static member AddArc3Pt(start:Point3d, ende:Point3d, pointOnArc:Point3d) : Guid =
        let arc = Arc(start, pointOnArc, ende)
        let rc = State.Doc.Objects.AddArc(arc)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddArc3Pt: Unable to add arc to document.  start:'%A' ende:'%A' pointOnArc:'%A'" start ende pointOnArc
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds an arc Curve, created from a start point, a start direction, and an
    ///    end point, to the document.</summary>
    ///<param name="start">(Point3d) The starting point of the arc</param>
    ///<param name="direction">(Vector3d) The arc direction at start</param>
    ///<param name="ende">(Point3d) The ending point of the arc</param>
    ///<returns>(Guid) objectId of the new Curve object.</returns>
    static member AddArcPtTanPt(start:Point3d, direction:Vector3d, ende:Point3d) : Guid =
        let arc = Arc(start, direction, ende)
        let rc = State.Doc.Objects.AddArc(arc)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddArcPtTanPt: Unable to add arc to document.  start:'%A' direction:'%A' ende:'%A'" start direction ende
        State.Doc.Views.Redraw()
        rc


    ///<summary>Makes a Curve blend between two Curves.</summary>
    ///<param name="curves">(Guid * Guid) List of two Curves</param>
    ///<param name="parameters">(float * float) List of two Curve parameters defining the blend end points</param>
    ///<param name="reverses">(bool * bool) List of two boolean values specifying to use the natural or opposite direction of the Curve</param>
    ///<param name="continuities">(int * int) List of two numbers specifying continuity at end points
    ///    0 = position
    ///    1 = tangency
    ///    2 = curvature</param>
    ///<returns>(Guid) identifier of new Curve.</returns>
    static member AddBlendCurve(curves:Guid * Guid, parameters:float * float, reverses:bool * bool, continuities:int * int) : Guid =
        let crv0 = RhinoScriptSyntax.CoerceCurve (fst curves)
        let crv1 = RhinoScriptSyntax.CoerceCurve (snd curves)
        let c0:BlendContinuity = EnumOfValue(fst continuities)
        let c1:BlendContinuity = EnumOfValue(snd continuities)
        let curve = Curve.CreateBlendCurve(crv0, fst parameters, fst reverses, c0, crv1, snd parameters, snd reverses, c1)
        let rc = State.Doc.Objects.AddCurve(curve)
        if rc = Guid.Empty then  RhinoScriptingException.Raise "RhinoScriptSyntax.AddBlendCurve: Unable to add curve to document.  curves:'%A' parameters:'%A' reverses:'%A' continuities:'%A'" curves parameters reverses continuities
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds a circle Curve to the document.</summary>
    ///<param name="plane">(Plane) Plane on which the circle will lie.</param>
    ///<param name="radius">(float) The radius of the circle</param>
    ///<returns>(Guid) objectId of the new Curve object.</returns>
    static member AddCircle(plane:Plane, radius:float) : Guid =
        let circle = Circle(plane, radius)
        let rc = State.Doc.Objects.AddCircle(circle)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddCircle: Unable to add circle to document.  plane:'%O' radius:'%f'" plane radius
        State.Doc.Views.Redraw()
        rc

    ///<summary>Adds a circle Curve to the document.</summary>
    ///<param name="center">(Point3d) Center of circle will lie. Plane wil be world XY </param>
    ///<param name="radius">(float) The radius of the circle</param>
    ///<returns>(Guid) ObjectId of the new Curve object.</returns>
    static member AddCircle(center:Point3d, radius:float) : Guid =
        let circle = Circle(center, radius)
        let rc = State.Doc.Objects.AddCircle(circle)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddCircle: Unable to add circle to document.  center:'%s' radius:'%f'" center.ToNiceString radius
        State.Doc.Views.Redraw()
        rc

    ///<summary>Adds a 3-point circle Curve to the document.</summary>
    ///<param name="first">(Point3d) First point on the circle'</param>
    ///<param name="second">(Point3d) Second point on the circle'</param>
    ///<param name="third">(Point3d) Third point on the circle'</param>
    ///<returns>(Guid) objectId of the new Curve object.</returns>
    static member AddCircle3Pt(first:Point3d, second:Point3d, third:Point3d) : Guid =
        let circle = Circle(first, second, third)
        let rc = State.Doc.Objects.AddCircle(circle)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddCircle3Pt: Unable to add circle to document.  first:'%A' second:'%A' third:'%A'" first second third
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds a control points Curve object to the document.</summary>
    ///<param name="points">(Point3d seq) A list of points</param>
    ///<param name="degree">(int) Optional, default value: <c>3</c>
    ///    Degree of the Curve</param>
    ///<returns>(Guid) objectId of the new Curve object.</returns>
    static member AddCurve(points:Point3d seq, [<OPT;DEF(3)>]degree:int) : Guid =
        let  curve = Curve.CreateControlPointCurve(points, degree)
        if isNull curve then RhinoScriptingException.Raise "RhinoScriptSyntax.AddCurve: Unable to create control point curve from given points.  points:'%A' degree:'%A'" points degree
        let  rc = State.Doc.Objects.AddCurve(curve)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddCurve: Unable to add curve to document.  points:'%A' degree:'%A'" points degree
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds an elliptical Curve to the document.</summary>
    ///<param name="plane">(Plane) The Plane on which the ellipse will lie. The origin of
    ///    the Plane will be the center of the ellipse</param>
    ///<param name="radiusX">(float) radius in the X axis direction</param>
    ///<param name="radiusY">(float) radius in the Y axis direction</param>
    ///<returns>(Guid) objectId of the new Curve object.</returns>
    static member AddEllipse(plane:Plane, radiusX:float, radiusY:float) : Guid =
        let ellipse = Ellipse(plane, radiusX, radiusY)
        let rc = State.Doc.Objects.AddEllipse(ellipse)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddEllipse: Unable to add curve to document. plane:'%A' radiusX:'%A' radiusY:'%A'" plane radiusX radiusY
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds a 3-point elliptical Curve to the document.</summary>
    ///<param name="center">(Point3d) Center point of the ellipse</param>
    ///<param name="second">(Point3d) End point of the x axis</param>
    ///<param name="third">(Point3d) End point of the y axis</param>
    ///<returns>(Guid) objectId of the new Curve object.</returns>
    static member AddEllipse3Pt(center:Point3d, second:Point3d, third:Point3d) : Guid =
        let  ellipse = Ellipse(center, second, third)
        let  rc = State.Doc.Objects.AddEllipse(ellipse)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddEllipse3Pt: Unable to add curve to document.  center:'%A' second:'%A' third:'%A'" center second third
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds a fillet Curve between two Curve objects.</summary>
    ///<param name="curveA">(Guid) Identifier of the first Curve object</param>
    ///<param name="curveB">(Guid) Identifier of the second Curve object</param>
    ///<param name="radius">(float) Optional, default value: <c>1.0</c>
    ///    Fillet radius</param>
    ///<param name="basePointA">(Point3d) Optional, Base point of the first Curve. If omitted,
    ///    starting point of the Curve is used</param>
    ///<param name="basePointB">(Point3d) Optional, Base point of the second Curve. If omitted,
    ///    starting point of the Curve is used</param>
    ///<returns>(Guid) objectId of the new Curve object.</returns>
    static member AddFilletCurve(curveA:Guid, curveB:Guid, [<OPT;DEF(1.0)>]radius:float, [<OPT;DEF(Point3d())>]basePointA:Point3d, [<OPT;DEF(Point3d())>]basePointB:Point3d) : Guid =
        //TODO make overload instead,[<OPT;DEF(Point3d())>] may leak  see draw vector and transform point!
        let basePointA = if basePointA = Point3d.Origin then Point3d.Unset else basePointA
        let basePointB = if basePointB = Point3d.Origin then Point3d.Unset else basePointB
        let  curve0 = RhinoScriptSyntax.CoerceCurve (curveA)
        let  curve1 = RhinoScriptSyntax.CoerceCurve (curveB)
        let mutable crv0T = 0.0
        if basePointA= Point3d.Unset then
            crv0T <- curve0.Domain.Min
        else
            let rc, t = curve0.ClosestPoint(basePointA)
            if not <| rc then RhinoScriptingException.Raise "RhinoScriptSyntax.AddFilletCurve ClosestPoint failed.  curveA:'%A' curveB:'%A' radius:'%A' basePointA:'%A' basePointB:'%A'" curveA curveB radius basePointA basePointB
            crv0T <- t
        let mutable crv1T = 0.0
        if basePointB= Point3d.Unset then
            crv1T <- curve1.Domain.Min
        else
            let rc, t = curve1.ClosestPoint(basePointB)
            if not <| rc then RhinoScriptingException.Raise "RhinoScriptSyntax.AddFilletCurve ClosestPoint failed.  curveA:'%A' curveB:'%A' radius:'%A' basePointA:'%A' basePointB:'%A'" curveA curveB radius basePointA basePointB
            crv1T <- t
        let mutable arc = Curve.CreateFillet(curve0, curve1, radius, crv0T, crv1T)
        let mutable rc = State.Doc.Objects.AddArc(arc)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddFilletCurve: Unable to add fillet curve to document.  curveA:'%A' curveB:'%A' radius:'%A' basePointA:'%A' basePointB:'%A'" curveA curveB radius basePointA basePointB
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds an interpolated Curve object that lies on a specified
    ///    Surface. Note, this function will not create periodic Curves,
    ///    but it will create closed Curves.</summary>
    ///<param name="surfaceId">(Guid) Identifier of the Surface to create the Curve on</param>
    ///<param name="points">(Point3d seq) List of 3D points that lie on the specified Surface.
    ///    The list must contain at least 2 points</param>
    ///<returns>(Guid) objectId of the new Curve object.</returns>
    static member AddInterpCrvOnSrf(surfaceId:Guid, points:Point3d seq) : Guid =
        let  surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let  tolerance = State.Doc.ModelAbsoluteTolerance
        let  curve = surface.InterpolatedCurveOnSurface(points, tolerance)
        if isNull curve then RhinoScriptingException.Raise "RhinoScriptSyntax.AddInterpCrvOnSrf: Unable to create InterpolatedCurveOnSurface.  surfaceId:'%s' points:'%A'" (Nice.str surfaceId) points
        let mutable rc = State.Doc.Objects.AddCurve(curve)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddInterpCrvOnSrf: Unable to add curve to document.  surfaceId:'%s' points:'%A'" (Nice.str surfaceId) points
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds an interpolated Curve object based on Surface parameters,
    ///    that lies on a specified Surface. Note, this function will not
    ///    create periodic Curves, but it will create closed Curves.</summary>
    ///<param name="surfaceId">(Guid) Identifier of the Surface to create the Curve on</param>
    ///<param name="points">(Point2d seq) A list of 2D Surface parameters. The list must contain
    ///    at least 2 sets of parameters</param>
    ///<returns>(Guid) objectId of the new Curve object.</returns>
    static member AddInterpCrvOnSrfUV(surfaceId:Guid, points:Point2d seq) : Guid =
        let mutable surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let mutable tolerance = State.Doc.ModelAbsoluteTolerance
        let mutable curve = surface.InterpolatedCurveOnSurfaceUV(points, tolerance)
        if isNull curve then RhinoScriptingException.Raise "RhinoScriptSyntax.AddInterpCrvOnSrfUV: Unable to create InterpolatedCurveOnSurfaceUV.  surfaceId:'%s' points:'%A'" (Nice.str surfaceId) points
        let mutable rc = State.Doc.Objects.AddCurve(curve)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddInterpCrvOnSrfUV: Unable to add curve to document.  surfaceId:'%s' points:'%A'" (Nice.str surfaceId) points
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds an interpolated Curve object to the document. Options exist to make
    ///    a periodic Curve or to specify the tangent at the endpoints. The resulting
    ///    Curve is a non-rational NURBS Curve of the specified degree.</summary>
    ///<param name="points">(Point3d seq) A list containing 3D points to interpolate. For periodic Curves,
    ///    if the final point is a duplicate of the initial point, it is
    ///    ignored. The number of control points must be bigger than 'degree' number</param>
    ///<param name="degree">(int) Optional, default value: <c>3</c>
    ///    Periodic Curves must have a degree bigger than 1. For knot-style = 1 or 2,
    ///    the degree must be 3. For knot-style = 4 or 5, the degree must be odd</param>
    ///<param name="knotStyle">(int) Optional, default value: <c>0</c>
    ///    0 Uniform knots. Parameter spacing between consecutive knots is 1.0.
    ///    1 Chord length spacing. Requires degree = 3 with arrCV1 and arrCVn1 specified.
    ///    2 Sqrt (chord length). Requires degree = 3 with arrCV1 and arrCVn1 specified.
    ///    3 Periodic with uniform spacing.
    ///    4 Periodic with chord length spacing. Requires an odd degree value.
    ///    5 Periodic with sqrt (chord length) spacing. Requires an odd degree value</param>
    ///<param name="startTangent">(Vector3d) Optional, A vector that specifies a tangency condition at the
    ///    beginning of the Curve. If the Curve is periodic, this argument must be omitted</param>
    ///<param name="endTangent">(Vector3d) Optional, 3d vector that specifies a tangency condition at the
    ///    end of the Curve. If the Curve is periodic, this argument must be omitted</param>
    ///<returns>(Guid) objectId of the new Curve object.</returns>
    static member AddInterpCurve(   points:Point3d seq,
                                    [<OPT;DEF(3)>]degree:int,
                                    [<OPT;DEF(0)>]knotStyle:int,
                                    [<OPT;DEF(Vector3d())>]startTangent:Vector3d,  //TODO make overload instead,[<OPT;DEF(Point3d())>] may leak  see draw vector and transform point!
                                    [<OPT;DEF(Vector3d())>]endTangent:Vector3d) : Guid =
        let endTangent   = if endTangent.IsZero then Vector3d.Unset else endTangent
        let startTangent = if startTangent.IsZero then Vector3d.Unset else startTangent
        let knotstyle : CurveKnotStyle = EnumOfValue knotStyle
        let  curve = Curve.CreateInterpolatedCurve(points, degree, knotstyle, startTangent, endTangent)
        if isNull curve then RhinoScriptingException.Raise "RhinoScriptSyntax.AddInterpCurve: Unable to CreateInterpolatedCurve.  points:'%A' degree:'%A' knotStyle:%d startTangent:'%A' endTangent:'%A'" points degree knotStyle startTangent endTangent
        let  rc = State.Doc.Objects.AddCurve(curve)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddInterpCurve: Unable to add curve to document.  points:'%A' degree:'%A' knotStyle:%d startTangent:'%A' endeTangent:'%A'" points degree knotStyle startTangent endTangent
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds a line Curve to the current model.</summary>
    ///<param name="start">(Point3d) Startpoint of the line</param>
    ///<param name="ende">(Point3d) Endpoint of the line</param>
    ///<returns>(Guid) objectId of the new Curve object.</returns>
    static member AddLine(start:Point3d, ende:Point3d) : Guid =
        let  rc = State.Doc.Objects.AddLine(start, ende)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddLine: Unable to add line to document. start:%s ende:%s" start.ToNiceString ende.ToNiceString
        State.Doc.Views.Redraw()
        rc

    ///<summary>Adds a line Curve to the current model.</summary>
    ///<param name="startX">(float) Startpoint of the line: X position</param>
    ///<param name="startY">(float) Startpoint of the line: Y position</param>
    ///<param name="startZ">(float) Startpoint of the line: Z position</param>
    ///<param name="endX">(float) Endpoint of the line: X position</param>
    ///<param name="endY">(float) Endpoint of the line: Y position</param>
    ///<param name="endZ">(float) Endpoint of the line:Z position</param>
    ///<returns>(Guid) objectId of the new Curve object.</returns>
    static member AddLine(startX,startY,startZ,endX,endY,endZ:float) : Guid =
        let start = Point3d(startX,startY,startZ)
        let ende = Point3d(endX,endY,endZ)
        let  rc = State.Doc.Objects.AddLine(start, ende)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddLine: Unable to add line to document. startX:%g ,startY:%g ,startZ:%g and endX:%g ,endY:%g ,endZ:%g" startX startY startZ endX endY endZ
        State.Doc.Views.Redraw()
        rc

    ///<summary>Adds a 2D Line Curve to the current model at z level 0.0</summary>
    ///<param name="startX">(float) Startpoint of the line: X position</param>
    ///<param name="startY">(float) Startpoint of the line: Y position</param>
    ///<param name="endX">(float) Endpoint of the line: X position</param>
    ///<param name="endY">(float) Endpoint of the line: Y position</param>
    ///<returns>(Guid) objectId of the new Curve object.</returns>
    static member AddLine2D(startX,startY,endX,endY:float) : Guid =
        let start = Point3d(startX,startY,0.0)
        let ende = Point3d(endX,endY,0.0)
        let  rc = State.Doc.Objects.AddLine(start, ende)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddLine2D: Unable to add line to document. startX:%g ,startY:%g  and  endX:%g ,endY:%g," startX startY  endX endY
        State.Doc.Views.Redraw()
        rc

    ///<summary>Creates a NURBS Curve geometry, but does not add or draw it to the document.</summary>
    ///<param name="points">(Point3d seq) A list containing 3D control points</param>
    ///<param name="knots">(float seq) Knot values for the Curve. The number of elements in knots must
    ///    equal the number of elements in points plus degree minus 1</param>
    ///<param name="degree">(int) Degree of the Curve. must be greater than of equal to 1</param>
    ///<param name="weights">(float seq) Optional, Weight values for the Curve. Number of elements should
    ///    equal the number of elements in points. Values must be greater than 0</param>
    ///<returns>(NurbsCurve) a NurbsCurve geometry.</returns>
    static member CreateNurbsCurve(points:Point3d seq, knots:float seq, degree:int, [<OPT;DEF(null: float seq)>]weights:float seq) : NurbsCurve =
        let cvcount = Seq.length(points)
        let knotcount = cvcount + degree - 1
        if Seq.length(knots)<>knotcount then
            RhinoScriptingException.Raise "RhinoScriptSyntax.CreateNurbsCurve:Number of elements in knots must equal the number of elements in points plus degree minus 1.  points:'%A' knots:'%A' degree:'%A' weights:'%A'" points knots degree weights
        let rational =
            if notNull weights then
                if Seq.length(weights)<>cvcount then
                    RhinoScriptingException.Raise "RhinoScriptSyntax.CreateNurbsCurve:Number of elements in weights should equal the number of elements in points.  points:'%A' knots:'%A' degree:'%A' weights:'%A'" points knots degree weights
                true
            else
            false
        let nc = new NurbsCurve(3, rational, degree + 1, cvcount)
        for i, k in Seq.indexed knots do
            nc.Knots.[i] <- k
        if notNull weights then
            if Seq.length(weights)<>cvcount then
                RhinoScriptingException.Raise "RhinoScriptSyntax.CreateNurbsCurve:Number of elements in weights should equal the number of elements in points.  points:'%A' knots:'%A' degree:'%A' weights:'%A'" points knots degree weights
            for i,(p, w)  in Seq.indexed (Seq.zip points weights) do
                nc.Points.SetPoint(i, p, w) |> ignore
        else
            for i, p in Seq.indexed points do
                nc.Points.SetPoint(i, p) |> ignore
        if not nc.IsValid then RhinoScriptingException.Raise "RhinoScriptSyntax.CreateNurbsCurve:Unable to create curve.  points:'%A' knots:'%A' degree:'%A' weights:'%A'" points knots degree weights
        nc

    ///<summary>Adds a NURBS Curve object to the document.</summary>
    ///<param name="points">(Point3d seq) A list containing 3D control points</param>
    ///<param name="knots">(float seq) Knot values for the Curve. The number of elements in knots must
    ///    equal the number of elements in points plus degree minus 1</param>
    ///<param name="degree">(int) Degree of the Curve. must be greater than of equal to 1</param>
    ///<param name="weights">(float seq) Optional, Weight values for the Curve. Number of elements should
    ///    equal the number of elements in points. Values must be greater than 0</param>
    ///<returns>(Guid) The identifier of the new object.</returns>
    static member AddNurbsCurve(points:Point3d seq, knots:float seq, degree:int, [<OPT;DEF(null: float seq)>]weights:float seq) : Guid =
        let nc = RhinoScriptSyntax.CreateNurbsCurve(points, knots, degree, weights)
        let rc = State.Doc.Objects.AddCurve(nc)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddNurbsCurve: Unable to add curve to document.  points:'%A' knots:'%A' degree:'%A' weights:'%A'" points knots degree weights
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds a Polyline Curve.</summary>
    ///<param name="points">(Point3d seq) List of 3D points. The list must contain at least two points. If the
    ///    list contains less than four points, then the first point and
    ///    last point must be different</param>
    ///<returns>(Guid) objectId of the new Curve object.</returns>
    static member AddPolyline(points:Point3d seq) : Guid =
        let pl = Polyline(points)
        //pl.DeleteShortSegments(State.Doc.ModelAbsoluteTolerance) |>ignore
        let rc = State.Doc.Objects.AddPolyline(pl)
        if rc = Guid.Empty then
            for i,pt in Seq.indexed(points) do
                let d = State.Doc.Objects.AddTextDot(string i, pt) // TODO really draw debug objects ?
                RhinoScriptSyntax.ObjectLayer(d,"ERROR-AddPolyline", createLayerIfMissing=true)
            eprintfn "See %d TextDots on layer 'ERROR-AddPolyline'"  (Seq.length points)
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddPolyline: Unable to add polyline to document form points:\r\n'%A'" (Nice.str points)
        State.Doc.Views.Redraw()
        rc

    ///<summary>Adds a closed Polyline Curve ,
    ///    if the endpoint is already closer than State.Doc.ModelAbsoluteTolerance to the start it wil be set to start point
    ///    else an additional point will be added with the same position as start.</summary>
    ///<param name="points">(Point3d seq) List of 3D points. The list must contain at least three points.</param>
    ///<returns>(Guid) objectId of the new Curve object.</returns>
    static member AddPolylineClosed(points:Point3d seq) : Guid =
        let pl = Polyline(points)
        if pl.Count < 3 then RhinoScriptingException.Raise "RhinoScriptSyntax.AddPolylineClosed: Unable to add closed polyline to document from points:\r\n'%A'" (Nice.str points)
        if (pl.First-pl.Last).Length <= State.Doc.ModelAbsoluteTolerance then
            pl.[pl.Count-1] <- pl.First
        else
            pl.Add pl.First
        //pl.DeleteShortSegments(State.Doc.ModelAbsoluteTolerance) |>ignore
        let rc = State.Doc.Objects.AddPolyline(pl)
        if rc = Guid.Empty then
            for i,pt in Seq.indexed(points) do
                let d = State.Doc.Objects.AddTextDot(string i, pt)  // TODO really draw debug objects ?
                RhinoScriptSyntax.ObjectLayer(d,"ERROR-AddPolylineClosed", createLayerIfMissing=true)
            eprintfn "See %d TextDots on layer 'ERROR-AddPolylineClosed'"  (Seq.length points)
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddPolylineClosed: Unable to add closed polyline to document.  points:'%A'" points
        State.Doc.Views.Redraw()
        rc

    ///<summary>Add a rectangular Curve to the document.</summary>
    ///<param name="plane">(Plane) Plane on which the rectangle will lie</param>
    ///<param name="width">(float) Width of rectangle as measured along the Plane's
    ///    x and y axes</param>
    ///<param name="height">(float) Height of rectangle as measured along the Plane's
    ///    x and y axes</param>
    ///<returns>(Guid) objectId of new rectangle.</returns>
    static member AddRectangle(plane:Plane, width:float, height:float) : Guid =
        let rect = Rectangle3d(plane, width, height)
        let poly = rect.ToPolyline()
        let rc = State.Doc.Objects.AddPolyline(poly)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddRectangle: Unable to add polyline to document.  plane:'%A' width:'%A' height:'%A'" plane width height
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds a spiral or helical Curve to the document.</summary>
    ///<param name="point0">(Point3d) Helix axis start point or center of spiral</param>
    ///<param name="point1">(Point3d) Helix axis end point or point normal on spiral Plane</param>
    ///<param name="pitch">(float) Distance between turns. If 0, then a spiral. If > 0 then the
    ///    distance between helix "threads"</param>
    ///<param name="turns">(float) Number of turns</param>
    ///<param name="radius0">(float) Starting radius of spiral</param>
    ///<param name="radius1">(float) Optional, Ending radius of spiral. If omitted, the starting radius is used for the complete spiral</param>
    ///<returns>(Guid) objectId of new Curve.</returns>
    static member AddSpiral(point0:Point3d, point1:Point3d, pitch:float, turns:float, radius0:float, [<OPT;DEF(0.0)>]radius1:float) : Guid =
        let dir = point1 - point0
        let plane = Plane(point0, dir)
        let point2 = point0 + plane.XAxis
        let r2 = if radius1 = 0.0 then radius0 else radius1
        let curve = NurbsCurve.CreateSpiral(point0, dir, point2, pitch, turns, radius0, r2)
        if isNull curve then RhinoScriptingException.Raise "RhinoScriptSyntax.AddSpiral: Unable to add curve to document.  point0:'%A' point1:'%A' pitch:'%A' turns:'%A' radius0:'%A' radius1:'%A'" point0 point1 pitch turns radius0 radius1
        let rc = State.Doc.Objects.AddCurve(curve)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddSpiral: Unable to add curve to document.  point0:'%A' point1:'%A' pitch:'%A' turns:'%A' radius0:'%A' radius1:'%A'" point0 point1 pitch turns radius0 radius1
        State.Doc.Views.Redraw()
        rc


    ///<summary>Add a Curve object based on a portion, or interval of an existing Curve
    ///    object. Similar in operation to Rhino's SubCrv command.</summary>
    ///<param name="curveId">(Guid) Identifier of a closed planar Curve object</param>
    ///<param name="param0">(float) First parameters on the source Curve</param>
    ///<param name="param1">(float) Second parameters on the source Curve</param>
    ///<returns>(Guid) objectId of the new Curve object.</returns>
    static member AddSubCrv(curveId:Guid, param0:float, param1:float) : Guid =
        let curve = RhinoScriptSyntax.CoerceCurve (curveId)
        let trimcurve = curve.Trim(param0, param1)
        if isNull trimcurve then RhinoScriptingException.Raise "RhinoScriptSyntax.AddSubCrv: Unable to trim curve. curveId:'%s' param0:'%A' param1:'%A'" (Nice.str curveId) param0 param1
        let rc = State.Doc.Objects.AddCurve(trimcurve)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddSubCrv: Unable to add curve to document. curveId:'%s' param0:'%A' param1:'%A'" (Nice.str curveId) param0 param1
        State.Doc.Views.Redraw()
        rc


    ///<summary>Returns the angle of an arc Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve object</param>
    ///<param name="segmentIndex">(int) Optional,
    ///    Identifies the Curve segment if CurveId identifies a poly-curve</param>
    ///<returns>(float) The angle in degrees.</returns>
    static member ArcAngle(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : float =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        let arc = ref Arc.Unset
        let rc = curve.TryGetArc( arc, RhinoMath.ZeroTolerance )
        if not <| rc then RhinoScriptingException.Raise "RhinoScriptSyntax.ArcAngle: Curve is not an arc. curveId:'%s' segmentIndex:'%A'" (Nice.str curveId) segmentIndex
        (!arc).AngleDegrees


    ///<summary>Returns the center point of an arc Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a poly-curve</param>
    ///<returns>(Point3d) The 3D center point of the arc.</returns>
    static member ArcCenterPoint(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : Point3d =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        let arc = ref Arc.Unset
        let rc = curve.TryGetArc( arc, RhinoMath.ZeroTolerance )
        if not <| rc then RhinoScriptingException.Raise "RhinoScriptSyntax.ArcCenterPoint: Curve is not an arc. curveId:'%s' segmentIndex:'%A'" (Nice.str curveId) segmentIndex
        (!arc).Center


    ///<summary>Returns the mid point of an arc Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a poly-curve</param>
    ///<returns>(Point3d) The 3D mid point of the arc.</returns>
    static member ArcMidPoint(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : Point3d =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        let arc = ref Arc.Unset
        let rc = curve.TryGetArc( arc, RhinoMath.ZeroTolerance )
        if not <| rc then RhinoScriptingException.Raise "RhinoScriptSyntax.ArcMidPoint: Curve is not an arc. curveId:'%s' segmentIndex:'%A'" (Nice.str curveId) segmentIndex
        (!arc).MidPoint


    ///<summary>Returns the radius of an arc Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a poly-curve</param>
    ///<returns>(float) The radius of the arc.</returns>
    static member ArcRadius(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : float =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        let arc = ref Arc.Unset
        let rc = curve.TryGetArc( arc, RhinoMath.ZeroTolerance )
        if not <| rc then RhinoScriptingException.Raise "RhinoScriptSyntax.ArcRadius: Curve is not an arc. curveId:'%s' segmentIndex:'%A'" (Nice.str curveId) segmentIndex
        (!arc).Radius



    ///<summary>Returns the center point of a circle Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a poly-curve</param>
    ///<returns>(Point3d) The 3D center point of the circle.</returns>
    static member CircleCenterPoint(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : Point3d =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        let circle = ref Circle.Unset
        let rc = curve.TryGetCircle(circle, RhinoMath.ZeroTolerance )
        if not <| rc then RhinoScriptingException.Raise "RhinoScriptSyntax.CircleCenterPoint: Curve is not circle. curveId:'%s' segmentIndex:'%A'" (Nice.str curveId) segmentIndex
        (!circle).Center


    ///<summary>Returns the center Plane of a circle Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a poly-curve</param>
    ///<returns>(Plane) The 3D Plane at the center point of the circle.</returns>
    static member CircleCenterPlane(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : Plane =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        let circle = ref Circle.Unset
        let rc = curve.TryGetCircle(circle, RhinoMath.ZeroTolerance )
        if not <| rc then RhinoScriptingException.Raise "RhinoScriptSyntax.CircleCenterPlane: Curve is not circle. curveId:'%s' segmentIndex:'%A'" (Nice.str curveId) segmentIndex
        (!circle).Plane





    ///<summary>Returns the circumference of a circle Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a poly-curve</param>
    ///<returns>(float) The circumference of the circle.</returns>
    static member CircleCircumference(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : float =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        let circle = ref Circle.Unset
        let rc = curve.TryGetCircle(circle, RhinoMath.ZeroTolerance )
        if not <| rc then RhinoScriptingException.Raise "RhinoScriptSyntax.CircleCircumference: Curve is not circle. curveId:'%s' segmentIndex:'%A'" (Nice.str curveId) segmentIndex
        (!circle).Circumference


    ///<summary>Returns the radius of a circle Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a poly-curve</param>
    ///<returns>(float) The radius of the circle.</returns>
    static member CircleRadius(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : float =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        let circle = ref Circle.Unset
        let rc = curve.TryGetCircle(circle, RhinoMath.ZeroTolerance )
        if not <| rc then RhinoScriptingException.Raise "RhinoScriptSyntax.CircleRadius: Curve is not circle. curveId:'%s' segmentIndex:'%A'" (Nice.str curveId) segmentIndex
        (!circle).Radius


    ///<summary>Closes an open Curve object by making adjustments to the end points so
    ///    they meet at a point.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve object</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c>
    ///    Maximum allowable distance between start and end point</param>
    ///<returns>(Guid) objectId of the new Curve object.</returns>
    static member CloseCurve(curveId:Guid, [<OPT;DEF(0.0)>]tolerance:float) : Guid =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        if curve.IsClosed then  curveId
        else
            if not <| curve.MakeClosed(Util.ifZero1 tolerance State.Doc.ModelAbsoluteTolerance) then  RhinoScriptingException.Raise "RhinoScriptSyntax.CloseCurve: Unable to add curve to document. curveId:'%s' tolerance:'%A'" (Nice.str curveId) tolerance
            let rc = State.Doc.Objects.AddCurve(curve)
            if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.CloseCurve: Unable to add curve to document. curveId:'%s' tolerance:'%A'" (Nice.str curveId) tolerance
            State.Doc.Views.Redraw()
            rc


    ///<summary>Determine the orientation (counter-clockwise or clockwise) of a closed,
    ///    planar Curve.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve object</param>
    ///<param name="direction">(Vector3d) Optional, default value: <c>Vector3d.ZAxis</c>
    ///    3d vector that identifies up, or Z axs, direction of
    ///    the Plane to test against</param>
    ///<returns>(int) 1 if the Curve's orientation is clockwise
    ///    -1 if the Curve's orientation is counter-clockwise
    ///     0 if unable to compute the Curve's orientation.</returns>
    static member ClosedCurveOrientation(curveId:Guid, [<OPT;DEF(Vector3d())>]direction:Vector3d) : int = //TODO make overload instead,[<OPT;DEF(Point3d())>] may leak  see draw vector and transform point!
        let direction0 =if direction.IsZero then Vector3d.Unset else direction
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        if not <| curve.IsClosed then  0
        else
            let orientation = curve.ClosedCurveOrientation(direction0)
            int(orientation)


    ///<summary>Convert Curve to a Polyline Curve.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve object</param>
    ///<param name="angleTolerance">(float) Optional, default value: <c>5.0</c>
    ///    The maximum angle between Curve tangents at line endpoints.</param>
    ///<param name="tolerance">(float) Optional, default value: <c>0.01</c>
    ///    The distance tolerance at segment midpoints.</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>false</c>
    ///    Delete the Curve object specified by CurveId. If omitted, CurveId will not be deleted</param>
    ///<param name="minEdgeLength">(float) Optional, Minimum segment length</param>
    ///<param name="maxEdgeLength">(float) Optional, Maximum segment length</param>
    ///<returns>(Guid) The new Curve.</returns>
    static member ConvertCurveToPolyline(   curveId:Guid,
                                            [<OPT;DEF(0.0)>]angleTolerance:float,
                                            [<OPT;DEF(0.0)>]tolerance:float,
                                            [<OPT;DEF(false)>]deleteInput:bool,
                                            [<OPT;DEF(0.0)>]minEdgeLength:float,
                                            [<OPT;DEF(0.0)>]maxEdgeLength:float) : Guid =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let angleTolerance0 = toRadians (Util.ifZero1 angleTolerance 0.5 )
        let tolerance0 = Util.ifZero1 tolerance 0.01
        let polylineCurve = curve.ToPolyline( 0, 0, angleTolerance0, 0.0, 0.0, tolerance0, minEdgeLength, maxEdgeLength, keepStartPoint=true) //TODO what happens on 0.0 input ?
        if isNull polylineCurve then RhinoScriptingException.Raise "RhinoScriptSyntax.ConvertCurveToPolyline: Unable to convertCurveToPolyline %A , maxEdgeLength%f, minEdgeLength:%f, deleteInput%b, tolerance%f, angleTolerance %f " curveId   maxEdgeLength minEdgeLength deleteInput tolerance angleTolerance
        if deleteInput then
            if State.Doc.Objects.Replace( curveId, polylineCurve) then
                curveId
            else
                RhinoScriptingException.Raise "RhinoScriptSyntax.ConvertCurveToPolyline: Unable to convertCurveToPolyline %A , maxEdgeLength%f, minEdgeLength:%f, deleteInput%b, tolerance%f, angleTolerance %f " curveId   maxEdgeLength minEdgeLength deleteInput tolerance angleTolerance
        else
            let objectId = State.Doc.Objects.AddCurve( polylineCurve )
            if System.Guid.Empty= objectId then
                RhinoScriptingException.Raise "RhinoScriptSyntax.ConvertCurveToPolyline: Unable to convertCurveToPolyline %A , maxEdgeLength%f, minEdgeLength:%f, deleteInput%b, tolerance%f, angleTolerance %f " curveId   maxEdgeLength minEdgeLength deleteInput tolerance angleTolerance
            else
                objectId


    ///<summary>Returns the point on the Curve that is a specified arc length
    ///    from the start of the Curve.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve object</param>
    ///<param name="length">(float) The arc length from the start of the Curve to evaluate</param>
    ///<param name="fromStart">(bool) Optional, default value: <c>true</c>
    ///    If not specified or True, then the arc length point is
    ///    calculated from the start of the Curve. If False, the arc length
    ///    point is calculated from the end of the Curve</param>
    ///<returns>(Point3d) on Curve.</returns>
    static member CurveArcLengthPoint(curveId:Guid, length:float, [<OPT;DEF(true)>]fromStart:bool) : Point3d =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let curveLength = curve.GetLength()
        if curveLength >= length then
            let mutable s = 0.0
            if length = 0.0 then  s <- 0.0
            elif abs(length-curveLength) < State.Doc.ModelAbsoluteTolerance then  s <- 1.0
            else s <- length / curveLength
            let dupe = if not fromStart then curve.Duplicate() :?> Curve else curve
            if notNull dupe then
                if not fromStart then  dupe.Reverse() |> ignore
                let rc, t = dupe.NormalizedLengthParameter(s)
                if rc then
                    let pt = dupe.PointAt(t)
                    if not fromStart then dupe.Dispose()
                    pt
                else RhinoScriptingException.Raise "RhinoScriptSyntax.CurveArcLengthPoint: Unable to curveArcLengthPoint %A, length:%f, fromStart:%b" curveId length fromStart
            else RhinoScriptingException.Raise "RhinoScriptSyntax.CurveArcLengthPoint: Unable to curveArcLengthPoint %A, length:%f, fromStart:%b" curveId length fromStart
        else RhinoScriptingException.Raise "RhinoScriptSyntax.CurveArcLengthPoint: Unable to curveArcLengthPoint %A, length:%f, fromStart:%b" curveId length fromStart


    ///<summary>Returns area of closed planar Curves. The results are based on the
    ///    current drawing units.</summary>
    ///<param name="curveId">(Guid) The identifier of a closed, planar Curve object</param>
    ///<returns>(float) The area.</returns>
    static member CurveArea(curveId:Guid) : float =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let tol = State.Doc.ModelAbsoluteTolerance
        let mp = AreaMassProperties.Compute(curve, tol)
        if isNull mp  then RhinoScriptingException.Raise "RhinoScriptSyntax.CurveArea failed on %A" curveId
        mp.Area


    ///<summary>Returns area centroid of closed, planar Curves. The results are based
    ///    on the current drawing units.</summary>
    ///<param name="curveId">(Guid) The identifier of a closed, planar Curve object</param>
    ///<returns>(Point3d ) The 3d centroid point.</returns>
    static member CurveAreaCentroid(curveId:Guid) : Point3d =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let tol = State.Doc.ModelAbsoluteTolerance
        let mp = AreaMassProperties.Compute(curve, tol)
        if isNull mp  then RhinoScriptingException.Raise "RhinoScriptSyntax.CurveAreaCentroid failed on %A" curveId
        mp.Centroid


    ///<summary>Get status of a Curve object's annotation arrows.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve</param>
    ///<returns>(int) The current annotation arrow style
    ///    0 = no arrows
    ///    1 = display arrow at start of Curve
    ///    2 = display arrow at end of Curve
    ///    3 = display arrow at both start and end of Curve.</returns>
    static member CurveArrows(curveId:Guid) : int = //GET
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(curveId)
        let attr = rhobj.Attributes
        let rc = attr.ObjectDecoration
        if   rc = DocObjects.ObjectDecoration.None then  0
        elif rc = DocObjects.ObjectDecoration.StartArrowhead then 1
        elif rc = DocObjects.ObjectDecoration.EndArrowhead then 2
        elif rc = DocObjects.ObjectDecoration.BothArrowhead then 3
        else RhinoScriptingException.Raise "RhinoScriptSyntax.CurveArrows: illegal state %A on curve %A" rc curveId

    ///<summary>Enables or disables a Curve object's annotation arrows.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve</param>
    ///<param name="arrowStyle">(int) The style of annotation arrow to be displayed.
    ///    0 = no arrows
    ///    1 = display arrow at start of Curve
    ///    2 = display arrow at end of Curve
    ///    3 = display arrow at both start and end of Curve</param>
    ///<returns>(unit) void, nothing.</returns>
    static member CurveArrows(curveId:Guid, arrowStyle:int) : unit = //SET
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(curveId)
        let attr = rhobj.Attributes
        //let rc = attr.ObjectDecoration
        if arrowStyle >= 0 && arrowStyle <= 3 then
            if arrowStyle = 0 then
                attr.ObjectDecoration <- DocObjects.ObjectDecoration.None
            elif arrowStyle = 1 then
                attr.ObjectDecoration <- DocObjects.ObjectDecoration.StartArrowhead
            elif arrowStyle = 2 then
                attr.ObjectDecoration <- DocObjects.ObjectDecoration.EndArrowhead
            elif arrowStyle = 3 then
                attr.ObjectDecoration <- DocObjects.ObjectDecoration.BothArrowhead
            if not <| State.Doc.Objects.ModifyAttributes(curveId, attr, quiet=true) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.CurveArrows ModifyAttributes failed on style %d on %s" arrowStyle  (Nice.str curveId)
            State.Doc.Views.Redraw()
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.CurveArrows style %d is invalid" arrowStyle

    ///<summary>Enables or disables multiple Curve objects's annotation arrows.</summary>
    ///<param name="curveIds">(Guid seq) Identifier of multiple Curve</param>
    ///<param name="arrowStyle">(int) The style of annotation arrow to be displayed.
    ///    0 = no arrows
    ///    1 = display arrow at start of Curve
    ///    2 = display arrow at end of Curve
    ///    3 = display arrow at both start and end of Curve</param>
    ///<returns>(unit) void, nothing.</returns>
    static member CurveArrows(curveIds:Guid seq, arrowStyle:int) : unit = //MULTISET
        for curveId in curveIds do
            let rhobj = RhinoScriptSyntax.CoerceRhinoObject(curveId)
            let attr = rhobj.Attributes
            //let rc = attr.ObjectDecoration
            if arrowStyle >= 0 && arrowStyle <= 3 then
                if arrowStyle = 0 then
                    attr.ObjectDecoration <- DocObjects.ObjectDecoration.None
                elif arrowStyle = 1 then
                    attr.ObjectDecoration <- DocObjects.ObjectDecoration.StartArrowhead
                elif arrowStyle = 2 then
                    attr.ObjectDecoration <- DocObjects.ObjectDecoration.EndArrowhead
                elif arrowStyle = 3 then
                    attr.ObjectDecoration <- DocObjects.ObjectDecoration.BothArrowhead
                if not <| State.Doc.Objects.ModifyAttributes(curveId, attr, quiet=true) then
                    RhinoScriptingException.Raise "RhinoScriptSyntax.CurveArrows ModifyAttributes failed on style %d on %s" arrowStyle  (Nice.str curveId)
            else
                RhinoScriptingException.Raise "RhinoScriptSyntax.CurveArrows: Curve Arrow style %d is invalid" arrowStyle
        State.Doc.Views.Redraw()

    ///<summary>Calculates the difference between two closed, planar Curves and
    ///    adds the results to the document. Note, Curves must be coplanar.</summary>
    ///<param name="curveA">(Guid) Identifier of the first Curve object</param>
    ///<param name="curveB">(Guid) Identifier of the second Curve object</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c>
    ///    A positive tolerance value, or None for the doc default</param>
    ///<returns>(Guid ResizeArray) The identifiers of the new objects.</returns>
    static member CurveBooleanDifference(curveA:Guid, curveB:Guid, [<OPT;DEF(0.0)>]tolerance:float) : Guid ResizeArray =
        let curve0 = RhinoScriptSyntax.CoerceCurve curveA
        let curve1 = RhinoScriptSyntax.CoerceCurve curveB
        let tolerance = Util.ifZero2 State.Doc.ModelAbsoluteTolerance tolerance
        let outCurves = Curve.CreateBooleanDifference(curve0, curve1, tolerance)
        let curves = ResizeArray()
        if notNull outCurves then
            for curve in outCurves do
                if notNull curve && curve.IsValid then
                    let rc = State.Doc.Objects.AddCurve(curve)
                    curve.Dispose()
                    if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.CurveBooleanDifference: Unable to add curve to document.  curveA:'%A' curveB:'%A'" curveA curveB
                    curves.Add(rc)
            State.Doc.Views.Redraw()
            curves
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.CurveBooleanDifference: Unable to add curve to document.  curveA:'%A' curveB:'%A'" curveA curveB


    ///<summary>Calculates the intersection of two closed, planar Curves and adds
    ///    the results to the document. Note, Curves must be coplanar.</summary>
    ///<param name="curveA">(Guid) Identifier of the first Curve object</param>
    ///<param name="curveB">(Guid) Identifier of the second Curve object</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c>
    ///    A positive tolerance value, or None for the doc default</param>
    ///<returns>(Guid ResizeArray) The identifiers of the new objects.</returns>
    static member CurveBooleanIntersection(curveA:Guid, curveB:Guid, [<OPT;DEF(0.0)>]tolerance:float) : Guid ResizeArray =
        let curve0 = RhinoScriptSyntax.CoerceCurve curveA
        let curve1 = RhinoScriptSyntax.CoerceCurve curveB
        let tolerance = Util.ifZero2 State.Doc.ModelAbsoluteTolerance tolerance
        let outCurves = Curve.CreateBooleanIntersection(curve0, curve1, tolerance)
        let curves = ResizeArray()
        if notNull outCurves then
            for curve in outCurves do
                if notNull curve && curve.IsValid then
                    let rc = State.Doc.Objects.AddCurve(curve)
                    curve.Dispose()
                    if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.CurveBooleanIntersection: Unable to add curve to document.  curveA:'%A' curveB:'%A'" curveA curveB
                    curves.Add(rc)
            State.Doc.Views.Redraw()
            curves
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.CurveBooleanIntersection: Unable to add curve to document.  curveA:'%A' curveB:'%A'" curveA curveB


    ///<summary>Calculate the union of two or more closed, planar Curves and
    ///    add the results to the document. Note, Curves must be coplanar.</summary>
    ///<param name="curveIds">(Guid seq) List of two or more close planar Curves identifiers</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c>
    ///    A positive tolerance value, or None for the doc default</param>
    ///<returns>(Guid ResizeArray) The identifiers of the new objects.</returns>
    static member CurveBooleanUnion(curveIds:Guid seq, [<OPT;DEF(0.0)>]tolerance:float) : Guid ResizeArray =
        let inCurves = ResizeArray()
        for objectId in curveIds do
            let curve = RhinoScriptSyntax.CoerceCurve objectId
            inCurves.Add(curve)

        if inCurves.Count < 2 then RhinoScriptingException.Raise "RhinoScriptSyntax.CurveBooleanUnion:curveIds must have at least 2 curves %A" curveIds
        let tolerance = Util.ifZero2 State.Doc.ModelAbsoluteTolerance tolerance
        let outCurves = Curve.CreateBooleanUnion(inCurves, tolerance)
        let curves = ResizeArray()
        if notNull outCurves then
            for curve in outCurves do
                if notNull curve && curve.IsValid then
                    let rc = State.Doc.Objects.AddCurve(curve)
                    curve.Dispose()
                    if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.CurveBooleanUnion: Unable to add curve to document.  curveIds:'%s'" (Nice.str curveIds)
                    curves.Add(rc)
            State.Doc.Views.Redraw()
        curves


    ///<summary>Intersects a Curve object with a brep object. Note, unlike the
    ///    CurveSurfaceIntersection function, this function works on trimmed Surfaces.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve object</param>
    ///<param name="brepId">(Guid) Identifier of a brep object</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c>
    ///    Distance tolerance at segment midpoints.</param>
    ///<returns>(Point3d ResizeArray * Curve ResizeArray) List of points and List of Curves.</returns>
    static member CurveBrepIntersect(curveId:Guid, brepId:Guid, [<OPT;DEF(0.0)>]tolerance:float) : Point3d ResizeArray * Curve ResizeArray=
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let brep = RhinoScriptSyntax.CoerceBrep(brepId)
        let tolerance0 = Util.ifZero2 State.Doc.ModelAbsoluteTolerance tolerance
        let rc, outCurves, outPoints = Intersect.Intersection.CurveBrep(curve, brep, tolerance0)
        if not <| rc then  RhinoScriptingException.Raise "RhinoScriptSyntax.CurveBrepIntersect: Intersection failed. curveId:'%s' brepId:'%s' tolerance:'%A'" (Nice.str curveId) (Nice.str brepId) tolerance

        let curves = ResizeArray(0)
        let points = ResizeArray(0)
        for curve in outCurves do
            if notNull curve && curve.IsValid then
                curves.Add(curve)
                //let rc = State.Doc.Objects.AddCurve(curve)
                //curve.Dispose()
                //if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.CurveBrepIntersect: Unable to add curve to document. curveId:'%s' brepId:'%s' tolerance:'%A'" (Nice.str curveId) brepId tolerance
                //curves.Add(rc)
        for point in outPoints do
            if point.IsValid then
                points.Add(point)
                //let rc = State.Doc.Objects.AddPoint(point)
                //points.Add(rc)
        //State.Doc.Views.Redraw()
        points, curves //TODO or  Guid as originally done ??


    ///<summary>Returns the 3D point locations on two objects where they are closest to
    ///    each other. Note, this function provides similar functionality to that of
    ///    Rhino's ClosestPt command.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object to test</param>
    ///<param name="objectIds">(Guid seq) List of identifiers of point cloud, Curve, Surface, or
    ///    Polysurface to test against</param>
    ///<returns>(Guid * Point3d * Point3d) containing the results of the closest point calculation.
    ///    The elements are as follows:
    ///      [0]    The identifier of the closest object.
    ///      [1]    The 3-D point that is closest to the closest object.
    ///      [2]    The 3-D point that is closest to the test Curve.</returns>
    static member CurveClosestObject(curveId:Guid, objectIds:Guid seq) : Guid * Point3d * Point3d =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let geometry = ResizeArray()
        for curveId in objectIds do
            let rhobj = RhinoScriptSyntax.CoerceRhinoObject(curveId)
            geometry.Add( rhobj.Geometry )
        if Seq.isEmpty geometry then RhinoScriptingException.Raise "RhinoScriptSyntax.CurveClosestObject: objectIds must contain at least one item. curveId:'%s' objectIds:'%s'" (Nice.str curveId) (Nice.str objectIds)
        let curvePoint = ref Point3d.Unset
        let geomPoint  = ref Point3d.Unset
        let whichGeom = ref 0
        let success = curve.ClosestPoints(geometry, curvePoint, geomPoint, whichGeom)
        if success then  objectIds|> Seq.item !whichGeom, !geomPoint, !curvePoint
        else RhinoScriptingException.Raise "RhinoScriptSyntax.CurveClosestObject failed  curveId:'%s' objectIds:'%A'" (Nice.str curveId) objectIds

    ///<summary>Returns the 3D point locations on the Curve and finite line where they are closest to
    ///    each other. Note, this function provides similar functionality to that of
    ///    Rhino's ClosestPt command.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object to test</param>
    ///<param name="line">(Line) a Line Geometry</param>
    ///<returns>(Point3d * Point3d) first point on Curve, second point on Line.</returns>
    static member CurveLineClosestPoint(curveId:Guid, line:Line) : Point3d * Point3d =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let curvePoint = ref Point3d.Unset
        let linePoint  = ref Point3d.Unset
        let success = curve.ClosestPoints(line.ToNurbsCurve(), curvePoint, linePoint)
        if success then  !linePoint, !curvePoint
        else RhinoScriptingException.Raise "RhinoScriptSyntax.CurveLineClosestPoint failed  curveId:'%s' Line:'%A'" (Nice.str curveId) line


    ///<summary>Returns parameter of the point on a Curve that is closest to a test point.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve object</param>
    ///<param name="point">(Point3d) Sampling point</param>
    ///<param name="segmentIndex">(int) Optional,
    ///    Curve segment index if `curveId` identifies a Polycurve</param>
    ///<returns>(float) The parameter of the closest point on the Curve.</returns>
    static member CurveClosestParameter(curveId:Guid, point:Point3d, [<OPT;DEF(-1)>]segmentIndex:int) : float =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        let t = ref 0.
        let rc = curve.ClosestPoint(point, t)
        if not <| rc then RhinoScriptingException.Raise "RhinoScriptSyntax.CurveClosestParameter failed. curveId:'%s' segmentIndex:'%d'" (Nice.str curveId) segmentIndex
        !t

    ///<summary>Returns parameter of the point on a Curve that is closest to a test point.</summary>
    ///<param name="curve">(Geometry.Curve) A Curve geometry object</param>
    ///<param name="point">(Point3d) Sampling point</param>
    ///<returns>(float) The parameter of the closest point on the Curve.</returns>
    static member CurveClosestParameter(curve:Curve, point:Point3d) : float =
        let t = ref 0.
        let rc = curve.ClosestPoint(point, t)
        if not <| rc then RhinoScriptingException.Raise "RhinoScriptSyntax.CurveClosestParameter failed on Curve Geometry"
        !t


    ///<summary>Returns the point on a Curve that is closest to a test point.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve object</param>
    ///<param name="point">(Point3d) Sampling point</param>
    ///<param name="segmentIndex">(int) Optional,
    ///    Curve segment index if `curveId` identifies a Polycurve</param>
    ///<returns>(Point3d) The closest point on the Curve.</returns>
    static member CurveClosestPoint(curveId:Guid, point:Point3d, [<OPT;DEF(-1)>]segmentIndex:int) : Point3d =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        let rc, t = curve.ClosestPoint(point)
        if not <| rc then RhinoScriptingException.Raise "RhinoScriptSyntax.CurveClosestPoint failed. curveId:'%s' segmentIndex:'%d'" (Nice.str curveId) segmentIndex
        curve.PointAt(t)

    ///<summary>Returns the point on a Curve that is closest to a test point.</summary>
    ///<param name="curve">(Geometry.Curve) A Curve geometry object</param>
    ///<param name="point">(Point3d) Sampling point</param>
    ///<returns>(Point3d) The closest point on the Curve.</returns>
    static member CurveClosestPoint(curve:Curve, point:Point3d) : Point3d =
        let rc, t = curve.ClosestPoint(point)
        if not <| rc then RhinoScriptingException.Raise "RhinoScriptSyntax.CurveClosestPoint failed on Curve Geometry"
        curve.PointAt(t)


    ///<summary>Returns the 3D point locations calculated by contouring a Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve object</param>
    ///<param name="startPoint">(Point3d) 3D starting point of a center line</param>
    ///<param name="endPoint">(Point3d) 3D ending point of a center line</param>
    ///<param name="interval">(float) The distance between contour Curves</param>
    ///<returns>(Point3d array) A list of 3D points, one for each contour.</returns>
    static member CurveContourPoints(curveId:Guid, startPoint:Point3d, endPoint:Point3d, interval:float) : array<Point3d> =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        if startPoint.DistanceTo(endPoint)<RhinoMath.ZeroTolerance then
            RhinoScriptingException.Raise "RhinoScriptSyntax.CurveContourPoints: Start && ende point are too close to define a line. curveId:'%s' startPoint:'%A' endPoint:'%A'" (Nice.str curveId) startPoint endPoint
        curve.DivideAsContour( startPoint, endPoint, interval)


    ///<summary>Returns the curvature of a Curve at a parameter. See the Rhino help for
    ///    details on Curve curvature.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve</param>
    ///<param name="parameter">(float) Parameter to evaluate</param>
    ///<returns>(Point3d * Vector3d * Point3d * float * Vector3d) of curvature information
    ///    [0] = point at specified parameter
    ///    [1] = tangent vector
    ///    [2] = center of radius of curvature
    ///    [3] = radius of curvature
    ///    [4] = curvature vector.</returns>
    static member CurveCurvature(curveId:Guid, parameter:float) : Point3d * Vector3d * Point3d * float * Vector3d =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let point = curve.PointAt(parameter)
        let tangent = curve.TangentAt(parameter)
        if tangent.IsTiny(1e-10) then  RhinoScriptingException.Raise "RhinoScriptSyntax.CurveCurvature: failed on tangent that is too small %A" curveId
        let cv = curve.CurvatureAt(parameter)
        let k = cv.Length
        if k<RhinoMath.SqrtEpsilon then  RhinoScriptingException.Raise "RhinoScriptSyntax.CurveCurvature: failed on tangent that is too small %A" curveId
        let rv = cv / (k*k)
        let circle = Circle(point, tangent, point + 2.0*rv)
        let center = point + rv
        let radius = circle.Radius
        point, tangent, center, radius, cv


    ///<summary>Calculates intersection of two Curve objects.</summary>
    ///<param name="curveA">(Guid) Identifier of the first Curve object</param>
    ///<param name="curveB">(Guid) Optional, Identifier of the second Curve object. If omitted, then a
    ///    self-intersection test will be performed on CurveA</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c>
    ///    Absolute tolerance in drawing units. If omitted,
    ///    the document's current absolute tolerance is used</param>
    ///<returns>( a ResizeArray of int*Point3d*Point3d*Point3d*Point3d*float*float*float*float)
    ///    List of tuples: containing intersection information .
    ///    The list will contain one or more of the following elements:
    ///      Element Type     Description
    ///      [n][0]  Number   The intersection event type, either Point (1) or Overlap (2).
    ///      [n][1]  Point3d  If the event type is Point (1), then the intersection point
    ///        on the first Curve. If the event type is Overlap (2), then
    ///        intersection start point on the first Curve.
    ///      [n][2]  Point3d  If the event type is Point (1), then the intersection point
    ///        on the first Curve. If the event type is Overlap (2), then
    ///        intersection end point on the first Curve.
    ///      [n][3]  Point3d  If the event type is Point (1), then the intersection point
    ///        on the second Curve. If the event type is Overlap (2), then
    ///        intersection start point on the second Curve.
    ///      [n][4]  Point3d  If the event type is Point (1), then the intersection point
    ///        on the second Curve. If the event type is Overlap (2), then
    ///        intersection end point on the second Curve.
    ///      [n][5]  Number   If the event type is Point (1), then the first Curve parameter.
    ///        If the event type is Overlap (2), then the start value of the
    ///        first Curve parameter range.
    ///      [n][6]  Number   If the event type is Point (1), then the first Curve parameter.
    ///        If the event type is Overlap (2), then the end value of the
    ///        first Curve parameter range.
    ///      [n][7]  Number   If the event type is Point (1), then the second Curve parameter.
    ///        If the event type is Overlap (2), then the start value of the
    ///        second Curve parameter range.
    ///      [n][8]  Number   If the event type is Point (1), then the second Curve parameter.
    ///        If the event type is Overlap (2), then the end value of the
    ///        second Curve parameter range.</returns>
    static member CurveCurveIntersection(curveA:Guid, [<OPT;DEF(Guid())>]curveB:Guid, [<OPT;DEF(0.0)>]tolerance:float) : (int*Point3d*Point3d*Point3d*Point3d*float*float*float*float) ResizeArray =
        let curve1 = RhinoScriptSyntax.CoerceCurve curveA
        let curve2 = if curveB= Guid.Empty then curve1 else RhinoScriptSyntax.CoerceCurve curveB
        let tolerance0 = Util.ifZero1 tolerance State.Doc.ModelAbsoluteTolerance
        let mutable rc = null
        if curveB<>curveA then
            rc <- Intersect.Intersection.CurveCurve(curve1, curve2, tolerance0, State.Doc.ModelAbsoluteTolerance)
        else
            rc <- Intersect.Intersection.CurveSelf(curve1, tolerance0)
        if isNull rc then RhinoScriptingException.Raise "RhinoScriptSyntax.CurveCurveIntersection failed on %A; %A tolerance %f" curveB curveA tolerance
        let events = ResizeArray()
        for i =0 to rc.Count-1 do
            let mutable eventType = 1
            if( rc.[i].IsOverlap ) then  eventType <- 2
            let oa = rc.[i].OverlapA
            let ob = rc.[i].OverlapB
            let element = (eventType, rc.[i].PointA, rc.[i].PointA2, rc.[i].PointB, rc.[i].PointB2, oa.[0], oa.[1], ob.[0], ob.[1])
            events.Add(element)
        events



    ///<summary>Returns the degree of a Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(int) The degree of the Curve.</returns>
    static member CurveDegree(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : int =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        curve.Degree


    ///<summary>Returns the minimum and maximum deviation between two Curve objects.</summary>
    ///<param name="curveA">(Guid) first Curve</param>
    ///<param name="curveB">(Guid) second Curve</param>
    ///<returns>(float * float * float * float * float * float) of deviation information
    ///    [0] = CurveA parameter at maximum overlap distance point
    ///    [1] = CurveB parameter at maximum overlap distance point
    ///    [2] = maximum overlap distance
    ///    [3] = CurveA parameter at minimum overlap distance point
    ///    [4] = CurveB parameter at minimum overlap distance point
    ///    [5] = minimum distance between Curves.</returns>
    static member CurveDeviation(curveA:Guid, curveB:Guid) : float * float * float * float * float * float =
        let curveA = RhinoScriptSyntax.CoerceCurve curveA
        let curveB = RhinoScriptSyntax.CoerceCurve curveB
        let tol = State.Doc.ModelAbsoluteTolerance
        let ok, maxa, maxb, maxd, mina, minb, mind = Curve.GetDistancesBetweenCurves(curveA, curveB, tol)
        if not ok then  RhinoScriptingException.Raise "RhinoScriptSyntax.CurveDeviation failed for %A; %A" curveB curveA
        else
            maxa, maxb, maxd, mina, minb, mind


    ///<summary>Returns the dimension of a Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve object</param>
    ///<param name="segmentIndex">(int) Optional,
    ///    The Curve segment if CurveId identifies a polycurve</param>
    ///<returns>(int) The dimension of the Curve .</returns>
    static member CurveDim(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : int =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        curve.Dimension


    ///<summary>Tests if two Curve objects are generally in the same direction or if they
    ///    would be more in the same direction if one of them were flipped. When testing
    ///    Curve directions, both Curves must be either open or closed - you cannot test
    ///    one open Curve and one closed Curve.</summary>
    ///<param name="curveA">(Guid) Identifier of first Curve object</param>
    ///<param name="curveB">(Guid) Identifier of second Curve object</param>
    ///<returns>(bool) True if the Curve directions match, otherwise False.</returns>
    static member CurveDirectionsMatch(curveA:Guid, curveB:Guid) : bool =
        let curve0 = RhinoScriptSyntax.CoerceCurve curveA
        let curve1 = RhinoScriptSyntax.CoerceCurve curveB
        Curve.DoDirectionsMatch(curve0, curve1)


    ///<summary>Search for a derivative, tangent, or curvature discontinuity in
    ///    a Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of Curve object</param>
    ///<param name="style">(int) The type of continuity to test for. The types of
    ///    continuity are as follows:
    ///    Value    Description
    ///    1        C0 - Continuous function
    ///    2        C1 - Continuous first derivative
    ///    3        C2 - Continuous first and second derivative
    ///    4        G1 - Continuous unit tangent
    ///    5        G2 - Continuous unit tangent and curvature</param>
    ///<returns>(Point3d ResizeArray) 3D points where the Curve is discontinuous.</returns>
    static member CurveDiscontinuity(curveId:Guid, style:int) : Point3d ResizeArray =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let dom = curve.Domain
        let mutable t0 = dom.Min
        let t1 = dom.Max
        let points = ResizeArray()
        let mutable getNext = true
        while getNext do
            let st : Continuity = EnumOfValue style
            let getN, t = curve.GetNextDiscontinuity(st, t0, t1)
            getNext <- getN
            if getNext then
                points.Add(curve.PointAt(t))
                t0 <- t // Advance to the next parameter
        points


    ///<summary>Returns the domain of a Curve object
    ///    as an indexable object with two elements.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(Interval) The domain of the Curve.</returns>
    static member CurveDomain(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : Interval =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        curve.Domain


    ///<summary>Returns the Edit-, or Greville-Points of a Curve object.
    ///    For each Curve control point, there is a corresponding edit point.
    /// see rs.CurveEditParameters for parameters, not points</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index is `curveId` identifies a polycurve</param>
    ///<returns>(Collections.Point3dList) Curve edit points.</returns>
    static member CurveEditPoints(curveId:Guid,[<OPT;DEF(-1)>]segmentIndex:int) : Collections.Point3dList =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        let nc = curve.ToNurbsCurve()
        if isNull nc then  RhinoScriptingException.Raise "RhinoScriptSyntax.CurveEditPoints failed for %A" curveId
        nc.GrevillePoints()


    ///<summary>Returns the Edit-, or Greville-Parameters of a Curve object.
    ///    For each Curve control point, there is a corresponding edit point parameter.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index is `curveId` identifies a polycurve</param>
    ///<returns>(Collections.Point3dList)  A list of Curve parameters</returns>
    static member CurveEditParameters(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : float[] =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        let nc = curve.ToNurbsCurve()
        if isNull nc then  RhinoScriptingException.Raise "RhinoScriptSyntax.CurveEditParameters failed for %A" curveId
        nc.GrevilleParameters()

    ///<summary>Returns the end point of a Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(Point3d) The 3d endpoint of the Curve.</returns>
    static member CurveEndPoint(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : Point3d =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        curve.PointAtEnd

    ///<summary>Returns the tangent at end point of a Curve object
    /// pointing away from the Curve .</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(Vector3d) The tangent, same as Curve.TangentAtEnd property .</returns>
    static member CurveEndTangent(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : Vector3d =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        curve.TangentAtEnd

    ///<summary>Returns the tangent at start point of a Curve object
    /// pointing in direction of  the Curve .</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(Vector3d) The tangent, same as Curve.TangentAtStart property .</returns>
    static member CurveStartTangent(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : Vector3d =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        curve.TangentAtStart

    ///<summary>Find points at which to cut a pair of Curves so that a fillet of a
    ///    specified radius fits. A fillet point is a pair of points (point0, point1)
    ///    such that there is a circle of radius tangent to Curve Curve0 at point0 and
    ///    tangent to Curve Curve1 at point1. Of all possible fillet points, this
    ///    function returns the one which is the closest to the base point basePointA,
    ///    basePointB. Distance from the base point is measured by the sum of arc
    ///    lengths along the two Curves.</summary>
    ///<param name="curveA">(Guid) Identifier of the first Curve object</param>
    ///<param name="curveB">(Guid) Identifier of the second Curve object</param>
    ///<param name="radius">(float) The fillet radius</param>
    ///<param name="basePointA">(Point3d) Optional, The base point on the first Curve.
    ///    If omitted, the starting point of the Curve is used</param>
    ///<param name="basePointB">(Point3d) Optional, The base point on the second Curve. If omitted,
    ///    the starting point of the Curve is used</param>
    ///<returns>(Point3d * Point3d * Plane)
    ///    . The list elements are as follows:
    ///      [0]    A point on the first Curve at which to cut (point).
    ///      [1]    A point on the second Curve at which to cut (point).
    ///      [2]    The fillet Plane.</returns>
    static member CurveFilletPoints(curveA:Guid,
                                    curveB:Guid,
                                    radius:float,
                                    [<OPT;DEF(Point3d())>]basePointA:Point3d,
                                    [<OPT;DEF(Point3d())>]basePointB:Point3d) : Point3d * Point3d * Plane = //TODO make overload instead, this may leak  see draw vector and transform point!
        //  [<OPT;DEF(true)>]returnPoints:bool)
        //<param name="returnPoints">(bool) Optional, default value: <c>true</c>
        //If True (Default), then fillet points are
        //  returned. Otherwise, a fillet curve is created and                       // TODO not Implemented
        //  it's identifier is returned</param>
        let curve0 = RhinoScriptSyntax.CoerceCurve curveA
        let curve1 = RhinoScriptSyntax.CoerceCurve curveB
        let basePointA = if basePointA = Point3d.Origin then Point3d.Unset else basePointA
        let basePointB = if basePointB = Point3d.Origin then Point3d.Unset else basePointB

        let inline distance  (a:Point3d)(b:Point3d) = (a-b).Length

        let t0Base =
            if basePointA <> Point3d.Unset then
                let ok, t = curve0.ClosestPoint(basePointA)
                if not ok then RhinoScriptingException.Raise "RhinoScriptSyntax.CurveFilletPoints failed 1 curveA:'%A' curveB:'%A' radius:'%A' basePointA: %A basePointB: %A" curveA curveB radius basePointA basePointB
                t
            else
                let distEnde  = min  (distance curve1.PointAtStart curve0.PointAtEnd)   (distance curve1.PointAtEnd curve0.PointAtEnd)
                let distStart = min  (distance curve1.PointAtStart curve0.PointAtStart) (distance curve1.PointAtEnd curve0.PointAtStart)
                if distStart < distEnde then curve0.Domain.Min else curve0.Domain.Max

        let t1Base =
            if basePointB <> Point3d.Unset then
                let ok, t = curve1.ClosestPoint(basePointB)
                if not ok then RhinoScriptingException.Raise "RhinoScriptSyntax.CurveFilletPoints failed 2 curveA:'%A' curveB:'%A' radius:'%A' basePointA: %A basePointB: %A" curveA curveB radius basePointA basePointB
                t
            else
                let distEnde  = min  (distance curve0.PointAtStart curve1.PointAtEnd)   (distance curve0.PointAtEnd curve1.PointAtEnd)
                let distStart = min  (distance curve0.PointAtStart curve1.PointAtStart) (distance curve0.PointAtEnd curve1.PointAtStart)
                if distStart < distEnde then curve1.Domain.Min else curve1.Domain.Max

        let ok, a, b, pl = Curve.GetFilletPoints(curve0, curve1, radius, t0Base, t1Base)
        if not ok then RhinoScriptingException.Raise "RhinoScriptSyntax.CurveFilletPoints failed 3 curveA:'%A' curveB:'%A' radius:'%A' basePointA: %A basePointB: %A" curveA curveB radius basePointA basePointB
        curve0.PointAt(a), curve0.PointAt(b), pl


    ///<summary>Returns the Plane at a parameter of a Curve. The Plane is based on the
    ///    tangent and curvature vectors at a parameter.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="parameter">(float) Parameter to evaluate</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(Plane) The Plane at the specified parameter.</returns>
    static member CurveFrame(curveId:Guid, parameter:float, [<OPT;DEF(-1)>]segmentIndex:int) : Plane =
        let mutable para = parameter
        let  curve = RhinoScriptSyntax.CoerceCurve curveId
        let  domain = curve.Domain
        if not <| domain.IncludesParameter(parameter) then
            let  tol = State.Doc.ModelAbsoluteTolerance
            if parameter>domain.Max && (para-domain.Max)<=tol then
                para <- domain.Max
            elif parameter<domain.Min && (domain.Min-para)<=tol then
                para <- domain.Min
            else
                RhinoScriptingException.Raise "RhinoScriptSyntax.CurveFrame failed. curveId:'%s' parameter:'%A' segmentIndex:'%A'" (Nice.str curveId) parameter segmentIndex
        let  rc, frame = curve.FrameAt(para)
        if rc && frame.IsValid then  frame
        else RhinoScriptingException.Raise "RhinoScriptSyntax.CurveFrame failed. curveId:'%s' parameter:'%A' segmentIndex:'%A'" (Nice.str curveId) parameter segmentIndex


    ///<summary>Returns the knot count of a Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment if `curveId` identifies a polycurve</param>
    ///<returns>(int) The number of knots.</returns>
    static member CurveKnotCount(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : int =
        let  curve = RhinoScriptSyntax.CoerceCurve (curveId, segmentIndex)
        let  nc = curve.ToNurbsCurve()
        if isNull nc then  RhinoScriptingException.Raise "RhinoScriptSyntax.CurveKnotCount failed. curveId:'%s' segmentIndex:'%A'" (Nice.str curveId) segmentIndex
        nc.Knots.Count


    ///<summary>Returns the knots, or knot vector, of a Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(float ResizeArray) knot values.</returns>
    static member CurveKnots(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : ResizeArray<float> =
        let  curve = RhinoScriptSyntax.CoerceCurve (curveId, segmentIndex)
        let  nc = curve.ToNurbsCurve()
        if isNull nc then  RhinoScriptingException.Raise "RhinoScriptSyntax.CurveKnots failed. curveId:'%s' segmentIndex:'%A'" (Nice.str curveId) segmentIndex
        let knots = ResizeArray(nc.Knots.Count)
        for i = 0 to nc.Knots.Count - 1 do
            knots.Add(nc.Knots.[i])
        knots

    ///<summary>Returns the length of a Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<param name="subDomain">(Interval) Optional, List of two numbers identifying the sub-domain of the
    ///    Curve on which the calculation will be performed. The two parameters
    ///    (sub-domain) must be non-decreasing. If omitted, the length of the
    ///    entire Curve is returned</param>
    ///<returns>(float) The length of the Curve.</returns>
    static member CurveLength(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int, [<OPT;DEF(Interval())>]subDomain:Interval) : float =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        if subDomain.T0 = 0.0 && subDomain.T1 = 0.0 then curve.GetLength()
        else curve.GetLength(subDomain)


    ///<summary>Returns the average unitized direction of a Curve object between start and end point,
    ///    Optionally allows non linear Curves too.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="allowNonLinear">(bool) Optional, allow non linear Curves, Default Value <c>False</c> </param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(Vector3d) The direction of the Curve.</returns>
    static member CurveDirection(curveId:Guid, [<OPT;DEF(false)>]allowNonLinear:bool,[<OPT;DEF(-1)>]segmentIndex:int) : Vector3d =
        let  curve = RhinoScriptSyntax.CoerceCurve (curveId, segmentIndex)
        if allowNonLinear || curve.IsLinear(RhinoMath.ZeroTolerance) then
            if curve.IsClosed || curve.IsClosable(State.Doc.ModelAbsoluteTolerance) then RhinoScriptingException.Raise "RhinoScriptSyntax.CurveDirection failed on closed or closable curve. curveId:'%s' allowNonLinear '%A' segmentIndex:'%A'" (Nice.str curveId) allowNonLinear segmentIndex
            let v = curve.PointAtEnd - curve.PointAtStart
            if v.Unitize() then v
            else
                RhinoScriptingException.Raise "RhinoScriptSyntax.CurveDirection failed. start and end are the same point. curveId:'%s' allowNonLinear '%A' segmentIndex:'%A'" (Nice.str curveId) allowNonLinear segmentIndex

        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.CurveDirection failed. curveId:'%s' allowNonLinear '%A' segmentIndex:'%A'" (Nice.str curveId) allowNonLinear segmentIndex


    ///<summary>Returns the mid point of a Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(Point3d) The 3D midpoint of the Curve.</returns>
    static member CurveMidPoint(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : Point3d =
        let  curve = RhinoScriptSyntax.CoerceCurve (curveId, segmentIndex)
        let  rc, t = curve.NormalizedLengthParameter(0.5)
        if rc then  curve.PointAt(t)
        else RhinoScriptingException.Raise "RhinoScriptSyntax.CurveMidPoint failed. curveId:'%s' segmentIndex:'%A'" (Nice.str curveId) segmentIndex


    ///<summary>Returns the normal direction of the Plane in which a planar Curve object lies.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment if CurveId identifies a polycurve</param>
    ///<returns>(Vector3d) The 3D normal vector.</returns>
    static member CurveNormal(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : Vector3d =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        let tol = State.Doc.ModelAbsoluteTolerance
        let plane = ref Plane.WorldXY
        let rc = curve.TryGetPlane(plane, tol)
        if rc then  (!plane).Normal
        else RhinoScriptingException.Raise "RhinoScriptSyntax.CurveNormal failed. curveId:'%s' segmentIndex:'%A'" (Nice.str curveId) segmentIndex


    ///<summary>Converts a Curve parameter to a normalized Curve parameter;
    ///    one that ranges between 0-1.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="parameter">(float) The Curve parameter to convert</param>
    ///<returns>(float) normalized Curve parameter.</returns>
    static member CurveNormalizedParameter(curveId:Guid, parameter:float) : float =
        let  curve = RhinoScriptSyntax.CoerceCurve curveId
        curve.Domain.NormalizedParameterAt(parameter)


    ///<summary>Converts a normalized Curve parameter to a Curve parameter;
    ///    one within the Curve's domain.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="parameter">(float) The normalized Curve parameter to convert</param>
    ///<returns>(float) Curve parameter.</returns>
    static member CurveParameter(curveId:Guid, parameter:float) : float =
        let curve = RhinoScriptSyntax.CoerceCurve curveId
        curve.Domain.ParameterAt(parameter)


    ///<summary>Returns the perpendicular Plane at a parameter of a Curve. The result
    ///    is relatively parallel (zero-twisting) Plane.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="parameter">(float) Parameter to evaluate</param>
    ///<returns>(Plane) Plane.</returns>
    static member CurvePerpFrame(curveId:Guid, parameter:float) : Plane =
        let  curve = RhinoScriptSyntax.CoerceCurve curveId
        let  rc, plane = curve.PerpendicularFrameAt(parameter)
        if rc then  plane else RhinoScriptingException.Raise "RhinoScriptSyntax.CurvePerpFrame failed. curveId:'%s' parameter:'%f'"  (Nice.str curveId) parameter


    ///<summary>Returns the Plane in which a planar Curve lies. Note, this function works
    ///    only on planar Curves.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(Plane) The Plane in which the Curve lies.</returns>
    static member CurvePlane(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : Plane =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        let tol = State.Doc.ModelAbsoluteTolerance
        let plane = ref Plane.WorldXY
        let rc = curve.TryGetPlane(plane, tol)
        if rc then  !plane
        else RhinoScriptingException.Raise "RhinoScriptSyntax.CurvePlane failed. curveId:'%s' segmentIndex:'%A'" (Nice.str curveId) segmentIndex


    ///<summary>Returns the control points count of a Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment if `curveId` identifies a polycurve</param>
    ///<returns>(int) Number of control points.</returns>
    static member CurvePointCount(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : int =
        let curve = RhinoScriptSyntax.CoerceCurve (curveId, segmentIndex)
        let mutable nc = curve.ToNurbsCurve()
        if notNull nc then  nc.Points.Count
        else RhinoScriptingException.Raise "RhinoScriptSyntax.CurvePointCount failed. curveId:'%s' segmentIndex:'%A'" (Nice.str curveId) segmentIndex

    ///<summary>Returns the control points, or control vertices, of a Curve object.
    ///    If the Curve is a rational NURBS Curve, the euclidean control vertices
    ///    are returned.</summary>
    ///<param name="curve">(Curve) The Curve Geometry</param>
    ///<returns>(Point3d ResizeArray) The control points, or control vertices, of a Curve object.</returns>
    static member CurvePoints(curve:Curve) : Point3d ResizeArray =
        match curve with
        | :? PolylineCurve as pl ->
            resizeArray { for i = 0 to pl.PointCount - 1 do pl.Point(i)}
        | :? NurbsCurve as nc ->
            resizeArray { for i = 0 to nc.Points.Count-1 do nc.Points.[i].Location }
        | _ ->
            let nc = curve.ToNurbsCurve()
            if isNull nc then  RhinoScriptingException.Raise "RhinoScriptSyntax.CurvePoints failed. curve:'%A'" curve
            resizeArray { for i = 0 to nc.Points.Count-1 do nc.Points.[i].Location }

    ///<summary>Returns the control points, or control vertices, of a Curve object.
    ///    If the Curve is a rational NURBS Curve, the euclidean control vertices
    ///    are returned.</summary>
    ///<param name="curveId">(Guid) The object's identifier</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment if `curveId` identifies a polycurve</param>
    ///<returns>(Point3d ResizeArray) The control points, or control vertices, of a Curve object.</returns>
    static member CurvePoints(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : Point3d ResizeArray =
        let  curve = RhinoScriptSyntax.CoerceCurve (curveId, segmentIndex)
        match curve with
        | :? PolylineCurve as pl ->
            resizeArray { for i = 0 to pl.PointCount - 1 do pl.Point(i)}
        | :? NurbsCurve as nc ->
            resizeArray { for i = 0 to nc.Points.Count-1 do nc.Points.[i].Location }
        | _ ->
            let nc = curve.ToNurbsCurve()
            if isNull nc then  RhinoScriptingException.Raise "RhinoScriptSyntax.CurvePoints failed. curveId:'%s' segmentIndex:'%A'" (Nice.str curveId) segmentIndex
            resizeArray { for i = 0 to nc.Points.Count-1 do nc.Points.[i].Location }


    ///<summary>Returns the radius of curvature at a point on a Curve.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="testPoint">(Point3d) Sampling point</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment if CurveId identifies a polycurve</param>
    ///<returns>(float) The radius of curvature at the point on the Curve.</returns>
    static member CurveRadius(curveId:Guid, testPoint:Point3d, [<OPT;DEF(-1)>]segmentIndex:int) : float =
        let curve = RhinoScriptSyntax.CoerceCurve (curveId, segmentIndex)
        let mutable rc, t = curve.ClosestPoint(testPoint)//, 0.0)
        if not <| rc then  RhinoScriptingException.Raise "RhinoScriptSyntax.CurveRadius failed. curveId:'%s' testPoint:'%A' segmentIndex:'%A'" (Nice.str curveId) testPoint segmentIndex
        let mutable v = curve.CurvatureAt( t )
        let mutable k = v.Length
        if k>RhinoMath.ZeroTolerance then  1.0/k
        else RhinoScriptingException.Raise "RhinoScriptSyntax.CurveRadius failed. curveId:'%s' testPoint:'%A' segmentIndex:'%A'" (Nice.str curveId) testPoint segmentIndex


    ///<summary>Adjusts the seam, or start/end, point of a closed Curve.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="parameter">(float) The parameter of the new start/end point.
    ///    Note, if successful, the resulting Curve's
    ///    domain will start at `parameter`</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member CurveSeam(curveId:Guid, parameter:float) : bool =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        if (not <| curve.IsClosed || not <| curve.Domain.IncludesParameter(parameter)) then
            false
        else
            let dupe = curve.Duplicate() :?>Curve
            if notNull dupe then
                let r = dupe.ChangeClosedCurveSeam(parameter)
                if not r then r
                else
                    State.Doc.Objects.Replace(curveId, dupe)
            else
                false


    ///<summary>Returns the start point of a Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(Point3d) The 3D starting point of the Curve.</returns>
    static member CurveStartPoint(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : Point3d =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        curve.PointAtStart

    ///<summary>Sets the start point of a Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="point">(Point3d) New start point</param>
    ///<returns>(unit).</returns>
    static member CurveStartPoint(curveId:Guid, point:Point3d) : unit =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        if not <|curve.SetStartPoint(point) then RhinoScriptingException.Raise "RhinoScriptSyntax.CurveStartPoint failed on '%A' and '%A'" point curveId
        State.Doc.Objects.Replace(curveId, curve) |> ignore
        State.Doc.Views.Redraw()



    ///<summary>Calculates intersection of a Curve object with a Surface object.
    ///    Note, this function works on the untrimmed portion of the Surface.</summary>
    ///<param name="curveId">(Guid) The identifier of the first Curve object</param>
    ///<param name="surfaceId">(Guid) The identifier of the second Curve object. If omitted,
    ///    the a self-intersection test will be performed on Curve</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c>
    ///    The absolute tolerance in drawing units.</param>
    ///<param name="angleTolerance">(float) Optional, default value: <c>State.Doc.ModelAngleToleranceRadians</c>
    ///    Angle tolerance in degrees. The angle
    ///    tolerance is used to determine when the Curve is tangent to the
    ///    Surface.</param>
    ///<returns>(ResizeArray of int*Point3d*Point3d*Point3d*Point3d*float*float*float*float) of intersection information .
    ///    The list will contain one or more of the following elements:
    ///      Element Type     Description
    ///      [n][0]  Number   The intersection event type, either Point(1) or Overlap(2).
    ///      [n][1]  Point3d  If the event type is Point(1), then the intersection point
    ///        on the first Curve. If the event type is Overlap(2), then
    ///        intersection start point on the first Curve.
    ///      [n][2]  Point3d  If the event type is Point(1), then the intersection point
    ///        on the first Curve. If the event type is Overlap(2), then
    ///        intersection end point on the first Curve.
    ///      [n][3]  Point3d  If the event type is Point(1), then the intersection point
    ///        on the second Curve. If the event type is Overlap(2), then
    ///        intersection start point on the Surface.
    ///      [n][4]  Point3d  If the event type is Point(1), then the intersection point
    ///        on the second Curve. If the event type is Overlap(2), then
    ///        intersection end point on the Surface.
    ///      [n][5]  Number   If the event type is Point(1), then the first Curve parameter.
    ///        If the event type is Overlap(2), then the start value of the
    ///        first Curve parameter range.
    ///      [n][6]  Number   If the event type is Point(1), then the first Curve parameter.
    ///        If the event type is Overlap(2), then the end value of the
    ///        Curve parameter range.
    ///      [n][7]  Number   If the event type is Point(1), then the U Surface parameter.
    ///        If the event type is Overlap(2), then the U Surface parameter
    ///        for Curve at (n, 5).
    ///      [n][8]  Number   If the event type is Point(1), then the V Surface parameter.
    ///        If the event type is Overlap(2), then the V Surface parameter
    ///        for Curve at (n, 5).
    ///      [n][9]  Number   If the event type is Point(1), then the U Surface parameter.
    ///        If the event type is Overlap(2), then the U Surface parameter
    ///        for Curve at (n, 6).
    ///      [n][10] Number   If the event type is Point(1), then the V Surface parameter.
    ///        If the event type is Overlap(2), then the V Surface parameter
    ///        for Curve at (n, 6).</returns>
    static member CurveSurfaceIntersection(curveId:Guid, surfaceId:Guid, [<OPT;DEF(0.0)>]tolerance:float, [<OPT;DEF(0.0)>]angleTolerance:float) : (int*Point3d*Point3d*Point3d*Point3d*float*float*float*float*float*float) ResizeArray =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let surface = RhinoScriptSyntax.CoerceSurface surfaceId
        let tolerance0 = Util.ifZero1 tolerance State.Doc.ModelAbsoluteTolerance
        let angleTolerance0 = Util.ifZero1 (toRadians(angleTolerance)) State.Doc.ModelAngleToleranceRadians
        let  rc = Intersect.Intersection.CurveSurface(curve, surface, tolerance0, angleTolerance0)
        if isNull rc then RhinoScriptingException.Raise "RhinoScriptSyntax.CurveSurfaceIntersection failed. (surfaceId:%A) (curveId:%A) (angleTolerance:%f) (tolerance:%f) " surfaceId curveId angleTolerance tolerance
        let events = ResizeArray()
        for i = 0 to rc.Count - 1 do
            let eventType = if rc.[i].IsOverlap then 2 else 1
            let item = rc.[i]
            let oa = item.OverlapA
            let u, v = item.SurfaceOverlapParameter()
            let e = eventType, item.PointA, item.PointA2, item.PointB, item.PointB2, oa.[0], oa.[1], u.[0], u.[1], v.[0], v.[1]
            events.Add(e)
        events

    ///<summary>Returns a 3D vector that is the tangent to a Curve at a parameter.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="parameter">(float) Parameter to evaluate</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(Vector3d) A 3D vector.</returns>
    static member CurveTangent(curveId:Guid, parameter:float, [<OPT;DEF(-1)>]segmentIndex:int) : Vector3d =
        let curve = RhinoScriptSyntax.CoerceCurve (curveId, segmentIndex)
        if curve.Domain.IncludesParameter(parameter) then
            curve.TangentAt(parameter)
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.CurveTangent failed. curveId:'%s' parameter:'%A' segmentIndex:'%A'" (Nice.str curveId) parameter segmentIndex


    ///<summary>Returns list of weights that are assigned to the control points of a Curve.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(float ResizeArray) The weight values of the Curve.</returns>
    static member CurveWeights(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) :  float ResizeArray =
        let nc =
            match RhinoScriptSyntax.CoerceCurve (curveId, segmentIndex) with
            | :? NurbsCurve as nc -> nc
            | c -> c.ToNurbsCurve()
        if isNull nc then  RhinoScriptingException.Raise "RhinoScriptSyntax.CurveWeights failed. curveId:'%s' segmentIndex:'%A'" (Nice.str curveId) segmentIndex
        resizeArray { for pt in nc.Points -> pt.Weight }

    ///<summary>Divides a Curve Geometry into a specified number of segments, including start and end point.</summary>
    ///<param name="curve">(Geometry.Curve) Curve geometry</param>
    ///<param name="segments">(int) The number of segments</param>
    ///<returns>(Point3d array) Array containing points at divisions.</returns>
    static member DivideCurveIntoPoints(curve:Curve, segments:int) : Point3d array =
        let pts = ref (Array.zeroCreate (segments + 1))
        let rc = curve.DivideByCount(segments, includeEnds=true, points=pts)
        if isNull rc then  RhinoScriptingException.Raise "RhinoScriptSyntax.DivideCurveIntoPoints failed. curve:'%A' segments:'%A'" curve segments
        !pts

    ///<summary>Divides a Curve object into a specified number of segments, including start and end point.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segments">(int) The number of segments</param>
    ///<returns>(Point3d array) Array containing points at divisions.</returns>
    static member DivideCurveIntoPoints(curveId:Guid, segments:int) : Point3d array =
        let  curve = RhinoScriptSyntax.CoerceCurve curveId
        let pts = ref (Array.zeroCreate (segments + 1))
        let rc = curve.DivideByCount(segments, includeEnds=true, points=pts)
        if isNull rc then  RhinoScriptingException.Raise "RhinoScriptSyntax.DivideCurveIntoPoints failed. curveId:'%s' segments:'%A'" (Nice.str curveId) segments
        !pts

    ///<summary>Divides a Curve Geometry into a specified number of segments.</summary>
    ///<param name="curve">(Geometry.Curve) Curve geometry</param>
    ///<param name="segments">(int) The number of segments</param>
    ///<returns>( float array ) array containing 3D division parameters.</returns>
    static member DivideCurve(curve:Curve, segments:int) :  float array =
        let rc = curve.DivideByCount(segments, includeEnds=true)
        if isNull rc then  RhinoScriptingException.Raise "RhinoScriptSyntax.DivideCurve failed. curve:'%A' segments:'%A'" curve segments
        rc

    ///<summary>Divides a Curve object into a specified number of segments.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segments">(int) The number of segments</param>
    ///<returns>( float array ) array containing 3D division parameters.</returns>
    static member DivideCurve(curveId:Guid, segments:int) :  float array =
        let  curve = RhinoScriptSyntax.CoerceCurve curveId
        let rc = curve.DivideByCount(segments, includeEnds=true)
        if isNull rc then  RhinoScriptingException.Raise "RhinoScriptSyntax.DivideCurve failed. curveId:'%s' segments:'%A'" (Nice.str curveId) segments
        rc


    ///<summary>Divides a Curve Geometry such that the linear distance between the points is equal.</summary>
    ///<param name="curve">(Geometry.Curve) Curve geometry</param>
    ///<param name="distance">(float) Linear distance between division points</param>
    ///<returns>(Point3d array) array containing 3D division points.</returns>
    static member DivideCurveEquidistant(curve:Curve, distance:float) : array<Point3d> =
        let  points = curve.DivideEquidistant(distance)
        if isNull points then
            let len = curve.GetLength()
            if len < distance then
                RhinoScriptingException.Raise "RhinoScriptSyntax.DivideCurveEquidistant failed on too short curve. curve:'%A' distance:%f, curveLength=%f" curve distance len
            else
                RhinoScriptingException.Raise "RhinoScriptSyntax.DivideCurveEquidistant failed. curve:'%A' distance:%f, curveLength=%f" curve distance len
        points


    ///<summary>Divides a Curve object such that the linear distance between the points is equal.</summary>
    ///<param name="curveId">(Guid) The object's identifier</param>
    ///<param name="distance">(float) Linear distance between division points</param>
    ///<returns>(Point3d array) array containing 3D division points.</returns>
    static member DivideCurveEquidistant(curveId:Guid, distance:float) : array<Point3d> =
        let  curve = RhinoScriptSyntax.CoerceCurve curveId
        let  points = curve.DivideEquidistant(distance)
        if isNull points then
            let len = curve.GetLength()
            if len < distance then
                RhinoScriptingException.Raise "RhinoScriptSyntax.DivideCurveEquidistant failed on too short curve. curveId:'%s' distance:%f, curveLength=%f" (Nice.str curveId) distance len
            else
                RhinoScriptingException.Raise "RhinoScriptSyntax.DivideCurveEquidistant failed. curveId:'%s' distance:%f, curveLength=%f" (Nice.str curveId) distance len
        points


    ///<summary>Divides a Curve Geometry into segments of a specified length.
    /// If length is more than Curve length it fails.</summary>
    ///<param name="curve">(Geometry.Curve) Curve geometry</param>
    ///<param name="length">(float) The length of each segment</param>
    ///<returns>(Point3d ResizeArray) a list containing division points.</returns>
    static member DivideCurveLengthIntoPoints(curve:Curve, length:float) : Point3d ResizeArray =
        let rc = curve.DivideByLength(length, includeEnds=true)
        if isNull rc then
            let len = curve.GetLength()
            if len < length then
                RhinoScriptingException.Raise "RhinoScriptSyntax.DivideCurveLengthIntoPoints failed on too short curve. curve:'%A' dived-length:%f, curveLength=%f" curve length len
            else
                RhinoScriptingException.Raise "RhinoScriptSyntax.DivideCurveLengthIntoPoints failed. curve:'%A' dived-length:%f, curveLength=%f" curve length len
        resizeArray { for r in rc do curve.PointAt(r)}

    ///<summary>Divides a Curve object into segments of a specified length.
    /// If length is more than Curve length it fails.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="length">(float) The length of each segment</param>
    ///<returns>(Point3d ResizeArray) a list containing division points.</returns>
    static member DivideCurveLengthIntoPoints(curveId:Guid, length:float) : Point3d ResizeArray =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let rc = curve.DivideByLength(length, includeEnds=true)
        if isNull rc then
            let len = curve.GetLength()
            if len < length then
                RhinoScriptingException.Raise "RhinoScriptSyntax.DivideCurveLengthIntoPoints failed on too short curve. curveId:'%s' dived-length:%f, curveLength=%f" (Nice.str curveId) length len
            else
                RhinoScriptingException.Raise "RhinoScriptSyntax.DivideCurveLengthIntoPoints failed. curveId:'%s' dived-length:%f, curveLength=%f" (Nice.str curveId) length len
        resizeArray { for r in rc do curve.PointAt(r)}

    ///<summary>Divides a Curve Geometry into segments of a specified length.
    /// If length is more than Curve length it fails.</summary>
    ///<param name="curve">(Geometry.Curve) Curve geometry</param>
    ///<param name="length">(float) The length of each segment</param>
    ///<returns>( float array) a list containing division parameters.</returns>
    static member DivideCurveLength(curve:Curve, length:float) :  float [] =
        let rc = curve.DivideByLength(length, includeEnds=true)
        if isNull rc then
            let len = curve.GetLength()
            if len < length then
                RhinoScriptingException.Raise "RhinoScriptSyntax.DivideCurveLength failed on too short curve. curve:'%A' dived-length:%f, curveLength=%f" curve length len
            else
                RhinoScriptingException.Raise "RhinoScriptSyntax.DivideCurveLength failed. curve:'%A' dived-length:%f, curveLength=%f" curve length len
        rc

    ///<summary>Divides a Curve object into segments of a specified length.
    /// If length is more than Curve length it fails.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="length">(float) The length of each segment</param>
    ///<returns>( float array) a list containing division parameters.</returns>
    static member DivideCurveLength(curveId:Guid, length:float) :  float [] =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let rc = curve.DivideByLength(length, includeEnds=true)
        if isNull rc then
            let len = curve.GetLength()
            if len < length then
                RhinoScriptingException.Raise "RhinoScriptSyntax.DivideCurveLength failed on too short curve. curveId:'%s' dived-length:%f, curveLength=%f" (Nice.str curveId) length len
            else
                RhinoScriptingException.Raise "RhinoScriptSyntax.DivideCurveLength failed. curveId:'%s' dived-length:%f, curveLength=%f" (Nice.str curveId) length len
        rc


    ///<summary>Returns the center point of an elliptical-shaped Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<returns>(Point3d) The 3D center point of the ellipse.</returns>
    static member EllipseCenterPoint(curveId:Guid) : Point3d =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let rc, ellipse = curve.TryGetEllipse()
        if not <| rc then  RhinoScriptingException.Raise "RhinoScriptSyntax.EllipseCenterPoint: Curve is not an ellipse. curveId:'%s'" (Nice.str curveId)
        ellipse.Plane.Origin


    ///<summary>Returns the quadrant points of an elliptical-shaped Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<returns>(Point3d * Point3d * Point3d * Point3d) Four points identifying the quadrants of the ellipse.</returns>
    static member EllipseQuadPoints(curveId:Guid) : Point3d * Point3d * Point3d * Point3d =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let rc, ellipse = curve.TryGetEllipse()
        if not <| rc then  RhinoScriptingException.Raise "RhinoScriptSyntax.EllipseQuadPoints: Curve is not an ellipse. curveId:'%s'" (Nice.str curveId)
        let origin = ellipse.Plane.Origin;
        let xAxis = ellipse.Radius1 * ellipse.Plane.XAxis;
        let yAxis = ellipse.Radius2 * ellipse.Plane.YAxis;
        (origin-xAxis, origin + xAxis, origin-yAxis, origin + yAxis)


    ///<summary>Evaluates a Curve at a parameter and returns a 3D point.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="t">(float) The parameter to evaluate</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(Point3d) a 3-D point.</returns>
    static member EvaluateCurve(curveId:Guid, t:float, [<OPT;DEF(-1)>]segmentIndex:int) : Point3d =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        curve.PointAt(t)


    ///<summary>Explodes, or un-joins, one Curve. PolyCurves will be exploded into Curve
    ///    segments. Polylines will be exploded into line segments. ExplodeCurves will
    ///    return the Curves in topological order.</summary>
    ///<param name="curveId">(Guid) The Curve object to explode</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>false</c>
    ///    Delete input objects after exploding if True</param>
    ///<returns>(Guid ResizeArray) identifying the newly created Curve objects.</returns>
    static member ExplodeCurve(curveId:Guid, [<OPT;DEF(false)>]deleteInput:bool) : Guid ResizeArray =
        let rc = ResizeArray()
        let curve = RhinoScriptSyntax.CoerceCurve curveId
        let pieces = curve.DuplicateSegments()
        if notNull pieces then
            for piece in pieces do
                rc.Add(State.Doc.Objects.AddCurve(piece))
            if deleteInput then
                State.Doc.Objects.Delete(curveId, quiet=true) |>ignore
        if rc.Count>0 then  State.Doc.Views.Redraw()
        rc

    ///<summary>Explodes, or un-joins, several curves Curve. PolyCurves will be exploded into Curve
    ///    segments. Polylines will be exploded into line segments. ExplodeCurves will
    ///    return the Curves in topological order.</summary>
    ///<param name="curveIds">(Guid seq) The Curve objects to explode</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>false</c>
    ///    Delete input objects after exploding if True</param>
    ///<returns>(Guid ResizeArray) identifying the newly created Curve objects.</returns>
    static member ExplodeCurves(curveIds:Guid seq, [<OPT;DEF(false)>]deleteInput:bool) : Guid ResizeArray =
        let rc = ResizeArray()
        for curveId in curveIds do
            let curve = RhinoScriptSyntax.CoerceCurve curveId
            let pieces = curve.DuplicateSegments()
            if notNull pieces then
                for piece in pieces do
                    rc.Add(State.Doc.Objects.AddCurve(piece))
                if deleteInput then
                    State.Doc.Objects.Delete(curveId, quiet=true) |>ignore
        if rc.Count>0 then  State.Doc.Views.Redraw()
        rc


    ///<summary>Extends a non-closed Curve object by a line, arc, or smooth extension
    ///    until it intersects a collection of objects.</summary>
    ///<param name="curveId">(Guid) Identifier of Curve to extend</param>
    ///<param name="extensionType">(int)
    ///    0 = line
    ///    1 = arc
    ///    2 = smooth</param>
    ///<param name="side">(int)
    ///    0 = extend from the start of the Curve
    ///    1 = extend from the end of the Curve
    ///    2 = extend from both the start and the end of the Curve</param>
    ///<param name="boundaryCurveIds">(Guid seq) Curve, Surface, and Polysurface objects to extend to</param>
    ///<param name="replaceInput">(bool) Optional, Default Value <c>false</c> Replace input or add new?</param>
    ///<returns>(Guid) The identifier of the new object or original Curve ( depending on 'replaceInput').</returns>
    static member ExtendCurve(  curveId:Guid,
                                extensionType:int,
                                side:int,
                                boundaryCurveIds:Guid seq,
                                [<OPT;DEF(false)>]replaceInput:bool) : Guid =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let mutable extensionTypet = CurveExtensionStyle.Line
        if extensionType = 0   then extensionTypet <- CurveExtensionStyle.Line
        elif extensionType = 1 then extensionTypet <- CurveExtensionStyle.Arc
        elif extensionType = 2 then extensionTypet <- CurveExtensionStyle.Smooth
        else RhinoScriptingException.Raise "RhinoScriptSyntax.ExtendCurve ExtensionType must be 0, 1, or 2. curveId:'%s' extensionType:'%A' side:'%A' boundaryCurveIds:'%s'" (Nice.str curveId) extensionType side  (Nice.str boundaryCurveIds)

        let sidet =
            match side with
            |0  -> CurveEnd.Start
            |1  -> CurveEnd.End
            |2  -> CurveEnd.Both
            |_  -> RhinoScriptingException.Raise "RhinoScriptSyntax.ExtendCurve Side must be 0, 1, or 2. curveId:'%s' extensionType:'%A' side:'%A' boundaryCurveIds:'%s'" (Nice.str curveId) extensionType side  (Nice.str boundaryCurveIds)

        let rhobjs = resizeArray { for objectId in boundaryCurveIds -> RhinoScriptSyntax.CoerceRhinoObject(objectId) }
        if rhobjs.IsEmpty then  RhinoScriptingException.Raise "RhinoScriptSyntax.ExtendCurve boundaryCurveIds failed. They must contain at least one item. curveId:'%s' extensionType:'%A' side:'%A' boundaryCurveIds:'%s'" (Nice.str curveId) extensionType side (Nice.str boundaryCurveIds)
        let geometry = resizeArray { for obj in rhobjs -> obj.Geometry }
        let newcurve = curve.Extend(sidet, extensionTypet, geometry)
        if notNull newcurve && newcurve.IsValid then
            if replaceInput then
                if State.Doc.Objects.Replace(curveId, newcurve) then
                    State.Doc.Views.Redraw()
                    curveId
                else
                    RhinoScriptingException.Raise "RhinoScriptSyntax.ExtendCurve failed. curveId:'%s' extensionType:'%A' side:'%A' boundaryCurveIds:'%s'" (Nice.str curveId) extensionType side  (Nice.str boundaryCurveIds)
            else
                let g= State.Doc.Objects.AddCurve(newcurve)
                State.Doc.Views.Redraw()
                g
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.ExtendCurve failed. curveId:'%s' extensionType:'%A' side:'%A' boundaryCurveIds:'%s'" (Nice.str curveId) extensionType side  (Nice.str boundaryCurveIds)


    ///<summary>Extends a non-closed Curve by a line, arc, or smooth extension for a specified distance.</summary>
    ///<param name="curveId">(Guid) Curve to extend</param>
    ///<param name="extensionType">(int)
    ///    0 = line
    ///    1 = arc
    ///    2 = smooth</param>
    ///<param name="side">(int)
    ///    0 = extend from start of the Curve
    ///    1 = extend from end of the Curve
    ///    2 = Extend from both ends</param>
    ///<param name="length">(float) Distance to extend</param>
    ///<returns>(Guid) The identifier of the new object.</returns>
    static member ExtendCurveLength(    curveId:Guid,
                                        extensionType:int,
                                        side:int,
                                        length:float) : Guid =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let mutable extensionTypet = CurveExtensionStyle.Line
        if extensionType   = 0 then extensionTypet <- CurveExtensionStyle.Line
        elif extensionType = 1 then extensionTypet <- CurveExtensionStyle.Arc
        elif extensionType = 2 then extensionTypet <- CurveExtensionStyle.Smooth
        else RhinoScriptingException.Raise "RhinoScriptSyntax.ExtendCurveLength ExtensionType must be 0, 1, or 2. curveId:'%s' extensionType:'%A' side:'%A' length:'%A'" (Nice.str curveId) extensionType side length

        let sideT =
            match side with
            |0  -> CurveEnd.Start
            |1  -> CurveEnd.End
            |2  -> CurveEnd.Both
            |_  -> RhinoScriptingException.Raise "RhinoScriptSyntax.ExtendCurveLength Side must be 0, 1, or 2. curveId:'%s' extensionType:'%A' side:'%A' length:'%A'" (Nice.str curveId) extensionType side length

        let newcurve =
            if length<0. then curve.Trim(sideT, -length)
            else curve.Extend(sideT, length, extensionTypet)

        if notNull newcurve && newcurve.IsValid then
            if State.Doc.Objects.Replace(curveId, newcurve) then
                State.Doc.Views.Redraw()
                curveId
            else RhinoScriptingException.Raise "RhinoScriptSyntax.ExtendCurveLength failed. curveId:'%s' extensionType:'%A' side:'%A' length:'%A'" (Nice.str curveId) extensionType side length
        else RhinoScriptingException.Raise "RhinoScriptSyntax.ExtendCurveLength failed. curveId:'%s' extensionType:'%A' side:'%A' length:'%A'" (Nice.str curveId) extensionType side length


    ///<summary>Extends a non-closed Curve by smooth extension to a point.</summary>
    ///<param name="curveId">(Guid) Curve to extend</param>
    ///<param name="side">(int)
    ///    0 = extend from start of the Curve
    ///    1 = extend from end of the Curve
    ///    2 = extend from both the start and the end of the Curve</param>
    ///<param name="point">(Point3d) Point to extend to</param>
    ///<param name="extensionType">(int) Optional, default value: <c>2</c> ( CurveExtensionStyle.Smooth))
    ///    0 = line
    ///    1 = arc
    ///    2 = smooth</param>
    ///<returns>(Guid) The identifier of the new object.</returns>
    static member ExtendCurvePoint( curveId:Guid,
                                    side:int,
                                    point:Point3d,
                                    [<OPT;DEF(-1)>]extensionType:int) : Guid =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let extensionTypet =
            match extensionType with
            | -1 ->  CurveExtensionStyle.Smooth
            |  0 ->  CurveExtensionStyle.Line
            |  1 ->  CurveExtensionStyle.Arc
            |  2 ->  CurveExtensionStyle.Smooth
            |  _ ->  RhinoScriptingException.Raise "RhinoScriptSyntax.ExtendCurvePoint ExtensionType must be 0, 1, or 2. curveId:'%s' side:'%A' point:'%A' extensionType:'%A'" (Nice.str curveId) side point extensionType

        let sidet =
            match side with
            | 0  -> CurveEnd.Start
            | 1  -> CurveEnd.End
            | 2  -> CurveEnd.Both
            | _  -> RhinoScriptingException.Raise "RhinoScriptSyntax.ExtendCurvePoint Side must be 0, 1, or 2. curveId:'%s' side:'%A' point:'%A' extensionType:'%A'" (Nice.str curveId) side point extensionType

        let newcurve = curve.Extend(sidet, extensionTypet, point)
        if notNull newcurve && newcurve.IsValid then
            if State.Doc.Objects.Replace( curveId, newcurve ) then
                State.Doc.Views.Redraw()
                curveId
            else RhinoScriptingException.Raise "RhinoScriptSyntax.ExtendCurvePoint failed. curveId:'%s' side:'%A' point:'%A'" (Nice.str curveId) side point
        else RhinoScriptingException.Raise "RhinoScriptSyntax.ExtendCurvePoint failed. curveId:'%s' side:'%A' point:'%A'" (Nice.str curveId) side point


    ///<summary>Fairs a Curve. Fair works best on degree 3 (cubic) Curves. Fair attempts
    ///    to remove large curvature variations while limiting the geometry changes to
    ///    be no more than the specified tolerance. Sometimes several applications of
    ///    this method are necessary to remove nasty curvature problems.</summary>
    ///<param name="curveId">(Guid) Curve to fair</param>
    ///<param name="tolerance">(float) Fairing tolerance</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member FairCurve(curveId:Guid, tolerance:float) : bool =
        let mutable curve = RhinoScriptSyntax.CoerceCurve curveId
        let angleTol = 0.0
        let mutable clamp = 0
        if curve.IsPeriodic then
            curve <- curve.ToNurbsCurve()
            clamp <- 1
        let newcurve = curve.Fair(tolerance, angleTol, clamp, clamp, 100)
        if notNull newcurve then  false
        else
            if State.Doc.Objects.Replace(curveId, newcurve) then
                State.Doc.Views.Redraw()
                true
            else
                false


    ///<summary>Reduces number of Curve control points while maintaining the Curve's same
    ///    general shape. Use this function for replacing Curves with many control
    ///    points. For more information, see the Rhino help for the FitCrv command.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="degree">(int) Optional, default value: <c>3</c>
    ///    The Curve degree, which must be greater than 1.
    ///    The default is 3</param>
    ///<param name="distanceTolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c>
    ///    The fitting tolerance.</param>
    ///<param name="angleTolerance">(float) Optional, default value: <c>State.Doc.ModelAngleToleranceRadians</c>
    ///    The kink smoothing tolerance in degrees. If
    ///    angleTolerance is 0.0, all kinks are smoothed. If angleTolerance
    ///    is bigger than  0.0, kinks smaller than angleTolerance are smoothed. If
    ///    angleTolerance is not specified or smaller than 0.0, the document angle
    ///    tolerance is used for the kink smoothing</param>
    ///<returns>(Guid) The identifier of the new object.</returns>
    static member FitCurve( curveId:Guid,
                            [<OPT;DEF(3)>]degree:int,
                            [<OPT;DEF(0.0)>]distanceTolerance:float,
                            [<OPT;DEF(-1.0)>]angleTolerance:float) : Guid =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let distanceTolerance0 = Util.ifZero1 distanceTolerance State.Doc.ModelAbsoluteTolerance
        let angleTolerance0 = if  angleTolerance < 0.0 then  State.Doc.ModelAngleToleranceRadians else toRadians angleTolerance
        let nc = curve.Fit(degree, distanceTolerance0, angleTolerance0)
        if notNull nc then
            let rhobj = RhinoScriptSyntax.CoerceRhinoObject(curveId)
            let mutable rc = Guid.Empty
            if notNull rhobj then
                rc <- State.Doc.Objects.AddCurve(nc, rhobj.Attributes)
            else
                rc <- State.Doc.Objects.AddCurve(nc)
            if rc = Guid.Empty then  RhinoScriptingException.Raise "RhinoScriptSyntax.FitCurve: Unable to add curve to document. curveId:'%s' degree:'%A' distanceTolerance:'%A' angleTolerance:'%A'" (Nice.str curveId) degree distanceTolerance angleTolerance
            State.Doc.Views.Redraw()
            rc
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.FitCurve failed. curveId:'%s' degree:'%A' distanceTolerance:'%A' angleTolerance:'%A'" (Nice.str curveId) degree distanceTolerance angleTolerance


    ///<summary>Inserts a knot into a Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="parameter">(float) Parameter on the Curve</param>
    ///<param name="symmetrical">(bool) Optional, default value: <c>false</c>
    ///    If True, then knots are added on both sides of
    ///    the center of the Curve</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member InsertCurveKnot(curveId:Guid, parameter:float, [<OPT;DEF(false)>]symmetrical:bool) : bool =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        if not <| curve.Domain.IncludesParameter(parameter) then  false
        else
            let nc = curve.ToNurbsCurve()
            if isNull nc then  false
            else
                let rc, t = curve.GetNurbsFormParameterFromCurveParameter(parameter)
                if rc then
                    let mutable rc = nc.Knots.InsertKnot(t, 1)
                    if rc && symmetrical then
                        let domain = nc.Domain
                        let tSym = domain.T1 - t + domain.T0
                        if abs(tSym)>RhinoMath.SqrtEpsilon then
                            rc <- nc.Knots.InsertKnot(tSym, 1)
                            if rc then  State.Doc.Views.Redraw()
                    if rc then
                        rc <- State.Doc.Objects.Replace(curveId, nc)
                        if rc then  State.Doc.Views.Redraw()
                rc


    ///<summary>Checks if an object is an open arc Curve. Returns false for any other Rhino object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="tolerance">(float) Optional, default value: <c>RhinoMath.ZeroTolerance</c>
    ///    If the Curve is not a circle, then the tolerance used
    ///    to determine whether or not the NURBS form of the Curve has the
    ///    properties of a arc.</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(bool) True or False.</returns>
    static member IsArc(curveId:Guid, [<OPT;DEF(0.0)>]tolerance:float, [<OPT;DEF(-1)>]segmentIndex:int) : bool =
        let tol = Util.ifZero2 RhinoMath.ZeroTolerance tolerance
        match RhinoScriptSyntax.TryCoerceCurve(curveId, segmentIndex) with
        |None -> false
        |Some curve  -> curve.IsArc(tol) && not curve.IsClosed


    ///<summary>Checks if an object is a circle Curve.  Returns false for any other Rhino object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="tolerance">(float) Optional, default value: <c>RhinoMath.ZeroTolerance</c>
    ///    If the Curve is not a circle, then the tolerance used
    ///    to determine whether or not the NURBS form of the Curve has the
    ///    properties of a circle.</param>
    ///<returns>(bool) True or False.</returns>
    static member IsCircle(curveId:Guid, [<OPT;DEF(0.0)>]tolerance:float) : bool =
        let tol = Util.ifZero2 RhinoMath.ZeroTolerance tolerance
        match RhinoScriptSyntax.TryCoerceCurve curveId with
        |None -> false
        |Some curve  -> curve.IsCircle(tol)


    ///<summary>Checks if an object is a Curve. Returns false for any other Rhino object.</summary>
    ///<param name="curveId">(Guid) The object's identifier</param>
    ///<returns>(bool) True or False.</returns>
    static member IsCurve(curveId:Guid) : bool =
        match RhinoScriptSyntax.TryCoerceCurve curveId with
        |None -> false
        |Some _  -> true


    ///<summary>Decide if it makes sense to close off the Curve by moving the end point
    ///    to the start point based on start-end gap size and length of Curve as
    ///    approximated by chord defined by 6 points. Returns false for any other Rhino object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c>
    ///    Maximum allowable distance between start point and end point.</param>
    ///<returns>(bool) True or False.</returns>
    static member IsCurveClosable(curveId:Guid, [<OPT;DEF(0.0)>]tolerance:float) : bool =
        let tolerance0 = Util.ifZero2 State.Doc.ModelAbsoluteTolerance tolerance
        match RhinoScriptSyntax.TryCoerceCurve curveId with
        |None -> false
        |Some curve  -> curve.IsClosable(tolerance0)


    ///<summary>Checks if an object is a closed Curve object. Returns false for any other Rhino object.</summary>
    ///<param name="curveId">(Guid) The object's identifier</param>
    ///<returns>(bool) If Curve is Closed True,  otherwise False.</returns>
    static member IsCurveClosed(curveId:Guid) : bool =
        match RhinoScriptSyntax.TryCoerceCurve curveId with
        |None -> false
        |Some curve  -> curve.IsClosed


    ///<summary>Test a Curve to see if it lies in a specific Plane. Returns false for any other Rhino object.</summary>
    ///<param name="curveId">(Guid) The object's identifier</param>
    ///<param name="plane">(Plane) Plane to test</param>
    ///<param name="tolerance">(float) Optional, default value: <c>RhinoMath.ZeroTolerance</c></param>
    ///<returns>(bool) True or False.</returns>
    static member IsCurveInPlane(curveId:Guid, plane:Plane, [<OPT;DEF(0.0)>]tolerance:float) : bool =
        let tolerance0 = Util.ifZero2 RhinoMath.ZeroTolerance tolerance
        match RhinoScriptSyntax.TryCoerceCurve curveId with
        |None -> false
        |Some curve  -> curve.IsInPlane(plane, tolerance0)


    ///<summary>Checks if an object is a linear Curve. Returns false for any other Rhino object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>    ///
    ///<param name="tolerance">(float) Optional, default value: <c>RhinoMath.ZeroTolerance</c></param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member IsCurveLinear(curveId:Guid, [<OPT;DEF(0.0)>]tolerance:float, [<OPT;DEF(-1)>]segmentIndex:int) : bool =
        let tolerance0 = Util.ifZero2 RhinoMath.ZeroTolerance tolerance
        match  RhinoScriptSyntax.TryCoerceCurve(curveId, segmentIndex) with
        |None -> false
        |Some curve  -> curve.IsLinear(tolerance0)


    ///<summary>Checks if an object is a periodic Curve object. Returns false for any other Rhino object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segmentIndex">(int) Optional,
    ///    The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(bool) True or False.</returns>
    static member IsCurvePeriodic(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : bool =
        match RhinoScriptSyntax.TryCoerceCurve(curveId, segmentIndex) with
        |None -> false
        |Some curve  -> curve.IsPeriodic


    ///<summary>Checks if an object is a planar Curve. Returns false for any other Rhino object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="tolerance">(float) Optional, default value: <c>RhinoMath.ZeroTolerance</c></param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member IsCurvePlanar(curveId:Guid, [<OPT;DEF(0.0)>]tolerance:float, [<OPT;DEF(-1)>]segmentIndex:int) : bool =
        let tol = Util.ifZero2 RhinoMath.ZeroTolerance tolerance
        match RhinoScriptSyntax.TryCoerceCurve(curveId, segmentIndex) with
        |None -> false
        |Some curve  -> curve.IsPlanar(tol)


    ///<summary>Checks if an object is a rational NURBS Curve. Returns false for any other Rhino object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member IsCurveRational(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : bool =
        match RhinoScriptSyntax.TryCoerceCurve(curveId, segmentIndex) with
        |None -> false
        |Some c  ->
            match c with
            | :? NurbsCurve as curve -> curve.IsRational
            |_ -> false


    ///<summary>Checks if an object is an elliptical-shaped Curve. Returns false for any other Rhino object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="tolerance">(float) Optional, default value: <c>RhinoMath.ZeroTolerance</c></param>
    ///<param name="segmentIndex">(int) Optional,
    ///    The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member IsEllipse(curveId:Guid, [<OPT;DEF(0.0)>]tolerance:float, [<OPT;DEF(-1)>]segmentIndex:int) : bool =
        let tol = Util.ifZero2 RhinoMath.ZeroTolerance tolerance
        match RhinoScriptSyntax.TryCoerceCurve(curveId,segmentIndex) with
        |None -> false
        |Some curve  -> curve.IsEllipse(tol)


    ///<summary>Checks if an object is a line Curve. Returns false for any other Rhino object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="tolerance">(float) Optional, default value: <c>RhinoMath.ZeroTolerance</c></param>
    ///<param name="segmentIndex">(int) Optional,
    ///    The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member IsLine(curveId:Guid, [<OPT;DEF(0.0)>]tolerance:float, [<OPT;DEF(-1)>]segmentIndex:int) : bool =
        let tol = Util.ifZero2 RhinoMath.ZeroTolerance tolerance
        match RhinoScriptSyntax.TryCoerceCurve(curveId, segmentIndex) with
        |None -> false
        |Some c  ->
            match c with
            | :? LineCurve  -> true
            | curve  ->
                if curve.IsLinear(tol) then true
                else
                    let rc, polyline = curve.TryGetPolyline()
                    if rc && polyline.Count = 2 then  true
                    else false


    ///<summary>Checks if a point is on a Curve. Returns false for any other Rhino object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="point">(Point3d) The test point</param>
    ///<param name="tolerance">(float) Optional, default value: <c>RhinoMath.SqrtEpsilon</c></param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member IsPointOnCurve(curveId:Guid, point:Point3d, [<OPT;DEF(0.0)>]tolerance:float, [<OPT;DEF(-1)>]segmentIndex:int) : bool =
        let tol = Util.ifZero2 RhinoMath.SqrtEpsilon tolerance
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        let t = ref 0.0
        curve.ClosestPoint(point, t, tol)


    ///<summary>Checks if an object is a PolyCurve Curve. Returns false for any other Rhino object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(bool) True or False.</returns>
    static member IsPolyCurve(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : bool =
        // TODO can a polycurve be nested in a polycurve ?
        match RhinoScriptSyntax.TryCoerceCurve(curveId, segmentIndex) with
        |None               -> false
        |Some c  ->
            match c with
            | :? PolyCurve  -> true
            | _             -> false


    ///<summary>Checks if an object is a Polyline Curve object or a nurbs cure with degree 1 and moer than 2 points
    /// Lines return false. Returns false for any other Rhino object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="segmentIndex">(int) Optional, The Curve segment index if `curveId` identifies a polycurve</param>
    ///<returns>(bool) True or False.</returns>
    static member IsPolyline(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : bool =
        match RhinoScriptSyntax.TryCoerceCurve(curveId, segmentIndex) with
        |None               -> false
        |Some c  ->
            match c with
            | :? PolylineCurve  -> true
            | :? NurbsCurve as nc -> nc.Points.Count > 2 && c.Degree = 1
            | _ -> false



    ///<summary>Joins multiple Curves together to form one or more Curves or polycurves.</summary>
    ///<param name="curveIds">(Guid seq) List of multiple Curves</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>false</c>
    ///    Delete input objects after joining</param>
    ///<param name="tolerance">(float) Optional, default value: <c>2.1 * State.Doc.ModelAbsoluteTolerance</c>
    ///    Join tolerance. If omitted, 2.1 * document absolute
    ///    tolerance is used</param>
    ///<returns>(Guid ResizeArray) Object objectId representing the new Curves.</returns>
    static member JoinCurves(curveIds:Guid seq, [<OPT;DEF(false)>]deleteInput:bool, [<OPT;DEF(0.0)>]tolerance:float) : Guid ResizeArray =
        let curves = resizeArray { for objectId in curveIds -> RhinoScriptSyntax.CoerceCurve objectId }
        if curves.IsEmpty then
            RhinoScriptingException.Raise "RhinoScriptSyntax.JoinCurves: curveIds must contain at least two items.  curveIds:'%s' deleteInput:'%A' tolerance:'%A'" (Nice.str curveIds) deleteInput tolerance
        let tolerance0 = Util.ifZero1 tolerance (2.1 * State.Doc.ModelAbsoluteTolerance)
        let newcurves = Curve.JoinCurves(curves, tolerance0)
        if isNull newcurves then
            RhinoScriptingException.Raise "RhinoScriptSyntax.JoinCurves failed on curveIds:'%s' deleteInput:'%A' tolerance:'%A'" (Nice.str curveIds) deleteInput tolerance

        let rc = resizeArray { for crv in newcurves -> State.Doc.Objects.AddCurve(crv) }
        if deleteInput then
            for objectId in curveIds do
                State.Doc.Objects.Delete(objectId, quiet=false) |> ignore
        State.Doc.Views.Redraw()
        rc



    ///<summary>Returns a line that was fit through an array of 3D points.</summary>
    ///<param name="points">(Point3d seq) A list of at least two 3D points</param>
    ///<returns>(Line) line.</returns>
    static member LineFitFromPoints(points:Point3d seq) : Line =
        let rc, line = Line.TryFitLineToPoints(points)
        if rc then  line
        else RhinoScriptingException.Raise "RhinoScriptSyntax.LineFitFromPoints failed.  points:'%A'" points


    ///<summary>Makes a periodic Curve non-periodic. Non-periodic Curves can develop
    ///    kinks when deformed.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>false</c>
    ///    Delete the input Curve. If omitted, the input Curve will not be deleted</param>
    ///<returns>(Guid) objectId of the new or modified Curve.</returns>
    static member MakeCurveNonPeriodic(curveId:Guid, [<OPT;DEF(false)>]deleteInput:bool) : Guid =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        if not <| curve.IsPeriodic then  RhinoScriptingException.Raise "RhinoScriptSyntax.MakeCurveNonPeriodic failed.1  curveId:'%s' deleteInput:'%A'" (Nice.str curveId) deleteInput
        let nc = curve.ToNurbsCurve()
        if isNull nc  then  RhinoScriptingException.Raise "RhinoScriptSyntax.MakeCurveNonPeriodic failed.2  curveId:'%s' deleteInput:'%A'" (Nice.str curveId) deleteInput
        if not <| nc.Knots.ClampEnd( CurveEnd.Both ) then RhinoScriptingException.Raise "RhinoScriptSyntax.MakeCurveNonPeriodic failed. curveId:'%s' deleteInput:'%A'" (Nice.str curveId) deleteInput
        if deleteInput then
            let rc = State.Doc.Objects.Replace(curveId, nc)
            if not <| rc then  RhinoScriptingException.Raise "RhinoScriptSyntax.MakeCurveNonPeriodic failed.3  curveId:'%s' deleteInput:'%A'" (Nice.str curveId) deleteInput
            State.Doc.Views.Redraw()
            curveId
        else
            let rhobj = RhinoScriptSyntax.CoerceRhinoObject(curveId)
            let rc = State.Doc.Objects.AddCurve(nc, rhobj.Attributes)
            if rc = Guid.Empty then  RhinoScriptingException.Raise "RhinoScriptSyntax.MakeCurveNonPeriodic failed.4  curveId:'%s' deleteInput:'%A'" (Nice.str curveId) deleteInput
            State.Doc.Views.Redraw()
            rc


    ///<summary>Creates an average Curve from two Curves.</summary>
    ///<param name="curve0">(Guid) identifiers of first Curve</param>
    ///<param name="curve1">(Guid) identifiers of second Curve</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c>
    ///    Angle tolerance used to match kinks between Curves</param>
    ///<returns>(Guid) objectId of the new or modified Curve.</returns>
    static member MeanCurve(curve0:Guid, curve1:Guid, [<OPT;DEF(0.0)>]tolerance:float) : Guid =
        let curve0 = RhinoScriptSyntax.CoerceCurve curve0
        let curve1 = RhinoScriptSyntax.CoerceCurve curve1
        let  tolerance = if tolerance = 0.0 then RhinoMath.UnsetValue else abs (tolerance)
        let crv = Curve.CreateMeanCurve(curve0, curve1, tolerance)
        if notNull crv then
            let rc = State.Doc.Objects.AddCurve(crv)
            State.Doc.Views.Redraw()
            rc
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.MeanCurve failed.  curve1:'%A' curve0:'%A' tolerance:'%f'" curve1 curve0 tolerance


    ///<summary>Creates a polygon Mesh object based on a closed Polyline Curve object.
    ///    The created Mesh object is added to the document.</summary>
    ///<param name="polylineId">(Guid) Identifier of the Polyline Curve object</param>
    ///<returns>(Guid) identifier of the new Mesh object.</returns>
    static member MeshPolyline(polylineId:Guid) : Guid =
        let curve = RhinoScriptSyntax.CoerceCurve polylineId
        let ispolyline, polyline = curve.TryGetPolyline()
        if not <| ispolyline then  RhinoScriptingException.Raise "RhinoScriptSyntax.MeshPolyline failed.  polylineId:'%s'" (Nice.str polylineId)
        let mesh = Mesh.CreateFromClosedPolyline(polyline)
        if isNull mesh then  RhinoScriptingException.Raise "RhinoScriptSyntax.MeshPolyline failed.  polylineId:'%s'" (Nice.str polylineId)
        let rc = State.Doc.Objects.AddMesh(mesh)
        State.Doc.Views.Redraw()
        rc


    ///<summary>Offsets a Curve by a distance. The offset Curve will be added to Rhino.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve object</param>
    ///<param name="direction">(Point3d) Point describing direction of the offset</param>
    ///<param name="distance">(float) Distance of the offset</param>
    ///<param name="normal">(Vector3d) Optional, default value: <c>Vector3d.ZAxis</c>
    ///    Normal of the Plane in which the offset will occur.
    ///    If omitted, the WorldXY Plane will be used</param>
    ///<param name="style">(int) Optional, default value: <c>1</c>
    ///    The corner style. If omitted, the style is sharp.
    ///    0 = None
    ///    1 = Sharp
    ///    2 = Round
    ///    3 = Smooth
    ///    4 = Chamfer</param>
    ///<returns>(Guid ResizeArray) list of ids for the new Curves.</returns>
    static member OffsetCurve(curveId:Guid, direction:Point3d, distance:float, [<OPT;DEF(Vector3d())>]normal:Vector3d, [<OPT;DEF(1)>]style:int) : Guid ResizeArray = //TODO make overload instead,[<OPT;DEF(Point3d())>] may leak  see draw vector and transform point!
        let normal0 = if normal.IsZero then Vector3d.ZAxis else normal
        let curve = RhinoScriptSyntax.CoerceCurve curveId
        let tolerance = State.Doc.ModelAbsoluteTolerance
        let stylee:CurveOffsetCornerStyle = EnumOfValue style
        let curves = curve.Offset(direction, normal0, distance, tolerance, stylee)
        if isNull curves then  RhinoScriptingException.Raise "RhinoScriptSyntax.OffsetCurve failed. curveId:'%s' direction:'%A' distance:'%A' normal:'%A' style:%d" (Nice.str curveId) direction distance normal style
        let rc = resizeArray { for curve in curves -> State.Doc.Objects.AddCurve(curve) }
        State.Doc.Views.Redraw()
        rc


    ///<summary>Offset a Curve on a Surface. The source Curve must lie on the Surface.
    ///    The offset Curve or Curves will be added to Rhino.</summary>
    ///<param name="curveId">(Guid) Curve identifiers</param>
    ///<param name="surfaceId">(Guid) Surface identifiers</param>
    ///<param name="parameter">(Point2d))  U, V parameter that the Curve will be offset through</param>
    ///<returns>(Guid ResizeArray) identifiers of the new Curves.</returns>
    static member OffsetCurveOnSurfaceUV(curveId:Guid, surfaceId:Guid, parameter:Point2d) : Guid ResizeArray =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let tol = State.Doc.ModelAbsoluteTolerance
        let curves = curve.OffsetOnSurface(surface, parameter, tol)
        if isNull curves  then  RhinoScriptingException.Raise "RhinoScriptSyntax.OffsetCurveOnSurfaceUV failed. curveId:'%s' surfaceId:'%s' parameter:'%A'" (Nice.str curveId) (Nice.str surfaceId) parameter
        let rc = resizeArray { for curve in curves -> State.Doc.Objects.AddCurve(curve) }
        State.Doc.Views.Redraw()
        rc

    ///<summary>Offset a Curve on a Surface. The source Curve must lie on the Surface.
    ///    The offset Curve or Curves will be added to Rhino Document.</summary>
    ///<param name="curveId">(Guid) The Curve identifiers</param>
    ///<param name="surfaceId">(Guid) The Surface identifiers</param>
    ///<param name="distance">(float)) The distance of the offset. Based on the Curve's direction, a positive value
    ///    will offset to the left and a negative value will offset to the right</param>
    ///<returns>(Guid ResizeArray) identifiers of the new Curves.</returns>
    static member OffsetCurveOnSurface(curveId:Guid, surfaceId:Guid, distance:float) : Guid ResizeArray =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let tol = State.Doc.ModelAbsoluteTolerance
        let curves = curve.OffsetOnSurface(surface, distance, tol)
        if isNull curves  then  RhinoScriptingException.Raise "RhinoScriptSyntax.OffsetCurveOnSurface failed. curveId:'%s' surfaceId:'%s' distance:'%A'" (Nice.str curveId) (Nice.str surfaceId) distance
        let curves = resizeArray {for curve in curves do curve.ExtendOnSurface(Rhino.Geometry.CurveEnd.Both, surface) } //https://github.com/mcneel/rhinoscriptsyntax/pull/186
        let rc = resizeArray { for curve in curves -> State.Doc.Objects.AddCurve(curve) }
        State.Doc.Views.Redraw()
        rc



    ///<summary>Determines the relationship between the regions bounded by two coplanar simple closed Curves.</summary>
    ///<param name="curveA">(Guid) identifier of the first  planar, closed Curve</param>
    ///<param name="curveB">(Guid) identifier of the second planar, closed Curve</param>
    ///<param name="plane">(Plane) Optional, default value: <c>Plane.WorldXY</c>
    ///    Test Plane. If omitted, the Plane.WorldXY Plane is used</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c></param>
    ///<returns>(int) a number identifying the relationship
    ///    0 = the regions bounded by the Curves are disjoint
    ///    1 = the two Curves intersect
    ///    2 = the region bounded by CurveA is inside of CurveB
    ///    3 = the region bounded by CurveB is inside of CurveA.</returns>
    static member PlanarClosedCurveContainment(curveA:Guid, curveB:Guid, [<OPT;DEF(Plane())>]plane:Plane, [<OPT;DEF(0.0)>]tolerance:float) : int =
        let curveA = RhinoScriptSyntax.CoerceCurve curveA
        let curveB = RhinoScriptSyntax.CoerceCurve curveB
        let tolerance0 = Util.ifZero2 State.Doc.ModelAbsoluteTolerance tolerance
        let plane0 = if plane.IsValid then plane else Plane.WorldXY
        let rc = Curve.PlanarClosedCurveRelationship(curveA, curveB, plane0, tolerance0)
        int(rc)


    ///<summary>Determines if two coplanar Curves intersect.</summary>
    ///<param name="curveA">(Guid) identifier of the first  planar Curve</param>
    ///<param name="curveB">(Guid) identifier of the second planar Curve</param>
    ///<param name="plane">(Plane) Optional, default value: <c>Plane.WorldXY</c>
    ///    Test Plane. If omitted, the Plane.WorldXY Plane is used</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c></param>
    ///<returns>(bool) True if the Curves intersect; otherwise False.</returns>
    static member PlanarCurveCollision(curveA:Guid, curveB:Guid, [<OPT;DEF(Plane())>]plane:Plane, [<OPT;DEF(0.0)>]tolerance:float) : bool =
        let curveA = RhinoScriptSyntax.CoerceCurve curveA
        let curveB = RhinoScriptSyntax.CoerceCurve curveB
        let tolerance0 = Util.ifZero2 State.Doc.ModelAbsoluteTolerance tolerance
        let plane0 = if plane.IsValid then plane else Plane.WorldXY
        Curve.PlanarCurveCollision(curveA, curveB, plane0, tolerance0)


    ///<summary>Determines if a point is inside of a closed Curve, on a closed Curve, or
    ///    outside of a closed Curve.</summary>
    ///<param name="point">(Point3d) Text point</param>
    ///<param name="curve">(Guid) Identifier of a Curve object</param>
    ///<param name="plane">(Plane) Optional, default value: <c>Plane.WorldXY</c>
    ///    Plane containing the closed Curve and point. If omitted, Plane.WorldXY  is used</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c></param>
    ///<returns>(int) number identifying the result
    ///    0 = point is outside of the Curve
    ///    1 = point is inside of the Curve
    ///    2 = point is on the Curve.</returns>
    static member PointInPlanarClosedCurve(point:Point3d, curve:Guid, [<OPT;DEF(Plane())>]plane:Plane, [<OPT;DEF(0.0)>]tolerance:float) : int =
        let curve = RhinoScriptSyntax.CoerceCurve curve
        let tolerance0 = Util.ifZero2 State.Doc.ModelAbsoluteTolerance tolerance
        let plane0 = if plane.IsValid then plane else Plane.WorldXY
        let rc = curve.Contains(point, plane0, tolerance0)
        if rc= PointContainment.Unset then
            RhinoScriptingException.Raise "RhinoScriptSyntax.PointInPlanarClosedCurve Curve.Contains is Unset.  point:'%A' curve:'%A' plane:'%A' tolerance:'%A'" point curve plane tolerance
        if rc= PointContainment.Outside then  0
        elif rc= PointContainment.Inside then  1
        else 2


    ///<summary>Returns the number of Curve segments that make up a polycurve.</summary>
    ///<param name="curveId">(Guid) The object's identifier</param>
    ///<param name="segmentIndex">(int) Optional,
    ///    If `curveId` identifies a PolyCurve object, then `segmentIndex` identifies the Curve segment of the PolyCurve to query</param>
    ///<returns>(int) The number of Curve segments in a polycurve.</returns>
    static member PolyCurveCount(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : int =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        match curve with
        | :? PolyCurve as curve ->  curve.SegmentCount
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.PolyCurveCount: CurveId does not reference a polycurve. curveId:'%s' segmentIndex:'%A'" (Nice.str curveId) segmentIndex


    ///<summary>Returns the vertices of a Polyline Curve.</summary>
    ///<param name="curveId">(Guid) The object's identifier</param>
    ///<param name="segmentIndex">(int) Optional,
    ///    If CurveId identifies a PolyCurve object, then segmentIndex identifies the Curve segment of the PolyCurve to query</param>
    ///<returns>(Point3d ResizeArray) an list of Point3d vertex points.</returns>
    static member PolylineVertices(curveId:Guid, [<OPT;DEF(-1)>]segmentIndex:int) : Point3d ResizeArray =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId, segmentIndex)
        let rc, polyline = curve.TryGetPolyline()
        if rc then  resizeArray { for pt in polyline -> pt }
        else RhinoScriptingException.Raise "RhinoScriptSyntax.PolylineVertices: CurveId does not <| reference a polyline. curveId:'%s' segmentIndex:'%A'" (Nice.str curveId) segmentIndex


    ///<summary>Projects one or more Curves onto one or more Surfaces or Meshes.</summary>
    ///<param name="curveIds">(Guid seq) Identifiers of Curves to project</param>
    ///<param name="meshIds">(Guid seq) Identifiers of Meshes to project onto</param>
    ///<param name="direction">(Vector3d) Projection direction</param>
    ///<returns>(Guid ResizeArray) list of identifiers for the resulting Curves.</returns>
    static member ProjectCurveToMesh(curveIds:Guid seq, meshIds:Guid seq, direction:Vector3d) : Guid ResizeArray =
        let curves = resizeArray { for objectId in curveIds -> RhinoScriptSyntax.CoerceCurve objectId }
        let meshes = resizeArray { for objectId in meshIds -> RhinoScriptSyntax.CoerceMesh(objectId) }
        let tolerance = State.Doc.ModelAbsoluteTolerance
        let newcurves = Curve.ProjectToMesh(curves, meshes, direction, tolerance)
        let ids = resizeArray { for curve in newcurves -> State.Doc.Objects.AddCurve(curve) }
        if ids.Count >0 then  State.Doc.Views.Redraw()
        ids


    ///<summary>Projects one or more Curves onto one or more Surfaces or Polysurfaces.</summary>
    ///<param name="curveIds">(Guid seq) Identifiers of Curves to project</param>
    ///<param name="surfaceIds">(Guid seq) Identifiers of Surfaces to project onto</param>
    ///<param name="direction">(Vector3d) Projection direction</param>
    ///<returns>(Guid ResizeArray) list of identifiers.</returns>
    static member ProjectCurveToSurface(curveIds:Guid seq, surfaceIds:Guid seq, direction:Vector3d) : Guid ResizeArray =
        let curves = resizeArray { for objectId in curveIds -> RhinoScriptSyntax.CoerceCurve objectId }
        let breps = resizeArray { for objectId in surfaceIds -> RhinoScriptSyntax.CoerceBrep(objectId) }
        let tolerance = State.Doc.ModelAbsoluteTolerance
        let newcurves = Curve.ProjectToBrep(curves, breps, direction, tolerance)
        let ids = resizeArray { for curve in newcurves -> State.Doc.Objects.AddCurve(curve) }
        if ids.Count > 0 then  State.Doc.Views.Redraw()
        ids


    ///<summary>Rebuilds a Curve to a given degree and control point count. For more
    ///    information, see the Rhino help for the Rebuild command.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<param name="degree">(int) New degree (must be greater than 0)</param>
    ///<param name="pointCount">(int) New point count, which must be bigger than degree</param>
    ///<returns>(bool) True of False indicating success or failure.</returns>
    static member RebuildCurve(curveId:Guid, degree:int, pointCount:int) : bool =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        if degree<1 then  RhinoScriptingException.Raise "RhinoScriptSyntax.RebuildCurve: Degree must be greater than 0. curveId:'%s' degree:'%A' pointCount:'%A'" (Nice.str curveId) degree pointCount
        let newcurve = curve.Rebuild(pointCount, degree, preserveTangents=false)
        if isNull newcurve then  false
        else
            State.Doc.Objects.Replace(curveId, newcurve) |> ignore
            State.Doc.Views.Redraw()
            true


    ///<summary>Deletes a knot from a Curve object.</summary>
    ///<param name="curve">(Guid) The reference of the source object</param>
    ///<param name="parameter">(float) The parameter on the Curve. Note, if the parameter is not equal to one
    ///    of the existing knots, then the knot closest to the specified parameter
    ///    will be removed</param>
    ///<returns>(bool) True of False indicating success or failure.</returns>
    static member RemoveCurveKnot(curve:Guid, parameter:float) : bool =
        let curveInst = RhinoScriptSyntax.CoerceCurve curve
        let success, nParam = curveInst.GetCurveParameterFromNurbsFormParameter(parameter)
        if not <| success then  false
        else
            let nCurve = curveInst.ToNurbsCurve()
            if isNull nCurve then  false
            else
                let success = nCurve.Knots.RemoveKnotAt(nParam)
                if not <| success then  false
                else
                    State.Doc.Objects.Replace(curve, nCurve)|> ignore
                    State.Doc.Views.Redraw()
                    true


    ///<summary>Reverses the direction of a Curve object. Same as Rhino's Dir command.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve object</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member ReverseCurve(curveId:Guid) : bool =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        if curve.Reverse() then
            State.Doc.Objects.Replace(curveId, curve)|> ignore
            true
        else
            false


    ///<summary>Replace a Curve with a geometrically equivalent polycurve.
    ///    The PolyCurve will have the following properties:
    ///      - All the PolyCurve segments are lines, polylines, arcs, or NURBS Curves.
    ///      - The NURBS Curves segments do not have fully multiple interior knots.
    ///      - Rational NURBS Curves do not have constant weights.
    ///      - Any segment for which IsCurveLinear or IsArc is True:  a line, Polyline segment, or an arc.
    ///      - Adjacent co-linear or co-circular segments are combined.
    ///      - Segments that meet with G1-continuity have there ends tuned up so that they meet with G1-continuity to within machine precision.
    ///      - If the PolyCurve is a polyline, a Polyline will be created.</summary>
    ///<param name="curveId">(Guid) The object's identifier</param>
    ///<param name="flags">(int) Optional, default value: <c>0</c>
    ///    The simplification methods to use. By default, all methods are used (flags = 0)
    ///    Value Description
    ///    0     Use all methods.
    ///    1     Do not split NURBS Curves at fully multiple knots.
    ///    2     Do not replace segments with IsCurveLinear = True with line Curves.
    ///    4     Do not replace segments with IsArc = True with arc Curves.
    ///    8     Do not replace rational NURBS Curves with constant denominator with an equivalent non-rational NURBS Curve.
    ///    16    Do not adjust Curves at G1-joins.
    ///    32    Do not merge adjacent co-linear lines or co-circular arcs or combine consecutive line segments into a polyline</param>
    ///<returns>(bool) True or False.</returns>
    static member SimplifyCurve(curveId:Guid, [<OPT;DEF(0)>]flags:int) : bool =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let mutable flagsDefault = 63
        if (flags &&& 1 )= 1  then flagsDefault <- flagsDefault &&& ( ~~~ (int CurveSimplifyOptions.SplitAtFullyMultipleKnots))
        if (flags &&& 2 )= 2  then flagsDefault <- flagsDefault &&& ( ~~~ (int CurveSimplifyOptions.RebuildLines))
        if (flags &&& 4 )= 4  then flagsDefault <- flagsDefault &&& ( ~~~ (int CurveSimplifyOptions.RebuildArcs))
        if (flags &&& 8 )= 8  then flagsDefault <- flagsDefault &&& ( ~~~ (int CurveSimplifyOptions.RebuildRationals))
        if (flags &&& 16)= 16 then flagsDefault <- flagsDefault &&& ( ~~~ (int CurveSimplifyOptions.AdjustG1))
        if (flags &&& 32)= 32 then flagsDefault <- flagsDefault &&& ( ~~~ (int CurveSimplifyOptions.Merge))
        let flags0: CurveSimplifyOptions = EnumOfValue flagsDefault
        //TODO test bitwise operations
        let tol = State.Doc.ModelAbsoluteTolerance
        let angTol = State.Doc.ModelAngleToleranceRadians
        let newcurve = curve.Simplify(flags0, tol, angTol)
        if notNull newcurve then
            State.Doc.Objects.Replace(curveId, newcurve)|> ignore
            State.Doc.Views.Redraw()
            true
        else
            false


    ///<summary>Splits, or divides, a Curve at a specified parameter. The parameter must
    ///    be in the interior of the Curve's domain.</summary>
    ///<param name="curveId">(Guid) The Curve to split</param>
    ///<param name="parameter">(float seq) One or more parameters to split the Curve at</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>true</c>
    ///    Delete the input Curve</param>
    ///<returns>(Guid ResizeArray) list of new Curves.</returns>
    static member SplitCurve(curveId:Guid, parameter:float seq, [<OPT;DEF(true)>]deleteInput:bool) : Guid ResizeArray =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let newcurves = curve.Split(parameter)
        if isNull newcurves then  RhinoScriptingException.Raise "RhinoScriptSyntax.SplitCurve failed. curveId:'%s' parameter:'%A' deleteInput:'%A'" (Nice.str curveId) parameter deleteInput
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(curveId)
        let rc = resizeArray { for crv in newcurves -> State.Doc.Objects.AddCurve(crv, rhobj.Attributes) }
        if deleteInput then
            State.Doc.Objects.Delete(curveId, quiet=true)|> ignore
        State.Doc.Views.Redraw()
        rc


    ///<summary>Trims a Curve by removing portions of the Curve outside a specified interval.</summary>
    ///<param name="curveId">(Guid) The Curve to trim</param>
    ///<param name="interval">(float * float) Two numbers identifying the interval to keep. Portions of
    ///    the Curve before domain[0] and after domain[1] will be removed. If the
    ///    input Curve is open, the interval must be increasing. If the input
    ///    Curve is closed and the interval is decreasing, then the portion of
    ///    the Curve across the start and end of the Curve is returned</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>true</c>
    ///    Delete the input Curve. If omitted the input Curve is deleted</param>
    ///<returns>(Guid) identifier of the new Curve.</returns>
    static member TrimCurve(curveId:Guid, interval:float * float, [<OPT;DEF(true)>]deleteInput:bool) : Guid  =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let newcurve = curve.Trim(fst interval, snd interval)
        if isNull newcurve then  RhinoScriptingException.Raise "RhinoScriptSyntax.TrimCurve failed. curveId:'%s' interval:'%A' deleteInput:'%A'" (Nice.str curveId) interval deleteInput
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(curveId)
        let rc = State.Doc.Objects.AddCurve(newcurve, rhobj.Attributes)
        if deleteInput then
            State.Doc.Objects.Delete(curveId, quiet=true)|> ignore
        State.Doc.Views.Redraw()
        rc


    ///<summary>Changes the degree of a Curve object. For more information see the Rhino help file for the ChangeDegree command.</summary>
    ///<param name="curveId">(Guid) The object's identifier</param>
    ///<param name="degree">(int) The new degree</param>
    ///<returns>(bool) True of False indicating success or failure.</returns>
    static member ChangeCurveDegree(curveId:Guid, degree:int) : bool =
        let curve = RhinoScriptSyntax.CoerceCurve curveId
        let nc = curve.ToNurbsCurve()
        if degree > 2 && degree < 12 && curve.Degree <> degree then
            if not <| nc.IncreaseDegree(degree) then false
            else
                State.Doc.Objects.Replace(curveId, nc)
        else
            false


    ///<summary>Creates Curves between two open or closed input Curves.</summary>
    ///<param name="fromCurveId">(Guid) Identifier of the first Curve object</param>
    ///<param name="toCurveId">(Guid) Identifier of the second Curve object</param>
    ///<param name="numberOfCurves">(int) Optional, default value: <c>1</c>
    ///    The number of Curves to create. The default is 1</param>
    ///<param name="method">(int) Optional, default value: <c>0</c>
    ///    The method for refining the output Curves, where:
    ///    0: (Default) Uses the control points of the Curves for matching. So the first control point of first Curve is matched to first control point of the second Curve.
    ///    1: Refits the output Curves like using the FitCurve method. Both the input Curve and the output Curve will have the same structure. The resulting Curves are usually more complex than input unless input Curves are compatible.
    ///    2: Input Curves are divided to the specified number of points on the Curve, corresponding points define new points that output Curves go through. If you are making one tween Curve, the method essentially does the following: divides the two Curves into an equal number of points, finds the midpoint between the corresponding points on the Curves, and interpolates the tween Curve through those points</param>
    ///<param name="sampleNumber">(int) Optional, default value: <c>10</c>
    ///    The number of samples points to use if method is 2. The default is 10</param>
    ///<returns>(Guid ResizeArray) The identifiers of the new tween objects.</returns>
    static member AddTweenCurves(fromCurveId:Guid, toCurveId:Guid, [<OPT;DEF(1)>]numberOfCurves:int, [<OPT;DEF(0)>]method:int, [<OPT;DEF(10)>]sampleNumber:int) : Guid ResizeArray =
        let curve0 = RhinoScriptSyntax.CoerceCurve fromCurveId
        let curve1 = RhinoScriptSyntax.CoerceCurve toCurveId
        let mutable outCurves = Array.empty
        let tolerance = State.Doc.ModelAbsoluteTolerance
        if method = 0 then
            outCurves <- Curve.CreateTweenCurves(curve0, curve1, numberOfCurves, tolerance)
            outCurves <- Curve.CreateTweenCurvesWithMatching(curve0, curve1, numberOfCurves, tolerance)
        elif method = 2 then
            outCurves <- Curve.CreateTweenCurvesWithSampling(curve0, curve1, numberOfCurves, sampleNumber, tolerance)
        else RhinoScriptingException.Raise "RhinoScriptSyntax.AddTweenCurves Method must be 0, 1, or 2.  fromCurveId:'%s' toCurveId:'%s' numberOfCurves:'%A' method:'%A' sampleNumber:'%A'"  (Nice.str fromCurveId) (Nice.str toCurveId) numberOfCurves method sampleNumber
        let curves = ResizeArray()
        if notNull outCurves then
            for curve in outCurves do
                if notNull curve && curve.IsValid then
                    let rc = State.Doc.Objects.AddCurve(curve)
                    //curve.Dispose()
                    if rc = Guid.Empty then  RhinoScriptingException.Raise "RhinoScriptSyntax.AddTweenCurves: Unable to add curve to document.  fromCurveId:'%s' toCurveId:'%s' numberOfCurves:'%A' method:'%A' sampleNumber:'%A'" (Nice.str fromCurveId) (Nice.str toCurveId) numberOfCurves method sampleNumber
                    curves.Add(rc)
            State.Doc.Views.Redraw()
        curves


    //---End of header marker: don't change: {@$%^&*()*&^%$@}



    ///<summary>Adds an aligned dimension object to the document. An aligned dimension
    ///    is a linear dimension lined up with two points.</summary>
    ///<param name="startPoint">(Point3d) First point of dimension</param>
    ///<param name="endPoint">(Point3d) Second point of dimension</param>
    ///<param name="pointOnDimensionLine">(Point3d) Location point of dimension line</param>
    ///<param name="style">(string) Optional, default value: <c>""</c> Name of dimension style</param>
    ///<returns>(Guid) identifier of new dimension.</returns>
    static member AddAlignedDimension(  startPoint:Point3d,
                                        endPoint:Point3d,
                                        pointOnDimensionLine:Point3d,  // TODO allow Point3d.Unset an then draw dim in XY plane
                                        [<OPT;DEF("")>]style:string) : Guid =
        let plane = Geometry.Plane(startPoint, endPoint, pointOnDimensionLine)
        if not plane.IsValid then RhinoScriptingException.Raise "RhinoScriptSyntax.AddAlignedDimension failed to create Plane.  startPoint:'%O' endPoint:'%O' pointOnDimensionLine:'%O'" startPoint endPoint pointOnDimensionLine
        let _, s, t = plane.ClosestParameter(startPoint)
        let start2 = Point2d(s, t)
        let _, s, t = plane.ClosestParameter(endPoint)
        let ende2 = Point2d(s, t)
        let _, s, t = plane.ClosestParameter(pointOnDimensionLine)
        let onpoint2 = Point2d(s, t)
        let ldim = new LinearDimension(plane, start2, ende2, onpoint2)
        if isNull ldim then  RhinoScriptingException.Raise "RhinoScriptSyntax.AddAlignedDimension failed.startPoint:'%O' endPoint:'%O' pointOnDimensionLine:'%O' style:'%s'" startPoint endPoint pointOnDimensionLine style
        ldim.Aligned <- true
        if style <> "" then
            let ds = State.Doc.DimStyles.FindName(style)
            if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.AddAlignedDimension, style not found.  startPoint:'%O' endPoint:'%O' pointOnDimensionLine:'%O' style:'%s'" startPoint endPoint pointOnDimensionLine style
            ldim.DimensionStyleId <- ds.Id
        let rc = State.Doc.Objects.AddLinearDimension(ldim)
        if rc = Guid.Empty then  RhinoScriptingException.Raise "RhinoScriptSyntax.AddAlignedDimension: Unable to add dimension to document. startPoint:'%O' endPoint:'%O' pointOnDimensionLine:'%O' style:'%s'" startPoint endPoint pointOnDimensionLine style
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds a new dimension style to the document. The new dimension style will
    ///    be initialized with the current default dimension style properties.</summary>
    ///<param name="dimStyleName">(string) Name of the new dimension style</param>
    ///<returns>(unit) void, nothing.</returns>
    static member AddDimStyle(dimStyleName:string) : unit =
        let index = State.Doc.DimStyles.Add(dimStyleName)
        if index<0 then  RhinoScriptingException.Raise "RhinoScriptSyntax.AddDimStyle failed. dimStyleName:'%A'" dimStyleName



    ///<summary>Adds a leader to the document. Leader objects are planar.
    ///    The 3D points passed will define the Plane if no Plane given.
    ///    If there are only two Points the World XY plane is used.</summary>
    ///<param name="points">(Point3d seq) List of (at least 2) 3D points</param>
    ///<param name="text">(string) Leader's text</param>
    ///<param name="plane">(Geometry.Plane) Optional, default value: <c>defined by points arg</c>
    ///    If points will be projected to this Plane</param>
    ///<returns>(Guid) identifier of the new leader.</returns>
    static member AddLeader( points:Point3d seq,
                             text:string,
                             [<OPT;DEF(Plane())>]plane:Plane) : Guid =
        let points2d = ResizeArray()
        let plane0 =
            if plane.IsValid then plane
            else
                let ps= ResizeArray(points)
                if ps.Count<2 then
                    RhinoScriptingException.Raise "RhinoScriptSyntax.AddLeader needs at least two points.  given %A, text:%s" points text
                elif ps.Count=2 then
                    let y =  ps.[1] - ps.[0]
                    if y.IsTiny(State.Doc.ModelAbsoluteTolerance*100.) then RhinoScriptingException.Raise "RhinoScriptSyntax.AddLeader two points given are identical %A, text:%s" points text
                    let pl = Plane(ps.[0], Vector3d.CrossProduct (y, Vector3d.ZAxis), y)
                    if not pl.IsValid then RhinoScriptingException.Raise "RhinoScriptSyntax.AddLeader failed to find plane from two points: %A, text:%s"  points text
                    pl
                else
                    let o = ps.GetNeg(-2)
                    let mutable x = ps.GetNeg(-1) - o
                    let mutable y = ps.[0]-ps.[1]
                    if y.Z < 0.0 then y <- -y
                    if y.Y < 0.0 then y <- -y
                    if x.X < 0.0 then x <- -x
                    let pl = Plane(o, x, y)
                    if not pl.IsValid then RhinoScriptingException.Raise "RhinoScriptSyntax.AddLeader failed to find plane from %d points: %A, text:%s" ps.Count points text
                    pl

        for point in points do
            let cprc, s, t = plane0.ClosestParameter( point )
            if not cprc then  RhinoScriptingException.Raise "RhinoScriptSyntax.AddLeader failed.  points %A, text:%s, plane %A" points text plane
            points2d.Add( Rhino.Geometry.Point2d(s, t))
        State.Doc.Objects.AddLeader(text, plane0, points2d)


    ///<summary>Adds a linear dimension to the document.</summary>
    ///<param name="startPoint">(Point3d) The origin, or first point of the dimension</param>
    ///<param name="endPoint">(Point3d) The offset, or second point of the dimension</param>
    ///<param name="pointOnDimensionLine">(Point3d) A point that lies on the dimension line</param>
    ///<param name="plane">(Plane) Optional, The Plane on which the dimension will lie. The default is World XY Plane</param>
    ///<returns>(Guid) identifier of the new object.</returns>
    static member AddLinearDimension(   startPoint:Point3d,
                                        endPoint:Point3d,
                                        pointOnDimensionLine:Point3d, // TODO allow Point3d.Unset an then draw dim in XY plane
                                        [<OPT;DEF(Plane())>] plane:Plane ) : Guid =
        let mutable plane0 = if not plane.IsValid then Plane.WorldXY else Plane(plane) // copy // TODO or fail
        plane0.Origin <- startPoint // needed ?
        // Calculate 2d dimension points
        let _, s, t = plane0.ClosestParameter(startPoint)
        let start = Point2d(s, t)
        let _, s, t = plane0.ClosestParameter(endPoint)
        let ende = Point2d(s, t)
        let _, s, t = plane0.ClosestParameter(pointOnDimensionLine)
        let onpoint = Point2d(s, t)
        // Add the dimension
        let ldim = new LinearDimension(plane0, start, ende, onpoint)
        if isNull ldim then
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddLinearDimension failed.  plane:'%A' startPoint:'%A' endPoint:'%A' pointOnDimensionLine:'%A'" plane startPoint endPoint pointOnDimensionLine
        let rc = State.Doc.Objects.AddLinearDimension(ldim)
        if rc= Guid.Empty then
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddLinearDimension: Unable to add dimension to document. plane:'%A' startPoint:'%A' endPoint:'%A' pointOnDimensionLine:'%A'" plane startPoint endPoint pointOnDimensionLine
        State.Doc.Views.Redraw()
        rc


    ///<summary>Returns the current default dimension style.</summary>
    ///<returns>(string) Name of the current dimension style.</returns>
    static member CurrentDimStyle() : string = //GET
        State.Doc.DimStyles.Current.Name

    ///<summary>Changes the current default dimension style.
    ///  Raise a RhinoScriptingException if the style does not exist.</summary>
    ///<param name="dimStyleName">(string) Name of an existing dimension style to make current</param>
    ///<returns>(unit) void, nothing.</returns>
    static member CurrentDimStyle(dimStyleName:string) : unit = //SET
        let ds = State.Doc.DimStyles.FindName(dimStyleName)
        if isNull ds  then  RhinoScriptingException.Raise "RhinoScriptSyntax.CurrentDimStyle setting failed. not found: '%s' . " dimStyleName
        if State.Doc.DimStyles.CurrentIndex <> ds.Index then // because SetCurrent returns false if it is already current
            if not <| State.Doc.DimStyles.SetCurrent(ds.Index, quiet=true) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.CurrentDimStyle setting '%s' failed." dimStyleName



    ///<summary>Removes an existing dimension style from the document. The dimension style
    ///    to be removed cannot be referenced by any dimension objects.</summary>
    ///<param name="dimStyleName">(string) The name of an unreferenced dimension style</param>
    ///<returns>(unit) void, nothing (fails on error).</returns>
    static member DeleteDimStyle(dimStyleName:string) : unit =
        let ds = State.Doc.DimStyles.FindName(dimStyleName)
        if isNull ds then
            RhinoScriptingException.Raise "RhinoScriptSyntax.DeleteDimStyle failed. dimStyleName:'%s'" dimStyleName
        let ok = State.Doc.DimStyles.Delete(ds.Index, quiet=true)
        if not ok then
            RhinoScriptingException.Raise "RhinoScriptSyntax.DeleteDimStyle failed. dimStyleName:' %s '" dimStyleName


    ///<summary>Returns the dimension style of a dimension object.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<returns>(string) The object's current dimension style name.</returns>
    static member DimensionStyle(objectId:Guid) : string = //GET
        let annotationObject = RhinoScriptSyntax.CoerceAnnotation(objectId)
        //let annotation = annotationObject.Geometry :?> AnnotationBase
        let ds = annotationObject.AnnotationGeometry.ParentDimensionStyle
        ds.Name
        // this is how Rhino Python is doing it :
        // let ds:DocObjects.DimensionStyle = annotationObject?DimensionStyle //TODO verify Duck typing works ok

    ///<summary>Modifies the dimension style of a dimension object.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<param name="dimStyleName">(string) The name of an existing dimension style</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DimensionStyle(objectId:Guid, dimStyleName:string) : unit = //SET
        let annotationObject = RhinoScriptSyntax.CoerceAnnotation(objectId)
        let ds =  State.Doc.DimStyles.FindName(dimStyleName)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimensionStyle set failed.  objectId:'%s' dimStyleName:'%s'" (Nice.str objectId) dimStyleName
        let mutable annotation = annotationObject.Geometry:?> AnnotationBase
        annotation.DimensionStyleId <- ds.Id
        annotationObject.CommitChanges() |> ignore
        State.Doc.Views.Redraw()

    ///<summary>Modifies the dimension style of multiple dimension objects.</summary>
    ///<param name="objectIds">(Guid seq) Identifier of the objects</param>
    ///<param name="dimStyleName">(string) The name of multiple existing dimension style</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DimensionStyle(objectIds:Guid seq, dimStyleName:string) : unit = //MULTISET
        let ds =  State.Doc.DimStyles.FindName(dimStyleName)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimensionStyle set failed.  objectId:'%s' dimStyleName:'%s'" (Nice.str objectIds) dimStyleName
        for objectId in objectIds do
            let annotationObject = RhinoScriptSyntax.CoerceAnnotation(objectId)
            let mutable annotation = annotationObject.Geometry:?> AnnotationBase
            annotation.DimensionStyleId <- ds.Id
            annotationObject.CommitChanges() |> ignore
        State.Doc.Views.Redraw()

    ///<summary>Returns the text displayed by a dimension object.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<returns>(string) The text displayed by a dimension object.</returns>
    static member DimensionText(objectId:Guid) : string =
        let annotationObject = RhinoScriptSyntax.CoerceAnnotation(objectId)
        annotationObject.DisplayText


    ///<summary>Returns the user text string of a dimension object. The user
    /// text is the string that gets printed when the dimension is defined.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<returns>(string) The current usertext string.</returns>
    static member DimensionUserText(objectId:Guid) : string = //GET
        let annotationObject = RhinoScriptSyntax.CoerceAnnotation(objectId)
        let geo = annotationObject.Geometry :?> AnnotationBase
        geo.PlainText

    ///<summary>Modifies the user text string of a dimension object. The user
    /// text is the string that gets printed when the dimension is defined.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<param name="usertext">(string) The new user text string value</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DimensionUserText(objectId:Guid, usertext:string) : unit = //SET
        let annotationObject = RhinoScriptSyntax.CoerceAnnotation(objectId)
        let geo = annotationObject.Geometry :?> AnnotationBase
        geo.PlainText <- usertext
        annotationObject.CommitChanges() |> ignore
        State.Doc.Views.Redraw()

    ///<summary>Modifies the user text string of multiple dimension objects. The user
    /// text is the string that gets printed when the dimension is defined.</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of the objects</param>
    ///<param name="usertext">(string) The new user text string value</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DimensionUserText(objectIds:Guid seq, usertext:string) : unit = //MULTISET
        for objectId in objectIds do
            let annotationObject = RhinoScriptSyntax.CoerceAnnotation(objectId)
            let geo = annotationObject.Geometry :?> AnnotationBase
            geo.PlainText <- usertext
            annotationObject.CommitChanges() |> ignore
        State.Doc.Views.Redraw()

    ///<summary>Returns the value of a dimension object.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<returns>(float) numeric value of the dimension.</returns>
    static member DimensionValue(objectId:Guid) : float =
        let annotationObject = RhinoScriptSyntax.CoerceAnnotation(objectId)
        let geo = annotationObject.Geometry :?> Dimension
        geo.NumericValue


    ///<summary>Returns the angle display precision of a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<returns>(int) The current angle precision.</returns>
    static member DimStyleAnglePrecision(dimStyle:string) : int = //GET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleAnglePrecision get failed. dimStyle:'%s'" dimStyle
        ds.AngleResolution

    ///<summary>Changes the angle display precision of a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<param name="precision">(int) The new angle precision value.</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DimStyleAnglePrecision(dimStyle:string, precision:int) : unit = //SET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleAnglePrecision set failed. dimStyle:'%s' precision:%d" dimStyle precision
        if precision >= 0 then
            ds.AngleResolution <- precision
            if not <| State.Doc.DimStyles.Modify(ds, ds.Id, quiet=false) then RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleAnglePrecision set failed. dimStyle:'%s' precision:%d" dimStyle precision
            State.Doc.Views.Redraw()

    ///<summary>Returns the arrow size of a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<returns>(float) The current arrow size.</returns>
    static member DimStyleArrowSize(dimStyle:string) : float = //GET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleArrowSize get failed. dimStyle:'%s'" dimStyle
        ds.ArrowLength

    ///<summary>Changes the arrow size of a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<param name="size">(float) The new arrow size</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DimStyleArrowSize(dimStyle:string, size:float) : unit = //SET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleArrowSize set failed. dimStyle:'%s' size:'%A'" dimStyle size
        if size > 0.0 then
            ds.ArrowLength <- size
            if not <| State.Doc.DimStyles.Modify(ds, ds.Id, quiet=false) then RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleArrowSize set failed. dimStyle:'%s' size: %g" dimStyle size
            State.Doc.Views.Redraw()
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleArrowSize set failed. dimStyle:'%s' size:%g" dimStyle size



    ///<summary>Returns the number of dimension styles in the document.</summary>
    ///<returns>(int) The number of dimension styles in the document.</returns>
    static member DimStyleCount() : int =
        State.Doc.DimStyles.Count


    ///<summary>Returns the extension line extension of a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<returns>(float) The current extension line extension.</returns>
    static member DimStyleExtension(dimStyle:string) : float = //GET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleExtension get failed. dimStyle:'%s'" dimStyle
        ds.ExtensionLineExtension

    ///<summary>Changes the extension line extension of a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<param name="extension">(float) The new extension line extension</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DimStyleExtension(dimStyle:string, extension:float) : unit = //SET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleExtension set failed. dimStyle:'%s' extension:'%A'" dimStyle extension
        if extension > 0.0 then
            ds.ExtensionLineExtension <- extension
            if not <| State.Doc.DimStyles.Modify(ds, ds.Id, quiet=false) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleExtension failed. dimStyle:'%s' extension:'%A'" dimStyle extension
            State.Doc.Views.Redraw()
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleExtension set failed. dimStyle:'%s' extension:'%A'" dimStyle extension



    ///<summary>Returns the font used by a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<returns>(string) The current font.</returns>
    static member DimStyleFont(dimStyle:string) : string = //GET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleFont get failed. dimStyle:'%s'" dimStyle
        ds.Font.FaceName


    ///<summary>Changes the font used by a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<param name="font">(string) The new font face name</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DimStyleFont(dimStyle:string, font:string) : unit = //SET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleFont set failed. dimStyle:'%s' font:'%A'" dimStyle font

        ds.Font <- DocObjects.Font(font) // TODO check if works OK !
        // let newIndex = State.Doc.Fonts.FindOrCreate(font, false, false) // deprecated ??
        // ds.Font <- State.Doc.Fonts.[newIndex]
        if not <| State.Doc.DimStyles.Modify(ds, ds.Id, quiet=false) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleFont set failed. dimStyle:'%s' font:'%A'" dimStyle font
        State.Doc.Views.Redraw()


    ///<summary>Gets all Available Font Face Names.</summary>
    ///<returns>(string array) array of all available font names.</returns>
    static member DimStyleAvailableFonts() : array<string> = // not part of original rhinoscriptsyntax
        DocObjects.Font.AvailableFontFaceNames()



    ///<summary>Returns the leader arrow size of a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<returns>(float) The current leader arrow size.</returns>
    static member DimStyleLeaderArrowSize(dimStyle:string) : float = //GET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleLeaderArrowSize get failed. dimStyle:'%s'" dimStyle
        ds.LeaderArrowLength

    ///<summary>Changes the leader arrow size of a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<param name="size">(float) The new leader arrow size</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DimStyleLeaderArrowSize(dimStyle:string, size:float) : unit = //SET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleLeaderArrowSize set failed. dimStyle:'%s' size:'%A'" dimStyle size
        if size > 0.0 then
            ds.LeaderArrowLength <- size
            if not <| State.Doc.DimStyles.Modify(ds, ds.Id, quiet=false) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleLeaderArrowSize set failed. dimStyle:'%s' size:'%A'" dimStyle size
            State.Doc.Views.Redraw()



    ///<summary>Returns the length factor of a dimension style. Length factor
    /// is the conversion between Rhino units and dimension units.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<returns>(float) if factor is not defined, the current length factor.</returns>
    static member DimStyleLengthFactor(dimStyle:string) : float = //GET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleLengthFactor get failed. dimStyle:'%s'" dimStyle
        ds.LengthFactor

    ///<summary>Changes the length factor of a dimension style. Length factor
    /// is the conversion between Rhino units and dimension units.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<param name="factor">(float) The new length factor</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DimStyleLengthFactor(dimStyle:string, factor:float) : unit = //SET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleLengthFactor set failed. dimStyle:'%s' factor:'%A'" dimStyle factor
        ds.LengthFactor <- factor
        if not <| State.Doc.DimStyles.Modify(ds, ds.Id, quiet=false) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleLengthFactor set failed. dimStyle:'%s' factor:'%A'" dimStyle factor
        State.Doc.Views.Redraw()



    ///<summary>Returns the linear display precision of a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<returns>(int) The current linear precision value.</returns>
    static member DimStyleLinearPrecision(dimStyle:string) : int = //GET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleLinearPrecision get failed. dimStyle:'%s'" dimStyle
        ds.LengthResolution

    ///<summary>Changes the linear display precision of a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<param name="precision">(int) The new linear precision value</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DimStyleLinearPrecision(dimStyle:string, precision:int) : unit = //SET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleLinearPrecision set failed. dimStyle:'%s' precision: %d" dimStyle precision
        if precision >= 0 then
            ds.LengthResolution <- precision
            if not <| State.Doc.DimStyles.Modify(ds, ds.Id, quiet=false) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleLinearPrecision set failed. dimStyle:'%s' precision: %d" dimStyle precision
            State.Doc.Views.Redraw()
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleLinearPrecision set failed. dimStyle:'%s' precision: %d" dimStyle precision



    ///<summary>Returns the names of all dimension styles in the document.</summary>
    ///<returns>(string ResizeArray) The names of all dimension styles in the document.</returns>
    static member DimStyleNames() : string ResizeArray =
        resizeArray {for  ds in State.Doc.DimStyles -> ds.Name }


    ///<summary>Returns the number display format of a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<returns>(int) The current display format
    ///     ModelUnits       0  Decimal current model units
    ///     Millimeters      3  Decimal Millimeters
    ///     Centimeters      4  Decimal Centimeters
    ///     Meters           5  Decimal Meters
    ///     Kilometers       6  Decimal Kilometers
    ///     InchesDecimal    7  Decimal Inches
    ///     InchesFractional 1  Fractional Inches ( 1.75 inches displays as 1-3/4 )
    ///     FeetDecimal      8  Decimal Feet
    ///     FeetAndInches    2  Feet and Inches ( 14.75 inches displays as 1'-2-3/4" )
    ///     Miles            9  Decimal Miles.</returns>
    static member DimStyleNumberFormat(dimStyle:string) : int = //GET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleNumberFormat get failed. dimStyle:'%s'" dimStyle
        int ds.DimensionLengthDisplay


    ///<summary>Changes the number display format of a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<param name="format">(int) The new number format
    ///     ModelUnits       0  Decimal current model units
    ///     Millimeters      3  Decimal Millimeters
    ///     Centimeters      4  Decimal Centimeters
    ///     Meters           5  Decimal Meters
    ///     Kilometers       6  Decimal Kilometers
    ///     InchesDecimal    7  Decimal Inches
    ///     InchesFractional 1  Fractional Inches ( 1.75 inches displays as 1-3/4 )
    ///     FeetDecimal      8  Decimal Feet
    ///     FeetAndInches    2  Feet and Inches ( 14.75 inches displays as 1'-2-3/4" )
    ///     Miles            9  Decimal Miles</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DimStyleNumberFormat(dimStyle:string, format:int) : unit = //SET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleNumberFormat set failed. dimStyle:'%s' format:'%A'" dimStyle format
        if  format<0 || format>9 then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleNumberFormat set failed. dimStyle:'%s' format:'%A'" dimStyle format
        ds.DimensionLengthDisplay <- LanguagePrimitives.EnumOfValue format
        if not <| State.Doc.DimStyles.Modify(ds, ds.Id, quiet=false) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleNumberFormat set failed. dimStyle:'%s' format:'%A'" dimStyle format
        State.Doc.Views.Redraw()


    ///<summary>Returns the extension line offset of a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<returns>(float) The current extension line offset.</returns>
    static member DimStyleOffset(dimStyle:string) : float = //GET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleOffset get failed. dimStyle:'%s'" dimStyle
        ds.ExtensionLineOffset

    ///<summary>Changes the extension line offset of a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<param name="offset">(float) The new extension line offset</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DimStyleOffset(dimStyle:string, offset:float) : unit = //SET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleOffset set failed. dimStyle:'%s' offset:'%A'" dimStyle offset
        ds.ExtensionLineOffset <- offset
        if not <| State.Doc.DimStyles.Modify(ds, ds.Id, quiet=false) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleOffset set failed. dimStyle:'%s' offset:'%A'" dimStyle offset
        State.Doc.Views.Redraw()



    ///<summary>Returns the prefix of a dimension style - the text to
    /// prefix to the dimension text.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimStyle</param>
    ///<returns>(string) The current prefix.</returns>
    static member DimStylePrefix(dimStyle:string) : string = //GET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStylePrefix get failed. dimStyle:'%s'" dimStyle
        ds.Prefix

    ///<summary>Changes the prefix of a dimension style - the text to
    /// prefix to the dimension text.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimStyle</param>
    ///<param name="prefix">(string) The new prefix</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DimStylePrefix(dimStyle:string, prefix:string) : unit = //SET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStylePrefix set failed. dimStyle:'%s' prefix:'%A'" dimStyle prefix
        ds.Prefix <- prefix
        if not <| State.Doc.DimStyles.Modify(ds, ds.Id, quiet=false) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.DimStylePrefix set failed. dimStyle:'%s' prefix:'%A'" dimStyle prefix
        State.Doc.Views.Redraw()


    ///<summary>Returns the scale of a dimension style .</summary>
    ///<param name="dimStyle">(string) The name of an existing dimStyle</param>
    ///<returns>(string) The current suffix.</returns>
    static member DimStyleScale(dimStyle:string) : float = //GET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleScale get failed. dimStyle:'%s'" dimStyle
        ds.DimensionScale

    ///<summary>Changes the scale of a dimension style .</summary>
    ///<param name="dimStyle">(string) The name of an existing dimStyle</param>
    ///<param name="scale">(float) The new scale</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DimStyleScale(dimStyle:string, scale:float) : unit = //SET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleScale set failed. dimStyle:'%s' scale:'%A'" dimStyle scale
        ds.DimensionScale <- scale
        if not <| State.Doc.DimStyles.Modify(ds, ds.Id, quiet=false) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleScale set failed. dimStyle:'%s' scale:'%A'" dimStyle scale
        State.Doc.Views.Redraw()


    ///<summary>Returns the suffix of a dimension style - the text to
    /// append to the dimension text.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimStyle</param>
    ///<returns>(string) The current suffix.</returns>
    static member DimStyleSuffix(dimStyle:string) : string = //GET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleSuffix get failed. dimStyle:'%s'" dimStyle
        ds.Suffix

    ///<summary>Changes the suffix of a dimension style - the text to
    /// append to the dimension text.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimStyle</param>
    ///<param name="suffix">(string) The new suffix</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DimStyleSuffix(dimStyle:string, suffix:string) : unit = //SET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleSuffix set failed. dimStyle:'%s' suffix:'%A'" dimStyle suffix
        ds.Suffix <- suffix
        if not <| State.Doc.DimStyles.Modify(ds, ds.Id, quiet=false) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleSuffix set failed. dimStyle:'%s' suffix:'%A'" dimStyle suffix
        State.Doc.Views.Redraw()



    ///<summary>Returns the text alignment mode of a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<returns>(int) The current text alignment
    ///     Top                   0   Attach to top of an 'I' on the first line. (Independent of glyphs being displayed.)
    ///     MiddleOfTop           1   Attach to middle of an 'I' on the first line. (Independent of glyphs being displayed.)
    ///     BottomOfTop           2   Attach to baseline of first line. (Independent of glyphs being displayed.)
    ///     Middle                3   Attach to middle of text vertical advance. (Independent of glyphs being displayed.)
    ///     MiddleOfBottom        4   Attach to middle of an 'I' on the last line. (Independent of glyphs being displayed.)
    ///     Bottom                5   Attach to the baseline of the last line. (Independent of glyphs being displayed.)
    ///     BottomOfBoundingBox   6   Attach to the bottom of the bounding box of the visible glyphs.</returns>
    static member DimStyleTextAlignment(dimStyle:string) : int = //GET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleTextAlignment get failed. dimStyle:'%s'" dimStyle
        int ds.TextVerticalAlignment

    ///<summary>Changes the text alignment mode of a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<param name="alignment">(int) The new text alignment
    ///     Top                   0   Attach to top of an 'I' on the first line. (Independent of glyphs being displayed.)
    ///     MiddleOfTop           1   Attach to middle of an 'I' on the first line. (Independent of glyphs being displayed.)
    ///     BottomOfTop           2   Attach to baseline of first line. (Independent of glyphs being displayed.)
    ///     Middle                3   Attach to middle of text vertical advance. (Independent of glyphs being displayed.)
    ///     MiddleOfBottom        4   Attach to middle of an 'I' on the last line. (Independent of glyphs being displayed.)
    ///     Bottom                5   Attach to the baseline of the last line. (Independent of glyphs being displayed.)
    ///     BottomOfBoundingBox   6   Attach to the bottom of the bounding box of the visible glyphs.</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DimStyleTextAlignment(dimStyle:string, alignment:int) : unit = //SET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleTextAlignment not found. dimStyle:'%s' alignment:'%A'" dimStyle alignment
        elif alignment<0 || alignment>6 then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleTextAlignment set failed. dimStyle:'%s' alignment:'%A'" dimStyle alignment
        ds.TextVerticalAlignment <- LanguagePrimitives.EnumOfValue (byte alignment)
        if not <| State.Doc.DimStyles.Modify(ds, ds.Id, quiet=false) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleTextAlignment set failed. dimStyle:'%s' alignment:'%A'" dimStyle alignment
        State.Doc.Views.Redraw()


    ///<summary>Returns the text gap used by a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<returns>(float) The current text gap.</returns>
    static member DimStyleTextGap(dimStyle:string) : float = //GET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleTextGap get failed. dimStyle:'%s'" dimStyle
        ds.TextGap

    ///<summary>Changes the text gap used by a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<param name="gap">(float) The new text gap</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DimStyleTextGap(dimStyle:string, gap:float) : unit = //SET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleTextGap set failed. dimStyle:'%s' gap:'%A'" dimStyle gap
        if gap >= 0.0 then
            ds.TextGap <- gap
            if not <| State.Doc.DimStyles.Modify(ds, ds.Id, quiet=false) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleTextGap set failed. dimStyle:'%s' gap:'%A'" dimStyle gap
            State.Doc.Views.Redraw()
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleTextGap set failed. dimStyle:'%s' gap:'%A'" dimStyle gap



    ///<summary>Returns the text height used by a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<returns>(float) The current text height.</returns>
    static member DimStyleTextHeight(dimStyle:string) : float = //GET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleTextHeight get failed. dimStyle:'%s'" dimStyle
        ds.TextHeight

    ///<summary>Changes the text height used by a dimension style.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<param name="height">(float) The new text height</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DimStyleTextHeight(dimStyle:string, height:float) : unit = //SET
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleTextHeight set failed. dimStyle:'%s' height:'%A'" dimStyle height
        if height>0.0 then
            ds.TextHeight <- height
            if not <| State.Doc.DimStyles.Modify(ds, ds.Id, quiet=false) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleTextHeight set failed. dimStyle:'%s' height:'%A'" dimStyle height
            State.Doc.Views.Redraw()
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.DimStyleTextHeight set failed. dimStyle:'%s' height:'%A'" dimStyle height


    ///<summary>Checks if  an object is an aligned dimension object. Returns false for any other Rhino object.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True or False.</returns>
    static member IsAlignedDimension(objectId:Guid) : bool =
        match RhinoScriptSyntax.CoerceGeometry objectId with
        | :? LinearDimension as g -> g.Aligned
        | _ -> false


    ///<summary>Checks if  an object is an angular dimension object. Returns false for any other Rhino object.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True or False.</returns>
    static member IsAngularDimension(objectId:Guid) : bool =
        match RhinoScriptSyntax.CoerceGeometry objectId with
        | :? AngularDimension -> true
        | _ -> false


    ///<summary>Checks if  an object is a diameter dimension object. Returns false for any other Rhino object.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True or False.</returns>
    static member IsDiameterDimension(objectId:Guid) : bool =
        match RhinoScriptSyntax.CoerceGeometry objectId with
        | :? RadialDimension as g -> g.IsDiameterDimension
        | _ -> false


    ///<summary>Checks if  an object is a dimension object. Returns false for any other Rhino object.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True or False.</returns>
    static member IsDimension(objectId:Guid) : bool =
        match RhinoScriptSyntax.CoerceGeometry objectId with
        | :? AnnotationBase  -> true
        | _ -> false


    ///<summary>Checks if  the existence of a dimension style in the document. Returns false for any other Rhino object.</summary>
    ///<param name="dimStyle">(string) The name of a dimStyle to test for</param>
    ///<returns>(bool) True or False.</returns>
    static member IsDimStyle(dimStyle:string) : bool =
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        notNull ds


    ///<summary>Checks if  that an existing dimension style is from a reference file. Returns false for any other Rhino object.</summary>
    ///<param name="dimStyle">(string) The name of an existing dimension style</param>
    ///<returns>(bool) True or False.</returns>
    static member IsDimStyleReference(dimStyle:string) : bool =
        let ds = State.Doc.DimStyles.FindName(dimStyle)
        if isNull ds then false
        else ds.IsReference


    ///<summary>Checks if  an object is a dimension leader object. Returns false for any other Rhino object.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True or False.</returns>
    static member IsLeader(objectId:Guid) : bool =
            match RhinoScriptSyntax.CoerceGeometry objectId with
            | :? Leader  -> true
            | _ -> false


    ///<summary>Checks if  an object is a linear dimension object. Returns false for any other Rhino object.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True or False.</returns>
    static member IsLinearDimension(objectId:Guid) : bool =
            match RhinoScriptSyntax.CoerceGeometry objectId with
            | :? LinearDimension  -> true
            | _ -> false


    ///<summary>Checks if  an object is an ordinate dimension object. Returns false for any other Rhino object.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True or False.</returns>
    static member IsOrdinateDimension(objectId:Guid) : bool =
            match RhinoScriptSyntax.CoerceGeometry objectId with
            | :? OrdinateDimension  -> true
            | _ -> false


    ///<summary>Checks if  an object is a radial dimension object. Returns false for any other Rhino object.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True or False.</returns>
    static member IsRadialDimension(objectId:Guid) : bool =
            match RhinoScriptSyntax.CoerceGeometry objectId with
            | :? RadialDimension  -> true
            | _ -> false


    ///<summary>Returns the text string of a dimension leader object.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(string) The current text string.</returns>
    static member LeaderText(objectId:Guid) : string = //GET
            match RhinoScriptSyntax.CoerceGeometry objectId with
            | :? Leader ->
                let annotationObject = RhinoScriptSyntax.CoerceAnnotation(objectId)
                annotationObject.DisplayText
            | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.LeaderText get failed.  objectId:'%s'" (Nice.str objectId)

    ///<summary>Modifies the text string of a dimension leader object.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<param name="text">(string) The new text string</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LeaderText(objectId:Guid, text:string) : unit = //SET
            match RhinoScriptSyntax.CoerceGeometry objectId with
            | :? Leader as g ->
                let annotationObject = RhinoScriptSyntax.CoerceAnnotation(objectId)
                g.PlainText <- text               // TODO or use rich text?
                if not <| State.Doc.Objects.Replace(objectId,g) then RhinoScriptingException.Raise "RhinoScriptSyntax.LeaderText: Objects.Replace(objectId,g) get failed. objectId:'%s'" (Nice.str objectId)
                annotationObject.CommitChanges() |> ignore
                State.Doc.Views.Redraw()
            | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.LeaderText set failed for  %s"  (Nice.str objectId)

    ///<summary>Modifies the text string of multiple dimension leader objects.</summary>
    ///<param name="objectIds">(Guid seq) The objects's identifiers</param>
    ///<param name="text">(string) The new text string</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LeaderText(objectIds:Guid seq, text:string) : unit = //MULTISET
        for objectId in objectIds do
            RhinoScriptSyntax.LeaderText(objectId,text)

    ///<summary>Renames an existing dimension style.</summary>
    ///<param name="oldStyle">(string) The name of an existing dimension style</param>
    ///<param name="newStyle">(string) The new dimension style name</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RenameDimStyle(oldStyle:string, newStyle:string) : unit =
        let mutable ds = State.Doc.DimStyles.FindName(oldStyle)
        if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.RenameDimStyle failed.  oldStyle:'%s' newStyle:'%s'" oldStyle newStyle
        ds.Name <- newStyle
        if not <| State.Doc.DimStyles.Modify(ds, ds.Id, quiet=false) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.RenameDimStyle failed.  oldStyle:'%s' newStyle:'%s'" oldStyle newStyle



    //---End of header marker: don't change: {@$%^&*()*&^%$@}


    ///<summary>Create a bitmap preview image of the current model.</summary>
    ///<param name="fileName">(string) Name of the bitmap file to create</param>
    ///<param name="view">(string) Optional, Title of the view. If omitted, the active view is used</param>
    ///<param name="width">(int) Optional, default value: <c>0</c>
    /// integer that specifies width of the bitmap in pixel. if only width given height will be scaled to keep screen ratio</param>
    ///<param name="height">(int) Optional, default value: <c>0</c>
    /// integer that specifies height of the bitmap in pixel. if only height given width will be scaled to keep screen ratio</param>
    ///<param name="flags">(int) Optional, default value: <c>0</c>
    ///    Bitmap creation flags. Can be the combination of:
    ///    1 = honor object highlighting
    ///    2 = draw construction Plane
    ///    4 = use ghosted shading</param>
    ///<param name="wireframe">(bool) Optional, default value: <c>false</c>
    ///    If True then a wire-frame preview image. If False,
    ///    a rendered image will be created</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member CreatePreviewImage(   fileName:string,
                                        [<OPT;DEF("")>]view:string,
                                        [<OPT;DEF(0)>]width:int,
                                        [<OPT;DEF(0)>]height:int,
                                        [<OPT;DEF(0)>]flags:int,
                                        [<OPT;DEF(false)>]wireframe:bool) : bool =
        let rhview = RhinoScriptSyntax.CoerceView(view)
        let inline  ( ./. ) (i:int) (j:int) = (float(i)) / (float(j))
        let inline  ( *. ) ( i:int) (f:float) = int(round(float(i) * f))
        let rhsize =
            match width, height with
            | 0, 0 -> rhview.ClientRectangle.Size
            | x, 0 ->
                let sc = x ./. rhview.ClientRectangle.Size.Width
                Drawing.Size(x, rhview.ClientRectangle.Size.Height *. sc)
            | 0, y ->
                let sc = y ./. rhview.ClientRectangle.Size.Height
                Drawing.Size(rhview.ClientRectangle.Size.Width *. sc , y)
            | x, y -> Drawing.Size(x, y)
        let ignoreHighlights =  (flags &&& 1) <> 1
        let drawcplane =        (flags &&& 2)  = 2
        let useghostedshading = (flags &&& 4)  = 4
        if wireframe then
            rhview.CreateWireframePreviewImage(fileName, rhsize, ignoreHighlights, drawcplane)
        else
            rhview.CreateShadedPreviewImage(fileName, rhsize, ignoreHighlights, drawcplane, useghostedshading)


    ///<summary>Returns the document's modified flag. This flag indicates whether
    /// or not any changes to the current document have been made. NOTE: setting the
    /// document modified flag to False will prevent the "Do you want to save this
    /// file..." from displaying when you close Rhino.</summary>
    ///<returns>(bool) if no modified state is specified, the current modified state.</returns>
    static member DocumentModified() : bool = //GET
        State.Doc.Modified

    ///<summary>Sets the document's modified flag. This flag indicates whether
    /// or not any changes to the current document have been made. NOTE: setting the
    /// document modified flag to False will prevent the "Do you want to save this
    /// file..." from displaying when you close Rhino.</summary>
    ///<param name="modified">(bool) The modified state, either True or False</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DocumentModified(modified:bool) : unit = //SET
        State.Doc.Modified <- modified



    ///<summary>Returns the name of the currently loaded Rhino document (3dm file).</summary>
    ///<returns>(string) The name of the currently loaded Rhino document (3dm file).</returns>
    static member DocumentName() : string =
        State.Doc.Name |? ""

    ///<summary>Returns full path of the currently loaded Rhino document including the file name (3dm file).</summary>
    ///<returns>(string) The path of the currently loaded Rhino document  including the file name(3dm file).</returns>
    static member DocumentPath() : string =
        let p = State.Doc.Path
        if isNull p then ""
        else p
            //let slash = string Path.DirectorySeparatorChar
            //if p.EndsWith slash then p
            //else p + slash // add \ or / at the ende to be consistent with RhinoScript


    ///<summary>Enables or disables screen redrawing.
    ///  All UI interacting functions (such as rs.GetObject) of Rhino.Scripting
    ///  will automatically enable redraw if needed
    ///  and afterwards disable it again if it was disabled before.
    ///  At the end of a script run in Fesh Editor Redraw will be automatically enabled again.</summary>
    ///<param name="enable">(bool) Optional, default value: <c>true</c>
    ///    True to enable, False to disable</param>
    ///<returns>(unit) void, nothing.</returns>
    static member EnableRedraw([<OPT;DEF(true)>]enable:bool) : unit =
        State.Doc.Views.RedrawEnabled <- enable

    ///<summary>Disables screen redrawing.
    ///  All UI interacting functions (such as rs.GetObject) of Rhino.Scripting
    ///  will automatically enable redraw if needed
    ///  and afterwards disable it again if it was disabled before.
    ///  At the end of a script run in Fesh Editor Redraw will be automatically enabled again.</summary>
    ///<returns>(unit) void, nothing.</returns>
    static member DisableRedraw() : unit =
        State.Doc.Views.RedrawEnabled <- false


    ///<summary>Extracts the bitmap preview image from the specified model (.3dm).</summary>
    ///<param name="fileName">(string) Name of the bitmap file to create. The extension of
    ///    the fileName controls the format of the bitmap file created.
    ///    (.bmp, .tga, .jpg, .jpeg, .pcx, .png, .tif, .tiff)</param>
    ///<param name="modelName">(string) Optional, The model (.3dm) from which to extract the
    ///    preview image. If omitted, the currently loaded model is used</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ExtractPreviewImage(fileName:string, [<OPT;DEF(null:string)>]modelName:string) : unit =
        let bmp =
            if notNull modelName  then
                if notNull State.Doc.Path then RhinoDoc.ExtractPreviewImage(State.Doc.Path) // TODO test this works ok
                else RhinoScriptingException.Raise "RhinoScriptSyntax.ExtractPreviewImage failed on unsaved file"
            else
                RhinoDoc.ExtractPreviewImage(modelName)
        bmp.Save(fileName)


    ///<summary>Checks if the current document has been modified in some way.</summary>
    ///<returns>(bool) True or False.</returns>
    static member IsDocumentModified() : bool =
        State.Doc.Modified


    ///<summary>Returns the document's notes. Notes are generally created
    /// using Rhino's Notes command.</summary>
    ///<returns>(string) The current notes.</returns>
    static member Notes() : string = //GET
        State.Doc.Notes

    ///<summary>Sets the document's notes. Notes are generally created
    /// using Rhino's Notes command.</summary>
    ///<param name="newNotes">(string) New notes to set</param>
    ///<returns>(unit) void, nothing.</returns>
    static member Notes(newNotes:string) : unit = //SET
        State.Doc.Notes <- newNotes



    ///<summary>Returns the file version of the current document. Use this function to
    ///    determine which version of Rhino last saved the document. Note, this
    ///    function will not return values from referenced or merged files.</summary>
    ///<returns>(int) The file version of the current document.</returns>
    static member ReadFileVersion() : int =
        State.Doc.ReadFileVersion()


    ///<summary>Redraws all views.</summary>
    ///<returns>(unit).</returns>
    static member Redraw() : unit =
        let old = State.Doc.Views.RedrawEnabled
        State.Doc.Views.RedrawEnabled <- true
        State.Doc.Views.Redraw()
        RhinoApp.Wait()
        State.Doc.Views.RedrawEnabled <- old


    ///<summary>Returns render antialiasing style.</summary>
    ///<returns>(int) The current antialiasing style (0 = none, 1 = normal, 2 = best).</returns>
    static member RenderAntialias() : int = //GET
        int(State.Doc.RenderSettings.AntialiasLevel) // TODO check

    ///<summary>Sets render antialiasing style.</summary>
    ///<param name="style">(int) Level of antialiasing (0 = none, 1 = normal, 2 = best)</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RenderAntialias(style:int) : unit = //SET
        if style = 0 || style = 1 || style = 2 then
            let settings = State.Doc.RenderSettings
            settings.AntialiasLevel <- EnumOfValue (style)
            State.Doc.RenderSettings <- settings


    ///<summary>Returns the render ambient light or background color.</summary>
    ///<param name="item">(int)
    ///   0 = ambient light color,
    ///   1 = background color</param>
    ///<returns>(Drawing.Color) The current item color.</returns>
    static member RenderColor(item:int) : Drawing.Color = //GET
        if item<>0 && item<>1 then  RhinoScriptingException.Raise "RhinoScriptSyntax.RenderColor Item must be 0 or 1.  item:'%A'" item
        if item = 0 then  State.Doc.RenderSettings.AmbientLight
        else State.Doc.RenderSettings.BackgroundColorTop

    ///<summary>Sets the render ambient light or background color.</summary>
    ///<param name="item">(int)
    ///    0 = ambient light color,
    ///    1 = background color</param>
    ///<param name="color">(Drawing.Color) The new color value</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RenderColor(item:int, color:Drawing.Color) : unit = //SET
        if item<>0 && item<>1 then  RhinoScriptingException.Raise "RhinoScriptSyntax.RenderColor Item must be 0 || 1.  item:'%A' color:'%A'" item color
        let settings = State.Doc.RenderSettings
        if item = 0 then  settings.AmbientLight <- color
        else            settings.BackgroundColorTop <- color
        State.Doc.RenderSettings <- settings
        State.Doc.Views.Redraw()


    ///<summary>Returns the render resolution.</summary>
    ///<returns>(int * int) The current resolution width, height.</returns>
    static member RenderResolution() : int * int = //GET
        let rc = State.Doc.RenderSettings.ImageSize
        rc.Width, rc.Height

    ///<summary>Sets the render resolution.</summary>
    ///<param name="width">(int) width and height of render</param>
    ///<param name="height">(int) height of render</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RenderResolution(width:int, height:int) : unit = //SET
            let settings = State.Doc.RenderSettings
            settings.ImageSize <- Drawing.Size(width , height)
            State.Doc.RenderSettings <- settings



    ///<summary>Returns the render Mesh density property of the active document.
    /// For more information on render Meshes, see the Document Properties: Mesh topic in the Rhino help file.</summary>
    ///<returns>(float) The current render Mesh density.</returns>
    static member RenderMeshDensity() : float = //GET
        let current = State.Doc.GetMeshingParameters(State.Doc.MeshingParameterStyle)
        current.RelativeTolerance

    ///<summary>Sets the render Mesh density property of the active document.
    /// For more information on render Meshes, see the Document Properties: Mesh topic in the Rhino help file.</summary>
    ///<param name="density">(float) The new render Mesh density, which is a number between 0.0 and 1.0</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RenderMeshDensity(density:float) : unit = //SET
        let current = State.Doc.GetMeshingParameters(State.Doc.MeshingParameterStyle)
        if RhinoMath.Clamp(density, 0.0, 1.0) = density then
            current.RelativeTolerance <- density
            State.Doc.SetCustomMeshingParameters(current)
            State.Doc.MeshingParameterStyle <- Rhino.Geometry.MeshingParameterStyle.Custom


    ///<summary>Returns the render Mesh maximum angle property of the active document.
    /// For more information on render Meshes, see the Document Properties: Mesh topic in the Rhino help file.</summary>
    ///<returns>(float) The current maximum angle.</returns>
    static member RenderMeshMaxAngle() : float = //GET
        let current = State.Doc.GetMeshingParameters(State.Doc.MeshingParameterStyle)
        toDegrees(current.RefineAngle)

    ///<summary>Sets the render Mesh maximum angle property of the active document.
    /// For more information on render Meshes, see the Document Properties: Mesh topic in the Rhino help file.</summary>
    ///<param name="angleDegrees">(float) The new maximum angle, which is a positive number in degrees</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RenderMeshMaxAngle(angleDegrees:float) : unit = //SET
        let current = State.Doc.GetMeshingParameters(State.Doc.MeshingParameterStyle)
        if angleDegrees > 0. then
                current.RefineAngle <- toRadians(angleDegrees)
                State.Doc.SetCustomMeshingParameters(current)
                State.Doc.MeshingParameterStyle <- Rhino.Geometry.MeshingParameterStyle.Custom


    ///<summary>Returns the render Mesh maximum aspect ratio property of the active document.
    /// For more information on render Meshes, see the Document Properties: Mesh topic in the Rhino help file.</summary>
    ///<returns>(float) The current render Mesh maximum aspect ratio.</returns>
    static member RenderMeshMaxAspectRatio() : float = //GET
        let current = State.Doc.GetMeshingParameters(State.Doc.MeshingParameterStyle)
        let rc = current.GridAspectRatio
        rc

    ///<summary>Sets the render Mesh maximum aspect ratio property of the active document.
    /// For more information on render Meshes, see the Document Properties: Mesh topic in the Rhino help file.</summary>
    ///<param name="ratio">(float) The render Mesh maximum aspect ratio. The suggested range, when not zero, is from 1 to 100</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RenderMeshMaxAspectRatio(ratio:float) : unit = //SET
        let current = State.Doc.GetMeshingParameters(State.Doc.MeshingParameterStyle)
        if ratio <> 0.0 then
            current.GridAspectRatio <- ratio
            State.Doc.SetCustomMeshingParameters(current)
            State.Doc.MeshingParameterStyle <- Rhino.Geometry.MeshingParameterStyle.Custom


    ///<summary>Returns the render Mesh maximum distance, edge to Surface parameter of the active document.
    /// For more information on render Meshes, see the Document Properties: Mesh topic in the Rhino help file.</summary>
    ///<returns>(float) The current render Mesh maximum distance, edge to Surface.</returns>
    static member RenderMeshMaxDistEdgeToSrf() : float = //GET
        let current = State.Doc.GetMeshingParameters(State.Doc.MeshingParameterStyle)
        let rc = current.Tolerance
        rc

    ///<summary>Sets the render Mesh maximum distance, edge to Surface parameter of the active document.
    /// For more information on render Meshes, see the Document Properties: Mesh topic in the Rhino help file.</summary>
    ///<param name="distance">(float) The render Mesh maximum distance, edge to Surface</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RenderMeshMaxDistEdgeToSrf(distance:float) : unit = //SET
        let current = State.Doc.GetMeshingParameters(State.Doc.MeshingParameterStyle)
        if distance > 0. then
            current.Tolerance <- distance
            State.Doc.SetCustomMeshingParameters(current)
            State.Doc.MeshingParameterStyle <- Rhino.Geometry.MeshingParameterStyle.Custom


    ///<summary>Returns the render Mesh maximum edge length parameter of the active document.
    /// For more information on render Meshes, see the Document Properties: Mesh topic in the Rhino help file.</summary>
    ///<returns>(float) The current render Mesh maximum edge length.</returns>
    static member RenderMeshMaxEdgeLength() : float = //GET
        let current = State.Doc.GetMeshingParameters(State.Doc.MeshingParameterStyle)
        let rc = current.MaximumEdgeLength
        rc

    ///<summary>Sets the render Mesh maximum edge length parameter of the active document.
    /// For more information on render Meshes, see the Document Properties: Mesh topic in the Rhino help file.</summary>
    ///<param name="distance">(float) The render Mesh maximum edge length</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RenderMeshMaxEdgeLength(distance:float) : unit = //SET
        let current = State.Doc.GetMeshingParameters(State.Doc.MeshingParameterStyle)
        if distance > 0.0 then
            current.MaximumEdgeLength <- distance
            State.Doc.SetCustomMeshingParameters(current)
            State.Doc.MeshingParameterStyle <- Rhino.Geometry.MeshingParameterStyle.Custom


    ///<summary>Returns the render Mesh minimum edge length parameter of the active document.
    /// For more information on render Meshes, see the Document Properties: Mesh topic in the Rhino help file.</summary>
    ///<returns>(float) The current render Mesh minimum edge length.</returns>
    static member RenderMeshMinEdgeLength() : float = //GET
        let current = State.Doc.GetMeshingParameters(State.Doc.MeshingParameterStyle)
        let rc = current.MinimumEdgeLength
        rc

    ///<summary>Sets the render Mesh minimum edge length parameter of the active document.
    /// For more information on render Meshes, see the Document Properties: Mesh topic in the Rhino help file.</summary>
    ///<param name="distance">(float) The render Mesh minimum edge length</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RenderMeshMinEdgeLength(distance:float) : unit = //SET
        let current = State.Doc.GetMeshingParameters(State.Doc.MeshingParameterStyle)
        if distance > 0.0 then
            current.MinimumEdgeLength <- distance
            State.Doc.SetCustomMeshingParameters(current)
            State.Doc.MeshingParameterStyle <- Rhino.Geometry.MeshingParameterStyle.Custom


    ///<summary>Returns the render Mesh minimum initial grid quads parameter of the active document.
    /// For more information on render Meshes, see the Document Properties: Mesh topic in the Rhino help file.</summary>
    ///<returns>(int) The current render Mesh minimum initial grid quads.</returns>
    static member RenderMeshMinInitialGridQuads() : int = //GET
        let current = State.Doc.GetMeshingParameters(State.Doc.MeshingParameterStyle)
        current.GridMinCount


    ///<summary>Sets the render Mesh minimum initial grid quads parameter of the active document.
    /// For more information on render Meshes, see the Document Properties: Mesh topic in the Rhino help file.</summary>
    ///<param name="quads">(int) The render Mesh minimum initial grid quads. The suggested range is from 0 to 10000</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RenderMeshMinInitialGridQuads(quads:int) : unit = //SET
        let current = State.Doc.GetMeshingParameters(State.Doc.MeshingParameterStyle)
        if quads > 0 then
            current.GridMinCount <- quads
            State.Doc.SetCustomMeshingParameters(current)
            State.Doc.MeshingParameterStyle <- Rhino.Geometry.MeshingParameterStyle.Custom


    ///<summary>Returns the render Mesh quality of the active document.
    /// For more information on render Meshes, see the Document Properties: Mesh topic in the Rhino help file.</summary>
    ///<returns>(int) The current render Mesh quality .
    ///    0: Jagged and faster. Objects may look jagged, but they should shade and render relatively quickly.
    ///    1: Smooth and slower. Objects should look smooth, but they may take a very long time to shade and render.
    ///    2: Custom.</returns>
    static member RenderMeshQuality() : int = //GET
        let current = State.Doc.MeshingParameterStyle
        if current = MeshingParameterStyle.Fast then 0
        elif current = MeshingParameterStyle.Quality then 1
        elif current = MeshingParameterStyle.Custom then  2
        else -1

    ///<summary>Sets the render Mesh quality of the active document.
    /// For more information on render Meshes, see the Document Properties: Mesh topic in the Rhino help file.</summary>
    ///<param name="quality">(int) The render Mesh quality, either:
    ///    0: Jagged and faster. Objects may look jagged, but they should shade and render relatively quickly.
    ///    1: Smooth and slower. Objects should look smooth, but they may take a very long time to shade and render.
    ///    2: Custom</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RenderMeshQuality(quality:int) : unit = //SET
        let newValue =
            if quality = 0 then
                MeshingParameterStyle.Fast
            elif quality = 1 then
                MeshingParameterStyle.Quality
            elif quality = 2 then
                MeshingParameterStyle.Custom
            else
                MeshingParameterStyle.None
        State.Doc.MeshingParameterStyle <- newValue


    ///<summary>Returns the render Mesh settings of the active document.
    /// For more information on render Meshes, see the Document Properties: Mesh topic in the Rhino help file.</summary>
    ///<returns>(int) The current render Mesh settings .
    ///      0: No settings enabled.
    ///      1: Refine Mesh enabled.
    ///      2: Jagged seams enabled.
    ///      4: Simple Planes enabled.
    ///      8: Texture is packed, scaled and normalized; otherwise unpacked, unscaled and normalized.</returns>
    static member RenderMeshSettings() : int = //GET
        let current = State.Doc.GetMeshingParameters(State.Doc.MeshingParameterStyle)
        let mutable rc = 0
        if current.RefineGrid then  rc <- rc +  1
        if current.JaggedSeams then  rc <- rc +  2
        if current.SimplePlanes then  rc <- rc +  4
        rc

    ///<summary>Sets the render Mesh settings of the active document.
    /// For more information on render Meshes, see the Document Properties: Mesh topic in the Rhino help file.</summary>
    ///<param name="settings">(int) The render Mesh settings, which is a bit-coded number that allows or disallows certain features.
    ///    The bits can be added together in any combination to form a value between 0 and 7. The bit values are as follows:
    ///      0: No settings enabled.
    ///      1: Refine Mesh enabled.
    ///      2: Jagged seams enabled.
    ///      4: Simple Planes enabled.
    ///      8: Texture is packed, scaled and normalized; otherwise unpacked, unscaled and normalized</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RenderMeshSettings(settings:int) : unit = //SET
        let current = State.Doc.GetMeshingParameters(State.Doc.MeshingParameterStyle)
        current.RefineGrid <- (settings &&& 1)   <> 0
        current.JaggedSeams <- (settings &&& 2)  <> 0
        current.SimplePlanes <- (settings &&& 4) <> 0
        State.Doc.SetCustomMeshingParameters(current)
        State.Doc.MeshingParameterStyle <- Rhino.Geometry.MeshingParameterStyle.Custom


    ///<summary>Returns render settings.</summary>
    ///<returns>(int) if settings are not specified, the current render settings in bit-coded flags
    ///    0 = none,
    ///    1 = create shadows,
    ///    2 = use lights on layers that are off,
    ///    4 = render Curves and iso-curves,
    ///    8 = render dimensions and text.</returns>
    static member RenderSettings() : int = //GET
        let mutable rc = 0
        let rendersettings = State.Doc.RenderSettings
        if 0 <> rendersettings.ShadowmapLevel   then  rc <- rc + 1
        if rendersettings.UseHiddenLights       then  rc <- rc + 2
        if rendersettings.RenderCurves          then  rc <- rc + 4
        if rendersettings.RenderAnnotations     then  rc <- rc + 8
        rc

    ///<summary>Sets render settings.</summary>
    ///<param name="settings">(int) Bit-coded flags of render settings to modify.
    ///    0 = none,
    ///    1 = create shadows,
    ///    2 = use lights on layers that are off,
    ///    4 = render Curves and iso-curves,
    ///    8 = render dimensions and text</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RenderSettings(settings:int) : unit = //SET
        let rendersettings = State.Doc.RenderSettings
        rendersettings.ShadowmapLevel <-    (settings &&& 1)
        rendersettings.UseHiddenLights <-   (settings &&& 2) = 2
        rendersettings.RenderCurves <-      (settings &&& 4) = 4
        rendersettings.RenderAnnotations <- (settings &&& 8) = 8
        State.Doc.RenderSettings <- rendersettings


    ///<summary>Returns the document's absolute tolerance. Absolute tolerance
    /// is measured in drawing units. See Rhino's document properties command
    /// (Units and Page Units Window) for details.</summary>
    ///<returns>(float) The current absolute tolerance.</returns>
    static member UnitAbsoluteTolerance() : float = //GET
        State.Doc.ModelAbsoluteTolerance

    ///<summary>Sets the document's absolute tolerance. Absolute tolerance
    /// is measured in drawing units. See Rhino's document properties command
    /// (Units and Page Units Window) for details.</summary>
    ///<param name="tolerance">(float) The absolute tolerance to set</param>
    ///<returns>(unit) void, nothing.</returns>
    static member UnitAbsoluteTolerance(tolerance:float) : unit = //SET
        if tolerance > 0.0 then
            State.Doc.ModelAbsoluteTolerance <- tolerance
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.UnitAbsoluteTolerance failed.  tolerance:'%A'" tolerance



    ///<summary>Return the document's angle tolerance. Angle tolerance is
    /// measured in degrees. See Rhino's DocumentProperties command
    /// (Units and Page Units Window) for details.</summary>
    ///<returns>(float) The current angle tolerance.</returns>
    static member UnitAngleTolerance() : float = //GET
        State.Doc.ModelAngleToleranceDegrees

    ///<summary>Set the document's angle tolerance. Angle tolerance is
    /// measured in degrees. See Rhino's DocumentProperties command
    /// (Units and Page Units Window) for details.</summary>
    ///<param name="angleToleranceDegrees">(float) The angle tolerance to set</param>
    ///<returns>(unit) void, nothing.</returns>
    static member UnitAngleTolerance(angleToleranceDegrees:float) : unit = //SET
            if angleToleranceDegrees > 0. then
                State.Doc.ModelAngleToleranceDegrees <- angleToleranceDegrees
            else
                RhinoScriptingException.Raise "RhinoScriptSyntax.UnitAngleTolerance failed.  angleToleranceDegrees:'%A'" angleToleranceDegrees


    ///<summary>Return the document's distance display precision.</summary>
    ///<returns>(int) The current distance display precision.</returns>
    static member UnitDistanceDisplayPrecision() : int = //GET
        State.Doc.ModelDistanceDisplayPrecision

    ///<summary>Set the document's distance display precision.</summary>
    ///<param name="precision">(int) The distance display precision. If the current distance display mode is Decimal, then precision is the number of decimal places.
    ///    If the current distance display mode is Fractional (including Feet and Inches), then the denominator = (1/2)^precision.
    ///    Use UnitDistanceDisplayMode to get the current distance display mode</param>
    ///<returns>(unit) void, nothing.</returns>
    static member UnitDistanceDisplayPrecision(precision:int) : unit = //SET
            State.Doc.ModelDistanceDisplayPrecision <- precision


    ///<summary>Return the document's relative tolerance. Relative tolerance
    /// is measured in percent. See Rhino's DocumentProperties command
    /// (Units and Page Units Window) for details.</summary>
    ///<returns>(float) The current tolerance in percent.</returns>
    static member UnitRelativeTolerance() : float = //GET
        State.Doc.ModelRelativeTolerance

    ///<summary>Set the document's relative tolerance. Relative tolerance
    /// is measured in percent. See Rhino's DocumentProperties command
    /// (Units and Page Units Window) for details.</summary>
    ///<param name="relativeTolerance">(float) The relative tolerance in percent</param>
    ///<returns>(unit) void, nothing.</returns>
    static member UnitRelativeTolerance(relativeTolerance:float) : unit = //SET
            if relativeTolerance > 0.0 then
                State.Doc.ModelRelativeTolerance <- relativeTolerance
            else
                RhinoScriptingException.Raise "RhinoScriptSyntax.UnitRelativeTolerance failed.  relativeTolerance:'%A'" relativeTolerance


    ///<summary>Return the scale factor for changing between unit systems.</summary>
    ///<param name="toSystem">(int) The unit system to convert to. The unit systems are are:
    ///    0 - No unit system
    ///    1 - Microns (1.0e-6 meters)
    ///    2 - Millimeters (1.0e-3 meters)
    ///    3 - Centimeters (1.0e-2 meters)
    ///    4 - Meters
    ///    5 - Kilometers (1.0e + 3 meters)
    ///    6 - Microinches (2.54e-8 meters, 1.0e-6 inches)
    ///    7 - Mils (2.54e-5 meters, 0.001 inches)
    ///    8 - Inches (0.0254 meters)
    ///    9 - Feet (0.3048 meters, 12 inches)
    ///   10 - Miles (1609.344 meters, 5280 feet)
    ///   11 - *Reserved for custom Unit System*
    ///   12 - Angstroms (1.0e-10 meters)
    ///   13 - Nanometers (1.0e-9 meters)
    ///   14 - Decimeters (1.0e-1 meters)
    ///   15 - Dekameters (1.0e + 1 meters)
    ///   16 - Hectometers (1.0e + 2 meters)
    ///   17 - Megameters (1.0e + 6 meters)
    ///   18 - Gigameters (1.0e + 9 meters)
    ///   19 - Yards (0.9144  meters, 36 inches)
    ///   20 - Printer point (1/72 inches, computer points)
    ///   21 - Printer pica (1/6 inches, (computer picas)
    ///   22 - Nautical mile (1852 meters)
    ///   23 - Astronomical (1.4959787e + 11)
    ///   24 - Lightyears (9.46073e + 15 meters)
    ///   25 - Parsecs (3.08567758e + 16)</param>
    ///<param name="fromSystem">(int) The unit system to convert from (see above)</param>
    ///<returns>(float) scale factor for changing between unit systems.</returns>
    static member UnitScale(toSystem:int, fromSystem:int) : float = // https://github.com/mcneel/rhinoscriptsyntax/pull/198/files
        let toSystem:UnitSystem   = LanguagePrimitives.EnumOfValue  (byte toSystem)
        let fromSystem:UnitSystem  = LanguagePrimitives.EnumOfValue (byte fromSystem)
        RhinoMath.UnitScale(fromSystem, toSystem)


    ///<summary>Return the document's unit system. See Rhino's DocumentProperties
    /// command (Units and Page Units Window) for details.</summary>
    ///<returns>(int) The current unit system
    ///    0 - No unit system
    ///    1 - Microns (1.0e-6 meters)
    ///    2 - Millimeters (1.0e-3 meters)
    ///    3 - Centimeters (1.0e-2 meters)
    ///    4 - Meters
    ///    5 - Kilometers (1.0e + 3 meters)
    ///    6 - MicroInches (2.54e-8 meters, 1.0e-6 inches)
    ///    7 - Mils (2.54e-5 meters, 0.001 inches)
    ///    8 - Inches (0.0254 meters)
    ///    9 - Feet (0.3048 meters, 12 inches)
    ///   10 - Miles (1609.344 meters, 5280 feet)
    ///   11 - *Reserved for custom Unit System*
    ///   12 - Angstroms (1.0e-10 meters)
    ///   13 - Nanometers (1.0e-9 meters)
    ///   14 - Decimeters (1.0e-1 meters)
    ///   15 - Dekameters (1.0e + 1 meters)
    ///   16 - Hectometers (1.0e + 2 meters)
    ///   17 - Megameters (1.0e + 6 meters)
    ///   18 - Gigameters (1.0e + 9 meters)
    ///   19 - Yards (0.9144  meters, 36 inches)
    ///   20 - Printer point (1/72 inches, computer points)
    ///   21 - Printer pica (1/6 inches, (computer picas)
    ///   22 - Nautical mile (1852 meters)
    ///   23 - Astronomical (1.4959787e + 11)
    ///   24 - Lightyears (9.46073e + 15 meters)
    ///   25 - Parsecs (3.08567758e + 16).</returns>
    static member UnitSystem() : int = //GET
            int(State.Doc.ModelUnitSystem)

    ///<summary>Set the document's unit system. See Rhino's DocumentProperties
    /// command (Units and Page Units Window) for details.</summary>
    ///<param name="unitSystem">(int) The unit system to set the document to. The unit systems are:
    ///    0 - No unit system
    ///    1 - Microns (1.0e-6 meters)
    ///    2 - Millimeters (1.0e-3 meters)
    ///    3 - Centimeters (1.0e-2 meters)
    ///    4 - Meters
    ///    5 - Kilometers (1.0e + 3 meters)
    ///    6 - MicroInches (2.54e-8 meters, 1.0e-6 inches)
    ///    7 - Mils (2.54e-5 meters, 0.001 inches)
    ///    8 - Inches (0.0254 meters)
    ///    9 - Feet (0.3048 meters, 12 inches)
    ///   10 - Miles (1609.344 meters, 5280 feet)
    ///   11 - *Reserved for custom Unit System*
    ///   12 - Angstroms (1.0e-10 meters)
    ///   13 - Nanometers (1.0e-9 meters)
    ///   14 - Decimeters (1.0e-1 meters)
    ///   15 - Dekameters (1.0e + 1 meters)
    ///   16 - Hectometers (1.0e + 2 meters)
    ///   17 - Megameters (1.0e + 6 meters)
    ///   18 - Gigameters (1.0e + 9 meters)
    ///   19 - Yards (0.9144  meters, 36 inches)
    ///   20 - Printer point (1/72 inches, computer points)
    ///   21 - Printer pica (1/6 inches, (computer picas)
    ///   22 - Nautical mile (1852 meters)
    ///   23 - Astronomical (1.4959787e + 11)
    ///   24 - Lightyears (9.46073e + 15 meters)
    ///   25 - Parsecs (3.08567758e + 16)</param>
    ///<param name="scale">(bool) Optional, default value: <c>false</c>
    ///    Scale existing geometry based on the new unit system.
    ///    If not specified, any existing geometry is not scaled (False)</param>
    ///<returns>(unit) void, nothing.</returns>
    static member UnitSystem(unitSystem:int, [<OPT;DEF(false)>]scale:bool) : unit = //SET
        if unitSystem < 1 || unitSystem > 25 then
            RhinoScriptingException.Raise "RhinoScriptSyntax.UnitSystem value of %d is not  valid" unitSystem
            let unitSystem : UnitSystem  = LanguagePrimitives.EnumOfValue (byte unitSystem)
            State.Doc.AdjustPageUnitSystem(unitSystem, scale)



    ///<summary>Returns the name of the current unit system.</summary>
    ///<param name="capitalize">(bool) Optional, default value: <c>false</c>
    ///    Capitalize the first character of the units system name (e.g. return "Millimeter" instead of "millimeter"). The default is not to capitalize the first character (false)</param>
    ///<param name="singular">(bool) Optional, default value: <c>true</c>
    ///    Return the singular form of the units system name (e.g. "millimeter" instead of "millimeters"). The default is to return the singular form of the name (true)</param>
    ///<param name="abbreviate">(bool) Optional, default value: <c>false</c>
    ///    Abbreviate the name of the units system (e.g. return "mm" instead of "millimeter"). The default is not to abbreviate the name (false)</param>
    ///<param name="modelUnits">(bool) Optional, default value: <c>true</c>
    ///    Return the document's model units (True) or the document's page units (False). The default is True</param>
    ///<returns>(string) The name of the current units system.</returns>
    static member UnitSystemName([<OPT;DEF(false)>]capitalize:bool, [<OPT;DEF(true)>]singular:bool, [<OPT;DEF(false)>]abbreviate:bool, [<OPT;DEF(true)>]modelUnits:bool) : string =
        State.Doc.GetUnitSystemName(modelUnits, capitalize, singular, abbreviate)



    //---End of header marker: don't change: {@$%^&*()*&^%$@}


    ///<summary>Create a clipping Plane for visibly clipping away geometry in a specific view. Clipping Planes are infinite.</summary>
    ///<param name="plane">(Plane) The Plane</param>
    ///<param name="uMagnitude">(float) U magnitude of the Plane</param>
    ///<param name="vMagnitude">(float) V magnitude of the Plane</param>
    ///<param name="views">(string seq) Optional, Titles the view(s) to clip. If omitted, the active
    ///    view is used</param>
    ///<returns>(Guid) object identifier.</returns>
    static member AddClippingPlane( plane:Plane,
                                    uMagnitude:float,
                                    vMagnitude:float,
                                    [<OPT;DEF(null:string seq)>]views:string seq) : Guid =
        let viewList =
            if isNull views then [State.Doc.Views.ActiveView.ActiveViewportID]
            else
                let modelViews = State.Doc.Views.GetViewList(includeStandardViews=true, includePageViews=false)
                [for view in views do
                    for item in modelViews do
                        if item.ActiveViewport.Name = view then
                            yield item.ActiveViewportID
                ]
        let rc = State.Doc.Objects.AddClippingPlane(plane, uMagnitude, vMagnitude, viewList)
        if rc = Guid.Empty then
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddClippingPlane: Unable to add clipping plane to document.  plane:'%s' uMagnitude:'%g' vMagnitude:'%g' views:'%s'" plane.ToNiceString uMagnitude vMagnitude (Nice.str views)
        State.Doc.Views.Redraw()
        rc


    ///<summary>Creates a picture frame and adds it to the document.</summary>
    ///<param name="plane">(Plane) The Plane in which the PictureFrame will be created. The bottom-left corner of picture will be at Plane's origin. The width will be in the Plane's X axis direction, and the height will be in the Plane's Y axis direction</param>
    ///<param name="filename">(string) The path to a bitmap or image file</param>
    ///<param name="width">(float) Optional, If both dblWidth and dblHeight are 0.0 or skipped, then the width and height of the PictureFrame will be the width and height of the image. If dblWidth = 0 and dblHeight is > 0, or if dblWidth > 0 and dblHeight = 0, then the non-zero value is assumed to be an aspect ratio of the image's width or height, which ever one is = 0. If both dblWidth and dblHeight are > 0, then these are assumed to be the width and height of in the current unit system</param>
    ///<param name="height">(float) Optional, If both dblWidth and dblHeight are  0.0 or skied, then the width and height of the PictureFrame will be the width and height of the image. If dblWidth = 0 and dblHeight is > 0, or if dblWidth > 0 and dblHeight = 0, then the non-zero value is assumed to be an aspect ratio of the image's width or height, which ever one is = 0. If both dblWidth and dblHeight are > 0, then these are assumed to be the width and height of in the current unit system</param>
    ///<param name="selfIllumination">(bool) Optional, default value: <c>true</c>
    ///    If True, then the image mapped to the picture frame Plane always displays at full intensity and is not affected by light or shadow</param>
    ///<param name="embed">(bool) Optional, default value: <c>false</c>
    ///    If True, then the function adds the image to Rhino's internal bitmap table, thus making the document self-contained</param>
    ///<param name="useAlpha">(bool) Optional, default value: <c>false</c>
    ///    If False, the picture frame is created without any transparency texture. If True, a transparency texture is created with a "mask texture" set to alpha, and an instance of the diffuse texture in the source texture slot</param>
    ///<param name="makeMesh">(bool) Optional, default value: <c>false</c>
    ///    If True, the function will make a PictureFrame object from a Mesh rather than a Plane Surface</param>
    ///<returns>(Guid) object identifier.</returns>
    static member AddPictureFrame(  plane:Plane,
                                    filename:string,
                                    [<OPT;DEF(0.0)>]width:float,
                                    [<OPT;DEF(0.0)>]height:float,
                                    [<OPT;DEF(true)>]selfIllumination:bool,
                                    [<OPT;DEF(false)>]embed:bool,
                                    [<OPT;DEF(false)>]useAlpha:bool,
                                    [<OPT;DEF(false)>]makeMesh:bool) : Guid =
        if not <| IO.File.Exists(filename) then RhinoScriptingException.Raise "RhinoScriptSyntax.AddPictureFrame image %s does not exist" filename
        let rc = State.Doc.Objects.AddPictureFrame(plane, filename, makeMesh, width, height, selfIllumination, embed)
        if rc = Guid.Empty
            then RhinoScriptingException.Raise "RhinoScriptSyntax.AddPictureFrame: Unable to add picture frame to document. plane:'%s' filename:'%s' width:'%g' height:'%g' selfIllumination:'%b' embed:'%b' useAlpha:'%b' makeMesh:'%b'" plane.ToNiceString filename width height selfIllumination embed useAlpha makeMesh
        State.Doc.Views.Redraw()
        rc

    ///<summary>Adds point object to the document.</summary>
    ///<param name="x">(float) X location of point to add</param>
    ///<param name="y">(float) Y location of point to add</param>
    ///<param name="z">(float) Z location of point to add</param>
    ///<returns>(Guid) identifier for the object that was added to the doc.</returns>
    static member AddPoint(x:float, y:float, z:float) : Guid =
        let rc = State.Doc.Objects.AddPoint(Point3d(x, y, z))
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddPoint: Unable to add point to document.  x:'%s' y:'%s' z:'%s'"  (NiceFormat.float x) (NiceFormat.float y) (NiceFormat.float z)
        State.Doc.Views.Redraw()
        rc

    ///<summary>Adds point object to the document.</summary>
    ///<param name="point">(Point3d) point to draw</param>
    ///<returns>(Guid) identifier for the object that was added to the doc.</returns>
    static member AddPoint(point:Point3d) : Guid =
        let rc = State.Doc.Objects.AddPoint(point)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddPoint: Unable to add point to document.  point:'%s'" point.ToNiceString
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds point cloud object to the document.</summary>
    ///<param name="points">(Point3d array) List of values where every multiple of three represents a point</param>
    ///<param name="colors">(Drawing.Color IList) Optional, List of colors to apply to each point</param>
    ///<returns>(Guid) identifier of point cloud.</returns>
    static member AddPointCloud(points:Point3d [], [<OPT;DEF(null:Drawing.Color IList)>]colors:Drawing.Color IList) : Guid =
        if notNull colors && Seq.length(colors) = Seq.length(points) then
            let pc = new PointCloud()
            for i = 0  to -1 + (Seq.length(points)) do
                let color = RhinoScriptSyntax.CoerceColor(colors.[i])
                pc.Add(points.[i], color)
            let rc = State.Doc.Objects.AddPointCloud(pc)
            if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddPointCloud: Unable to add point cloud to document. points:'%A' colors:'%A'" points colors
            State.Doc.Views.Redraw()
            rc
        else
            let rc = State.Doc.Objects.AddPointCloud(points)
            if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddPointCloud: Unable to add point cloud to document. points:'%A' colors:'%A'" points colors
            State.Doc.Views.Redraw()
            rc


    ///<summary>Adds one or more point objects to the document.</summary>
    ///<param name="points">(Point3d seq) List of points</param>
    ///<returns>(Guid ResizeArray) List of identifiers of the new objects.</returns>
    static member AddPoints(points:Point3d seq) : Guid ResizeArray =
        let rc = resizeArray { for point in points do yield State.Doc.Objects.AddPoint(point) }
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds a text string to the document.</summary>
    ///<param name="text">(string) The text to display</param>
    ///<param name="plane">(Plane) The Plane on which the text will lie.
    ///    The origin of the Plane will be the origin point of the text</param>
    ///<param name="height">(float) Optional, default value: <c>1.0</c>
    ///    The text height</param>
    ///<param name="font">(string) Optional, The text font</param>
    ///<param name="fontStyle">(int) Optional, default value: <c>0</c>
    ///    Any of the following flags
    ///    0 = normal
    ///    1 = bold
    ///    2 = italic
    ///    3 = bold and italic</param>
    ///<param name="horizontalAlignment">(DocObjects.TextHorizontalAlignment) or Byte.
    ///    Optional, default value: <c>TextHorizontalAlignment.Center = 1uy</c>
    ///    0uy = Left
    ///    1uy = Center
    ///    2uy = Right</param>
    ///<param name="verticalAlignment">(DocObjects.TextVerticalAlignment) or Byte.
    ///    Optional, default value: <c>TextVerticalAlignment.Middle = 3uy</c>
    ///    0uy = Top:                    Attach to top of an "I" on the first line.
    ///    1uy = MiddleOfTop:            Attach to middle of an "I" on the first line.
    ///    2uy = BottomOfTop:            Attach to baseline of first line.
    ///    3uy = Middle:                 Attach to middle of text vertical advance.
    ///    4uy = MiddleOfBottom:         Attach to middle of an "I" on the last line.
    ///    5uy = Bottom:                 Attach to the baseline of the last line.
    ///    6uy = BottomOfBoundingBox:    Attach to the bottom of the bounding box of the visible glyphs.</param>
    ///<returns>(Guid) identifier for the object that was added to the doc.</returns>
    static member AddText(  text:string,
                            plane:Plane,
                            [<OPT;DEF(1.0)>]height:float,
                            [<OPT;DEF(null:string)>]font:string,
                            [<OPT;DEF(0)>]fontStyle:int,
                            [<OPT;DEF(1uy)>]horizontalAlignment:byte, //DocObjects.TextHorizontalAlignment, //TODO how to keep enum type and keep parameter optional ???
                            [<OPT;DEF(3uy)>]verticalAlignment  :byte) : Guid = //DocObjects.TextVerticalAlignment) : Guid =

        if isNull text || text = "" then RhinoScriptingException.Raise "RhinoScriptSyntax.AddText Text invalid.  text:'%s' plane:'%s' height:'%g' font:'%A' fontStyle:'%A' horizontalAlignment '%A' verticalAlignment:'%A'" text plane.ToNiceString height font fontStyle horizontalAlignment verticalAlignment
        let bold   = (1 = fontStyle || 3 = fontStyle)
        let italic = (2 = fontStyle || 3 = fontStyle)
        let ds = State.Doc.DimStyles.Current
        let qn, quartetBoldProp , quartetItalicProp =
            if isNull font then
                ds.Font.QuartetName, ds.Font.Bold, ds.Font.Italic
            else
                font, false, false

        let f = DocObjects.Font.FromQuartetProperties(qn, quartetBoldProp, quartetItalicProp)

        if isNull f then
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddText failed. text:'%s' plane:'%s' height:'%g' font:'%A' fontStyle:'%A' horizontalAlignment '%A' verticalAlignment:'%A'" text plane.ToNiceString height font fontStyle horizontalAlignment verticalAlignment
        let te = TextEntity.Create(text, plane, ds, false, 0.0, 0.0)
        te.TextHeight <- height
        if font |> notNull then
            te.Font <- f
        if bold <> quartetBoldProp then
            if DocObjects.Font.FromQuartetProperties(qn, bold, false) |> isNull then
                RhinoScriptingException.Raise "RhinoScriptSyntax.AddText failed. text:'%s' plane:'%s' height:'%g' font:'%A' fontStyle:'%A' horizontalAlignment '%A' verticalAlignment:'%A'" text plane.ToNiceString height font fontStyle horizontalAlignment verticalAlignment
            else
                te.SetBold(bold)|> ignore
        if italic <> quartetItalicProp then
            if DocObjects.Font.FromQuartetProperties(qn, false, italic) |> isNull then
                RhinoScriptingException.Raise "RhinoScriptSyntax.AddText failed. text:'%s' plane:'%s' height:'%g' font:'%A' fontStyle:'%A' horizontalAlignment '%A' verticalAlignment:'%A'" text plane.ToNiceString height font fontStyle horizontalAlignment verticalAlignment
            else
                te.SetItalic(italic)|> ignore

        te.TextHorizontalAlignment <- LanguagePrimitives.EnumOfValue horizontalAlignment
        te.TextVerticalAlignment <- LanguagePrimitives.EnumOfValue verticalAlignment
        let objectId = State.Doc.Objects.Add(te)
        if objectId = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddText: Unable to add text to document.  text:'%A' plane:'%A' height:'%A' font:'%A' fontStyle:'%A' horizontalAlignment '%A' verticalAlignment:'%A'" text plane height font fontStyle horizontalAlignment verticalAlignment
        State.Doc.Views.Redraw()
        objectId

    ///<summary>Adds a text string to the document.</summary>
    ///<param name="text">(string) The text to display</param>
    ///<param name="pt">(Point3d) a point where to add text. It will be parallel to XY Plane.</param>
    ///<param name="height">(float) Optional, default value: <c>1.0</c>
    ///    The text height</param>
    ///<param name="font">(string) Optional, The text font</param>
    ///<param name="fontStyle">(int) Optional, default value: <c>0</c>
    ///    Any of the following flags
    ///    0 = normal
    ///    1 = bold
    ///    2 = italic
    ///    3 = bold and italic</param>
    ///<param name="horizontalAlignment">(DocObjects.TextHorizontalAlignment) or Byte.
    ///    Optional, default value: <c>TextHorizontalAlignment.Center = 1uy</c>
    ///    0uy = Left
    ///    1uy = Center
    ///    2uy = Right</param>
    ///<param name="verticalAlignment">(DocObjects.TextVerticalAlignment) or Byte.
    ///    Optional, default value: <c>TextVerticalAlignment.Middle = 3uy</c>
    ///    0uy = Top:                    Attach to top of an "I" on the first line.
    ///    1uy = MiddleOfTop:            Attach to middle of an "I" on the first line.
    ///    2uy = BottomOfTop:            Attach to baseline of first line.
    ///    3uy = Middle:                 Attach to middle of text vertical advance.
    ///    4uy = MiddleOfBottom:         Attach to middle of an "I" on the last line.
    ///    5uy = Bottom:                 Attach to the baseline of the last line.
    ///    6uy = BottomOfBoundingBox:    Attach to the bottom of the bounding box of the visible glyphs.</param>
    ///<returns>(Guid) identifier for the object that was added to the doc.</returns>
    static member AddText(  text:string,
                            pt:Point3d,
                            [<OPT;DEF(1.0)>]height:float,
                            [<OPT;DEF(null:string)>]font:string,
                            [<OPT;DEF(0)>]fontStyle:int,
                            [<OPT;DEF(1uy)>]horizontalAlignment:byte, //DocObjects.TextHorizontalAlignment, //TODO how to keep enum type and keep parameter optional ???
                            [<OPT;DEF(3uy)>]verticalAlignment  :byte) : Guid =
        let pl = Plane(pt,Vector3d.XAxis,Vector3d.YAxis)
        RhinoScriptSyntax.AddText(text, pl, height, font, fontStyle, horizontalAlignment, verticalAlignment)

    ///<summary>Add a text dot to the document.</summary>
    ///<param name="text">(string) String in dot</param>
    ///<param name="point">(Point3d) A 3D point identifying the origin point</param>
    ///<returns>(Guid) The identifier of the new object.</returns>
    static member AddTextDot(text:string, point:Point3d) : Guid =
        let rc = State.Doc.Objects.AddTextDot(text, point)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddTextDot: Unable to add TextDot to document. text:'%s' point:'%s'" text (Nice.str point)
        State.Doc.Views.Redraw()
        rc

    ///<summary>Add a text dot to the document.</summary>
    ///<param name="text">(string) String in dot</param>
    ///<param name="x">(float) X position</param>
    ///<param name="y">(float) Y position</param>
    ///<param name="z">(float) Z position</param>
    ///<returns>(Guid) The identifier of the new object.</returns>
    static member AddTextDot(text:string, x:float,y,z) : Guid =
        let rc = State.Doc.Objects.AddTextDot(text, Point3d(x,y,z))
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddTextDot: Unable to add TextDot to document. text:'%s' at x:%g, y:%g, z:%g" text x y z
        State.Doc.Views.Redraw()
        rc


    ///<summary>Compute the area of a closed Curve, Hatch, Surface, Polysurface, or Mesh.</summary>
    ///<param name="geometry">(GeometryBase) The geometry to use</param>
    ///<returns>(float) area.</returns>
    static member Area(geometry:GeometryBase) : float =
        let mp = AreaMassProperties.Compute([geometry])
        if mp |> isNull then RhinoScriptingException.Raise "RhinoScriptSyntax.Area: Unable to compute area mass properties from geometry:'%s'" (Nice.str geometry)
        mp.Area

    ///<summary>Compute the area of a closed Curve, Hatch, Surface, Polysurface, or Mesh.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(float) area.</returns>
    static member Area(objectId:Guid) : float =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let mp = AreaMassProperties.Compute([rhobj.Geometry])
        if mp |> isNull then RhinoScriptingException.Raise "RhinoScriptSyntax.Area: Unable to compute area mass properties from objectId:'%s'" (Nice.str objectId)
        mp.Area

    ///<summary>Returns a world axis-aligned bounding box of several objects.
    ///   Estimated bounding boxes can be computed much (much) faster than accurate (or "tight") bounding boxes.
    ///   Estimated bounding boxes are always similar to or larger than accurate bounding boxes.</summary>
    ///<param name="geometries">(GeometryBase seq) The Geometries of the objects</param>
    ///<returns>(Geometry.BoundingBox) The BoundingBox (oriented to the World XY Plane).
    ///    To get the eight 3D points that define the bounding box call box.GetCorners()
    ///    Points returned in counter-clockwise order starting with the bottom rectangle of the box.</returns>
    static member BoundingBoxEstimate(geometries: seq<#GeometryBase>) : BoundingBox =
        let mutable bbox = BoundingBox.Empty
        for g in geometries do
            bbox <- BoundingBox.Union(bbox, g.GetBoundingBox(false)) //https://discourse.mcneel.com/t/questions-about-getboundingbox-bool/32092/5
        bbox

    ///<summary>Returns a world axis-aligned bounding box of several objects.
    ///   Estimated bounding boxes can be computed much (much) faster than accurate (or "tight") bounding boxes.
    ///   Estimated bounding boxes are always similar to or larger than accurate bounding boxes.</summary>
    ///<param name="objects">(Guid seq) The identifiers of the objects</param>
    ///<returns>(Geometry.BoundingBox) The BoundingBox (oriented to the World XY Plane).
    ///    To get the eight 3D points that define the bounding box call box.GetCorners()
    ///    Points returned in counter-clockwise order starting with the bottom rectangle of the box.</returns>
    static member BoundingBoxEstimate(objects:Guid seq) : BoundingBox =
        let mutable bbox = BoundingBox.Empty
        for o in objects do
            let g =  RhinoScriptSyntax.CoerceGeometry o
            bbox <- BoundingBox.Union(bbox, g.GetBoundingBox(false)) //https://discourse.mcneel.com/t/questions-about-getboundingbox-bool/32092/5
        bbox

    ///<summary>Returns a world axis-aligned bounding box of one object.
    ///   Estimated bounding boxes can be computed much (much) faster than accurate (or "tight") bounding boxes.
    ///   Estimated bounding boxes are always similar to or larger than accurate bounding boxes.</summary>
    ///<param name="object">(Guid) The identifier of the object</param>
    ///<returns>(Geometry.BoundingBox) The BoundingBox (oriented to the World XY Plane).
    ///    To get the eight 3D points that define the bounding box call box.GetCorners()
    ///    Points returned in counter-clockwise order starting with the bottom rectangle of the box.</returns>
    static member BoundingBoxEstimate(object:Guid) : BoundingBox =
        let g =  RhinoScriptSyntax.CoerceGeometry object
        g.GetBoundingBox(false) //https://discourse.mcneel.com/t/questions-about-getboundingbox-bool/32092/5


    ///<summary>Returns a world axis-aligned bounding box of several objects.</summary>
    ///<param name="objects">(Guid seq) The identifiers of the objects</param>
    ///<returns>(Geometry.BoundingBox) The BoundingBox (oriented to the World XY Plane).
    ///    To get the eight 3D points that define the bounding box call box.GetCorners()
    ///    Points returned in counter-clockwise order starting with the bottom rectangle of the box.</returns>
    static member BoundingBox(objects:Guid seq) : BoundingBox =
        let mutable bbox = BoundingBox.Empty
        for o in objects do
            let g =  RhinoScriptSyntax.CoerceGeometry o
            bbox <- BoundingBox.Union(bbox, g.GetBoundingBox(true))
        bbox

    ///<summary>Returns a world axis-aligned bounding box of several geometry objects.</summary>
    ///<param name="geos">(GeometryBase seq) The geometries</param>
    ///<returns>(Geometry.BoundingBox) The BoundingBox (oriented to the World XY Plane).
    ///    To get the eight 3D points that define the bounding box call box.GetCorners()
    ///    Points returned in counter-clockwise order starting with the bottom rectangle of the box.</returns>
    static member BoundingBox(geos:seq<#GeometryBase>) : BoundingBox =
        let mutable bbox = BoundingBox.Empty
        for g in geos do
            bbox <- BoundingBox.Union(bbox, g.GetBoundingBox(true))
        bbox


    ///<summary>Returns a world axis-aligned bounding box of one object.</summary>
    ///<param name="object">(Guid) The identifier of the object</param>
    ///<returns>(Geometry.BoundingBox) The BoundingBox (oriented to the World XY Plane).
    ///    To get the eight 3D points that define the bounding box call box.GetCorners()
    ///    Points returned in counter-clockwise order starting with the bottom rectangle of the box.</returns>
    static member BoundingBox(object:Guid) : BoundingBox =
        let g =  RhinoScriptSyntax.CoerceGeometry object
        g.GetBoundingBox(true) //https://discourse.mcneel.com/t/questions-about-getboundingbox-bool/32092/5

    ///<summary>Returns a custom Plane axis-aligned bounding box of several objects.</summary>
    ///<param name="objects">(Guid seq) The identifiers of the objects</param>
    ///<param name="plane">(Plane) Plane to which the bounding box should be aligned</param>
    ///<param name="inWorldCoords">(bool) Optional, default value: <c>true</c>
    ///    Returns the box as world coordinates or custom Plane coordinates.</param>
    ///<returns>(Geometry.Box) The Box ,oriented to the Plane or in Plane coordinates.
    ///    It cannot be a Geometry.BoundingBox since it is not in World XY
    ///    To get the eight 3D points that define the bounding box call box.GetCorners()
    ///    Points returned in counter-clockwise order starting with the bottom rectangle of the box.</returns>
    static member BoundingBox(objects:Guid seq, plane:Plane, [<OPT;DEF(true)>]inWorldCoords:bool) : Box =
        let mutable bbox = BoundingBox.Empty
        if not plane.IsValid then RhinoScriptingException.Raise "Invalid Geometry.Plane:%s in RhinoScriptSyntax.BoundingBox of %s" plane.ToNiceString (Nice.str objects)
        let worldtoplane = Transform.ChangeBasis(Plane.WorldXY, plane)
        objects
        |> Seq.map RhinoScriptSyntax.CoerceGeometry
        |> Seq.iter (fun g -> bbox <- BoundingBox.Union(bbox, g.GetBoundingBox(worldtoplane)))

        if  inWorldCoords then
            let planetoworld = Transform.ChangeBasis(plane, Plane.WorldXY)
            let box = Box(bbox)
            box.Transform(planetoworld) |> RhinoScriptingException.FailIfFalse "plane Transform in rs.BoundingBox()"
            box
        else
            Box(bbox) // return in Plane coordinates not worldxy

    ///<summary>Returns a custom Plane axis-aligned bounding box of one object.</summary>
    ///<param name="object">(Guid) The identifier of the object</param>
    ///<param name="plane">(Plane) Plane to which the bounding box should be aligned</param>
    ///<param name="inWorldCoords">(bool) Optional, default value: <c>true</c>
    ///    Returns the box as world coordinates or custom Plane coordinates.</param>
    ///<returns>(Geometry.Box) The Box ,oriented to the Plane or in Plane coordinates.
    ///    It cannot be a Geometry.BoundingBox since it is not in World XY
    ///    To get the eight 3D points that define the bounding box call box.GetCorners()
    ///    Points returned in counter-clockwise order starting with the bottom rectangle of the box.</returns>
    static member BoundingBox(object:Guid, plane:Plane, [<OPT;DEF(true)>]inWorldCoords:bool) : Box =
        RhinoScriptSyntax.BoundingBox([object],plane,inWorldCoords)

    ///<summary>Returns a new inflated the box with equal amounts in all directions.
    ///   Inflating with negative amounts may result in decreasing and invalid boxes.
    ///   This function raises an Exception if the resulting box is decreasing.
    ///   Invalid boxes can not be inflated.</summary>
    ///<param name="bbox">(BoundingBox) Geometry.BoundingBox</param>
    ///<param name="amount">(float) amount in model units to expand</param>
    ///<returns>(Geometry.BoundingBox) The new Box.</returns>
    static member BoundingBoxInflate(bbox:BoundingBox, amount:float) : BoundingBox =
        let b = BoundingBox(bbox.Min,bbox.Max)
        b.Inflate(amount)
        if not b.IsValid then RhinoScriptingException.Raise "RhinoScriptSyntax.BoundingBoxInflate Invalid BoundingBox from rs.BoundingBoxInflate by %f on %s" amount bbox.ToNiceString
        b

    ///<summary>Returns a new inflated box with custom x, y and z amounts in their directions.
    ///   Inflating with negative amounts may result in decreasing and invalid boxes.
    ///   This function raises an Exception if the resulting box is decreasing.
    ///   InValid boxes can not be inflated.</summary>
    ///<param name="bbox">(BoundingBox) Geometry.BoundingBox</param>
    ///<param name="amountX">(float) amount on X Axis in model units to expand</param>
    ///<param name="amountY">(float) amount on X Axis in model units to expand</param>
    ///<param name="amountZ">(float) amount on X Axis in model units to expand</param>
    ///<returns>(Geometry.BoundingBox) The new Box.</returns>
    static member BoundingBoxInflate(bbox:BoundingBox, amountX:float, amountY:float, amountZ:float) : BoundingBox =
        let b = BoundingBox(bbox.Min,bbox.Max)
        b.Inflate(amountX, amountY, amountZ)
        if not b.IsValid then RhinoScriptingException.Raise "RhinoScriptSyntax.BoundingBoxInflate Invalid BoundingBox from rs.BoundingBoxInflate by x:%f, y:%f, z:%f, on %s" amountX amountY amountZ bbox.ToNiceString
        b


    ///<summary>Compares two objects to determine if they are geometrically identical.</summary>
    ///<param name="first">(Guid) The identifier of the first object to compare</param>
    ///<param name="second">(Guid) The identifier of the second object to compare</param>
    ///<returns>(bool) True if the objects are geometrically identical, otherwise False.</returns>
    static member CompareGeometry(first:Guid, second:Guid) : bool =
        let firstG = RhinoScriptSyntax.CoerceGeometry(first)
        let secondG = RhinoScriptSyntax.CoerceGeometry(second)
        GeometryBase.GeometryEquals(firstG, secondG)


    ///<summary>Creates outline Curves for a given text entity.</summary>
    ///<param name="textId">(Guid) Identifier of Text object to explode</param>
    ///<param name="delete">(bool) Optional, default value: <c>false</c>
    ///    Delete the text object after the Curves have been created</param>
    ///<returns>(Guid array) Array of outline Curves.</returns>
    static member ExplodeText(textId:Guid, [<OPT;DEF(false)>]delete:bool) : ResizeArray<Guid> =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(textId)
        let curves = (rhobj.Geometry:?>TextEntity).Explode()
        let attr = rhobj.Attributes
        let rc = resizeArray { for curve in curves do yield State.Doc.Objects.AddCurve(curve, attr) }
        if delete then State.Doc.Objects.Delete(rhobj, quiet=true) |>ignore
        State.Doc.Views.Redraw()
        rc


    ///<summary>Checks if that an object is a clipping Plane object. Returns false for any other Rhino object.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True if the object with a given objectId is a clipping Plane.</returns>
    static member IsClippingPlane(objectId:Guid) : bool =
        RhinoScriptSyntax.CoerceGeometry objectId :? ClippingPlaneSurface


    ///<summary>Checks if an object is a point object. Returns false for any other Rhino object.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True if the object with a given objectId is a point.</returns>
    static member IsPoint(objectId:Guid) : bool =
        RhinoScriptSyntax.CoerceGeometry objectId :? Point


    ///<summary>Checks if an object is a point cloud object. Returns false for any other Rhino object.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True if the object with a given objectId is a point cloud.</returns>
    static member IsPointCloud(objectId:Guid) : bool =
        RhinoScriptSyntax.CoerceGeometry objectId :? PointCloud


    ///<summary>Checks if an object is a text object. Returns false for any other Rhino object.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True if the object with a given objectId is a text object.</returns>
    static member IsText(objectId:Guid) : bool =
        RhinoScriptSyntax.CoerceGeometry objectId :? TextEntity


    ///<summary>Checks if an object is a text dot object. Returns false for any other Rhino object.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True if the object with a given objectId is a text dot object.</returns>
    static member IsTextDot(objectId:Guid) : bool =
        RhinoScriptSyntax.CoerceGeometry objectId :? TextDot


    ///<summary>Returns the point count of a point cloud object.</summary>
    ///<param name="objectId">(Guid) The point cloud object's identifier</param>
    ///<returns>(int) number of points.</returns>
    static member PointCloudCount(objectId:Guid) : int =
        let pc = RhinoScriptSyntax.CoercePointCloud(objectId)
        pc.Count


    ///<summary>Checks if a point cloud has hidden points.</summary>
    ///<param name="objectId">(Guid) The point cloud object's identifier</param>
    ///<returns>(bool) True if cloud has hidden points, otherwise False.</returns>
    static member PointCloudHasHiddenPoints(objectId:Guid) : bool =
        let pc = RhinoScriptSyntax.CoercePointCloud(objectId)
        pc.HiddenPointCount>0


    ///<summary>Checks if a point cloud has point colors.</summary>
    ///<param name="objectId">(Guid) The point cloud object's identifier</param>
    ///<returns>(bool) True if cloud has point colors, otherwise False.</returns>
    static member PointCloudHasPointColors(objectId:Guid) : bool =
        let pc = RhinoScriptSyntax.CoercePointCloud(objectId)
        pc.ContainsColors


    ///<summary>Returns the hidden points of a point cloud object.</summary>
    ///<param name="objectId">(Guid) The point cloud object's identifier</param>
    ///<returns>(bool ResizeArray) List of point cloud hidden states.</returns>
    static member PointCloudHidePoints(objectId:Guid) : ResizeArray<bool> = //GET
        let pc = RhinoScriptSyntax.CoercePointCloud(objectId)
        resizeArray { for item in pc do yield item.Hidden }


    ///<summary>Modifies the hidden points of a point cloud object.</summary>
    ///<param name="objectId">(Guid) The point cloud object's identifier</param>
    ///<param name="hidden">(bool seq) List of booleans matched to the index of points to be hidden, On empty seq all point wil be shown</param>
    ///<returns>(unit) void, nothing.</returns>
    static member PointCloudHidePoints(objectId:Guid, hidden:bool seq) : unit = //SET
        let pc = RhinoScriptSyntax.CoercePointCloud objectId
        if Seq.isEmpty hidden then
            pc.ClearHiddenFlags()

        elif Seq.length(hidden) = pc.Count then
                for i, h in Seq.indexed hidden do
                    pc.[i].Hidden <- h
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.PointCloudHidePoints length of hidden values does not match point cloud point count"

        (RhinoScriptSyntax.CoerceRhinoObject objectId).CommitChanges() |> ignore
        State.Doc.Views.Redraw()



    ///<summary>Returns the point colors of a point cloud object.</summary>
    ///<param name="objectId">(Guid) The point cloud object's identifier</param>
    ///<returns>(Drawing.Color ResizeArray) List of point cloud colors.</returns>
    static member PointCloudPointColors(objectId:Guid) : Drawing.Color ResizeArray = //GET
        let pc = RhinoScriptSyntax.CoercePointCloud objectId
        resizeArray { for item in pc do yield item.Color }

    ///<summary>Modifies the point colors of a point cloud object.</summary>
    ///<param name="objectId">(Guid) The point cloud object's identifier</param>
    ///<param name="colors">(Drawing.Color seq) List of color values if you want to adjust colors, empty Seq to clear colors</param>
    ///<returns>(unit) void, nothing.</returns>
    static member PointCloudPointColors(objectId:Guid, colors:Drawing.Color seq) : unit = //SET
        let pc = RhinoScriptSyntax.CoercePointCloud objectId
        if colors |> Seq.isEmpty then
            pc.ClearColors()
        elif Seq.length(colors) = pc.Count then
            for i, c in Seq.indexed colors do pc.[i].Color <- c
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.PointCloudPointColors length of color values does not match PointCloud point count"
        (RhinoScriptSyntax.CoerceRhinoObject objectId).CommitChanges() |> ignore
        State.Doc.Views.Redraw()



    ///<summary>Returns the points of a point cloud object.</summary>
    ///<param name="objectId">(Guid) The point cloud object's identifier</param>
    ///<returns>(Point3d array) list of points.</returns>
    static member PointCloudPoints(objectId:Guid) : array<Point3d> =
        let pc = RhinoScriptSyntax.CoercePointCloud(objectId)
        pc.GetPoints()


    ///<summary>Returns amount indices of points in a point cloud that are near needlePoints.</summary>
    ///<param name="ptCloud">(Point3d seq) The point cloud to be searched, or the "hay stack".
    /// This can also be a list of points</param>
    ///<param name="needlePoints">(Point3d seq) A list of points to search in the PointCloud.
    /// This can also be specified as a point cloud</param>
    ///<param name="amount">(int) Optional, default value: <c>1</c>
    ///    The amount of required closest points. Defaults to 1</param>
    ///<returns>(int array seq) nested lists with amount items within a list, with the indices of the found points.</returns>
    static member PointCloudKNeighbors(ptCloud:Point3d seq, needlePoints:Point3d seq, [<OPT;DEF(1)>]amount:int) : seq<int[]> =
        if Seq.length(needlePoints) > 100 then
            RTree.Point3dKNeighbors(ptCloud, needlePoints, amount)
        else
            Collections.RhinoList.Point3dKNeighbors(ptCloud, needlePoints, amount)


    ///<summary>Returns a list of lists of point indices in a point cloud that are
    ///    closest to needlePoints. Each inner list references all points within or on the Surface of a sphere of distance radius.</summary>
    ///<param name="ptCloud">(Point3d seq) The point cloud to be searched, or the "hay stack". This can also be a list of points</param>
    ///<param name="needlePoints">(Point3d seq) A list of points to search in the PointCloud. This can also be specified as a point cloud</param>
    ///<param name="distance">(float) The included limit for listing points</param>
    ///<returns>(int array seq) a seq of arrays with the indices of the found points.</returns>
    static member PointCloudClosestPoints(ptCloud:Point3d seq, needlePoints:Point3d seq, distance:float) : seq<int []> =
        RTree.Point3dClosestPoints(ptCloud, needlePoints, distance)


    ///<summary>Returns the X, Y, and Z coordinates of a point object.</summary>
    ///<param name="objectId">(Guid) The identifier of a point object</param>
    ///<returns>(Point3d) The current 3-D point location.</returns>
    static member PointCoordinates(objectId:Guid) : Point3d = //GET
        RhinoScriptSyntax.Coerce3dPoint(objectId)


    ///<summary>Modifies the X, Y, and Z coordinates of a point object.</summary>
    ///<param name="objectId">(Guid) The identifier of a point object</param>
    ///<param name="point">(Point3d) A new 3D point location</param>
    ///<returns>(unit) void, nothing.</returns>
    static member PointCoordinates(objectId:Guid, point:Point3d) : unit = //SET
        let pt = RhinoScriptSyntax.Coerce3dPoint(objectId)
        if not <| State.Doc.Objects.Replace(objectId, pt) then RhinoScriptingException.Raise "RhinoScriptSyntax.PointCoordinates failed to change object %s to %s" (Nice.str objectId) (Nice.str point)
        State.Doc.Views.Redraw()



    ///<summary>Returns the font of a text dot.</summary>
    ///<param name="objectId">(Guid) Identifier of a text dot object</param>
    ///<returns>(string) The current text dot font.</returns>
    static member TextDotFont(objectId:Guid) : string = //GET
        (RhinoScriptSyntax.CoerceTextDot(objectId)).FontFace

    ///<summary>Modifies the font of a text dot.</summary>
    ///<param name="objectId">(Guid) Identifier of a text dot object</param>
    ///<param name="fontFace">(string) New font face name</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TextDotFont(objectId:Guid, fontFace:string) : unit = //SET
        let textdot = RhinoScriptSyntax.CoerceTextDot(objectId)
        textdot.FontFace <-  fontFace
        if not <| State.Doc.Objects.Replace(objectId, textdot) then RhinoScriptingException.Raise "RhinoScriptSyntax.TextDotFont failed to change object %s to '%s'" (Nice.str objectId) fontFace
        State.Doc.Views.Redraw()

    ///<summary>Modifies the font of multiple text dots.</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of multiple text dot objects</param>
    ///<param name="fontFace">(string) New font face name</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TextDotFont(objectIds:Guid seq, fontFace:string) : unit = //MULTISET
        for objectId in objectIds do
            let textdot = RhinoScriptSyntax.CoerceTextDot(objectId)
            textdot.FontFace <-  fontFace
            if not <| State.Doc.Objects.Replace(objectId, textdot) then RhinoScriptingException.Raise "RhinoScriptSyntax.TextDotFont failed to change object %s to '%s'" (Nice.str objectId) fontFace
        State.Doc.Views.Redraw()


    ///<summary>Returns the font height of a text dot.</summary>
    ///<param name="objectId">(Guid) Identifier of a text dot object</param>
    ///<returns>(int) The current text dot height.</returns>
    static member TextDotHeight(objectId:Guid) : int = //GET
        (RhinoScriptSyntax.CoerceTextDot(objectId)).FontHeight

    ///<summary>Modifies the font height of a text dot.</summary>
    ///<param name="objectId">(Guid) Identifier of a text dot object</param>
    ///<param name="height">(int) New font height</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TextDotHeight(objectId:Guid, height:int) : unit = //SET
        let textdot = RhinoScriptSyntax.CoerceTextDot(objectId)
        textdot.FontHeight <- height
        if not <| State.Doc.Objects.Replace(objectId, textdot) then RhinoScriptingException.Raise "RhinoScriptSyntax.TextDotHeight failed to change object %s to %d" (Nice.str objectId) height
        State.Doc.Views.Redraw()

    ///<summary>Modifies the font height of multiple text dots.</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of multiple text dot objects</param>
    ///<param name="height">(int) New font height</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TextDotHeight(objectIds:Guid seq, height:int) : unit = //MULTISET
        for objectId in objectIds do
            let textdot = RhinoScriptSyntax.CoerceTextDot(objectId)
            textdot.FontHeight <- height
            if not <| State.Doc.Objects.Replace(objectId, textdot) then RhinoScriptingException.Raise "RhinoScriptSyntax.TextDotHeight failed to change object %s to %d" (Nice.str objectId) height
        State.Doc.Views.Redraw()


    ///<summary>Returns the location, or insertion point, on a text dot object.</summary>
    ///<param name="objectId">(Guid) Identifier of a text dot object</param>
    ///<returns>(Point3d) The current 3-D text dot location.</returns>
    static member TextDotPoint(objectId:Guid) : Point3d = //GET
        (RhinoScriptSyntax.CoerceTextDot(objectId)).Point


    ///<summary>Modifies the location, or insertion point, on a text dot object.</summary>
    ///<param name="objectId">(Guid) Identifier of a text dot object</param>
    ///<param name="point">(Point3d) A new 3D point location</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TextDotPoint(objectId:Guid, point:Point3d) : unit = //SET
        let textdot = RhinoScriptSyntax.CoerceTextDot(objectId)
        textdot.Point <-  point
        if not <| State.Doc.Objects.Replace(objectId, textdot) then RhinoScriptingException.Raise "RhinoScriptSyntax.TextDotPoint failed to change object %s to %s" (Nice.str objectId) point.ToNiceString
        State.Doc.Views.Redraw()




    ///<summary>Returns the text on a text dot object.</summary>
    ///<param name="objectId">(Guid) The identifier of a text dot object</param>
    ///<returns>(string) The current text dot text.</returns>
    static member TextDotText(objectId:Guid) : string = //GET
        (RhinoScriptSyntax.CoerceTextDot(objectId)).Text



    ///<summary>Modifies the text on a text dot object.</summary>
    ///<param name="objectId">(Guid) The identifier of a text dot object</param>
    ///<param name="text">(string) A new string for the dot</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TextDotText(objectId:Guid, text:string) : unit = //SET
        let textdot = RhinoScriptSyntax.CoerceTextDot(objectId)
        textdot.Text <-  text
        if not <| State.Doc.Objects.Replace(objectId, textdot) then RhinoScriptingException.Raise "RhinoScriptSyntax.TextDotText failed to change object %s to '%s'" (Nice.str objectId) text
        State.Doc.Views.Redraw()

    ///<summary>Modifies the text on multiple text dot objects.</summary>
    ///<param name="objectIds">(Guid seq) The identifiers of multiple text dot objects</param>
    ///<param name="text">(string) A new string for the dot</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TextDotText(objectIds:Guid seq, text:string) : unit = //MULTISET
        for objectId in objectIds do
            let textdot = RhinoScriptSyntax.CoerceTextDot(objectId)
            textdot.Text <-  text
            if not <| State.Doc.Objects.Replace(objectId, textdot) then RhinoScriptingException.Raise "RhinoScriptSyntax.TextDotText failed to change object %s to '%s'" (Nice.str objectId) text
        State.Doc.Views.Redraw()


    ///<summary>Returns the font used by a text object.</summary>
    ///<param name="objectId">(Guid) The identifier of a text object</param>
    ///<returns>(string) The current font face name.</returns>
    static member TextObjectFont(objectId:Guid) : string = //GET
        (RhinoScriptSyntax.CoerceTextEntity(objectId)).Font.QuartetName



    ///<summary>Returns the height of a text object.</summary>
    ///<param name="objectId">(Guid) The identifier of a text object</param>
    ///<returns>(float) The current text height.</returns>
    static member TextObjectHeight(objectId:Guid) : float = //GET
        (RhinoScriptSyntax.CoerceTextEntity(objectId)).TextHeight

    ///<summary>Modifies the height of a text object.</summary>
    ///<param name="objectId">(Guid) The identifier of a text object</param>
    ///<param name="height">(float) The new text height</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TextObjectHeight(objectId:Guid, height:float) : unit = //SET
        let annotation = RhinoScriptSyntax.CoerceTextEntity(objectId)
        annotation.TextHeight <-  height
        if not <| State.Doc.Objects.Replace(objectId, annotation) then RhinoScriptingException.Raise "RhinoScriptSyntax.TextObjectHeight failed.  objectId:'%s' height:'%s'" (Nice.str objectId) (NiceFormat.float height)
        State.Doc.Views.Redraw()

    ///<summary>Modifies the height of multiple text objects.</summary>
    ///<param name="objectIds">(Guid seq) The identifiers of multiple text objects</param>
    ///<param name="height">(float) The new text height</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TextObjectHeight(objectIds:Guid seq, height:float) : unit = //MULTISET
        for objectId in objectIds do
            let annotation = RhinoScriptSyntax.CoerceTextEntity(objectId)
            annotation.TextHeight <-  height
            if not <| State.Doc.Objects.Replace(objectId, annotation) then RhinoScriptingException.Raise "RhinoScriptSyntax.TextObjectHeight failed.  objectId:'%s' height:'%s'" (Nice.str objectId) (NiceFormat.float height)
        State.Doc.Views.Redraw()
        State.Doc.Views.Redraw()

    ///<summary>Returns the Plane used by a text object.</summary>
    ///<param name="objectId">(Guid) The identifier of a text object</param>
    ///<returns>(Plane) The current Plane.</returns>
    static member TextObjectPlane(objectId:Guid) : Plane = //GET
        (RhinoScriptSyntax.CoerceTextEntity(objectId)).Plane

    ///<summary>Modifies the Plane used by a text object.</summary>
    ///<param name="objectId">(Guid) The identifier of a text object</param>
    ///<param name="plane">(Plane) The new text object Plane</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TextObjectPlane(objectId:Guid, plane:Plane) : unit = //SET
        let annotation = RhinoScriptSyntax.CoerceTextEntity(objectId)
        annotation.Plane <-  plane
        if not <| State.Doc.Objects.Replace(objectId, annotation) then RhinoScriptingException.Raise "RhinoScriptSyntax.TextObjectPlane failed.  objectId:'%s' plane:'%s'" (Nice.str objectId) plane.ToNiceString
        State.Doc.Views.Redraw()


    ///<summary>Returns the location of a text object.</summary>
    ///<param name="objectId">(Guid) The identifier of a text object</param>
    ///<returns>(Point3d) The 3D point identifying the current location.</returns>
    static member TextObjectPoint(objectId:Guid) : Point3d = //GET
        (RhinoScriptSyntax.CoerceTextEntity(objectId)).Plane.Origin

    ///<summary>Modifies the location of a text object.</summary>
    ///<param name="objectId">(Guid) The identifier of a text object</param>
    ///<param name="point">(Point3d) The new text object location</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TextObjectPoint(objectId:Guid, point:Point3d) : unit = //SET
        let text = RhinoScriptSyntax.CoerceTextEntity(objectId)
        let mutable plane = text.Plane
        plane.Origin <-  point
        text.Plane <-  plane

        if not <| State.Doc.Objects.Replace(objectId, text) then RhinoScriptingException.Raise "RhinoScriptSyntax.TextObjectPoint failed.  objectId:'%s' point:'%s'" (Nice.str objectId) point.ToNiceString
        State.Doc.Views.Redraw()

    ///<summary>Returns the font style of a text object.</summary>
    ///<param name="objectId">(Guid) The identifier of a text object</param>
    ///<returns>(int) The current font style
    ///    0 = Normal
    ///    1 = Bold
    ///    2 = Italic
    ///    3 = Bold and Italic.</returns>
    static member TextObjectStyle(objectId:Guid) : int = //GET
        let annotation = RhinoScriptSyntax.CoerceTextEntity(objectId)
        let fontdata = annotation.Font
        let mutable rc = 0
        if fontdata.Bold   then rc <- 1 + rc
        if fontdata.Italic then rc <- 2 + rc
        rc

    ///<summary>Returns the plain text string of a text object.</summary>
    ///<param name="objectId">(Guid) The identifier of a text object</param>
    ///<returns>(string) The current string value.</returns>
    static member TextObjectText(objectId:Guid) : string = //GET
        let text = RhinoScriptSyntax.CoerceTextEntity(objectId)
        text.PlainText

    ///<summary>Modifies the plain text string of a text object.</summary>
    ///<param name="objectId">(Guid) The identifier of a text object</param>
    ///<param name="text">(string) A new text string</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TextObjectText(objectId:Guid, text:string) : unit = //SET
        let annotation = RhinoScriptSyntax.CoerceTextEntity(objectId)
        annotation.PlainText <-  text
        if not <| State.Doc.Objects.Replace(objectId, annotation) then RhinoScriptingException.Raise "RhinoScriptSyntax.TextObjectText failed.  objectId:'%s' text:'%s'" (Nice.str objectId) text
        State.Doc.Views.Redraw()



    ///<summary>Modifies the plain text string of multiple text objects.</summary>
    ///<param name="objectIds">(Guid seq) The identifiers of multiple text objects</param>
    ///<param name="text">(string) A new text string</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TextObjectText(objectIds:Guid seq, text:string) : unit = //MULTISET
        for objectId in objectIds do
            let annotation = RhinoScriptSyntax.CoerceTextEntity(objectId)
            annotation.PlainText <-  text
            if not <| State.Doc.Objects.Replace(objectId, annotation) then RhinoScriptingException.Raise "RhinoScriptSyntax.TextObjectText failed.  objectId:'%s' text:'%s'" (Nice.str objectId) text
        State.Doc.Views.Redraw()


     ///<summary>Returns the RichText formatting string of a text object.</summary>
    ///<param name="objectId">(Guid) The identifier of a text object</param>
    ///<returns>(string) The current RichText formatting string.</returns>
    static member TextObjectRichText(objectId:Guid) : string = //GET
        let text = RhinoScriptSyntax.CoerceTextEntity(objectId)
        text.RichText


    ///<summary>Modifies the RichText formatting string of a text object.</summary>
    ///<param name="objectId">(Guid) The identifier of a text object</param>
    ///<param name="rtfString">(string) A new text RichText formatting string</param>
    ///<param name="style">(string) Optional, default value: <c>""</c> Name of dimension style</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TextObjectRichText(objectId:Guid, rtfString:string,[<OPT;DEF("")>]style:string ) : unit = //SET
        let annotation = RhinoScriptSyntax.CoerceTextEntity(objectId)
        if style <> "" then
            let ds = State.Doc.DimStyles.FindName(style)
            if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.TextObjectRichText, style not found:'%s'"  style
            annotation.SetRichText(rtfString, ds)
        else
            annotation.RichText <-  rtfString
        if not <| State.Doc.Objects.Replace(objectId, annotation) then RhinoScriptingException.Raise "RhinoScriptSyntax.TextObjectRichText failed.  objectId:'%s' text:'%s'" (Nice.str objectId) rtfString
        State.Doc.Views.Redraw()



    ///<summary>Modifies the RichText formatting string of multiple text objects.</summary>
    ///<param name="objectIds">(Guid seq) The identifiers of multiple text objects</param>
    ///<param name="rtfString">(string) A new text RichText formatting string</param>
    ///<param name="style">(string) Optional, default value: <c>""</c> Name of dimension style</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TextObjectRichText(objectIds:Guid seq,  rtfString:string, [<OPT;DEF("")>]style:string ) : unit = //MULTISET
        if style <> "" then
            let ds = State.Doc.DimStyles.FindName(style)
            if isNull ds then  RhinoScriptingException.Raise "RhinoScriptSyntax.TextObjectRichText, style not found:'%s'"  style
            for objectId in objectIds do
                let annotation = RhinoScriptSyntax.CoerceTextEntity(objectId)
                if not <| State.Doc.Objects.Replace(objectId, annotation) then RhinoScriptingException.Raise "RhinoScriptSyntax.TextObjectRichText failed.  objectId:'%s' text:'%s' style:'%s'" (Nice.str objectId) rtfString style
                annotation.SetRichText(rtfString, ds)
        else
            for objectId in objectIds do
                let annotation = RhinoScriptSyntax.CoerceTextEntity(objectId)
                annotation.RichText <-  rtfString
                if not <| State.Doc.Objects.Replace(objectId, annotation) then RhinoScriptingException.Raise "RhinoScriptSyntax.TextObjectRichText failed.  objectId:'%s' text:'%s'" (Nice.str objectId) rtfString
        State.Doc.Views.Redraw()



    ///<summary>Modifies the font style of a text object.</summary>
    ///<param name="objectId">(Guid) The identifier of a text object</param>
    ///<param name="style">(int) The font style. Can be any of the following flags
    ///    0 = Normal
    ///    1 = Bold
    ///    2 = Italic
    ///    3 = Bold and Italic</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TextObjectStyle(objectId:Guid, style:int) : unit = //SET
        let annotation = RhinoScriptSyntax.CoerceTextEntity(objectId)
        let fontdata = annotation.Font
        let f =
            match style with
            |3 -> DocObjects.Font.FromQuartetProperties(fontdata.QuartetName, bold=true , italic=true)
            |2 -> DocObjects.Font.FromQuartetProperties(fontdata.QuartetName, bold=false, italic=true)
            |1 -> DocObjects.Font.FromQuartetProperties(fontdata.QuartetName, bold=true , italic=false)
            |0 -> DocObjects.Font.FromQuartetProperties(fontdata.QuartetName, bold=false, italic=false)
            |_ -> (RhinoScriptingException.Raise "RhinoScriptSyntax.TextObjectStyle failed.  objectId:'%s' bad style:%d" (Nice.str objectId) style)
        if isNull f then RhinoScriptingException.Raise "RhinoScriptSyntax.TextObjectStyle failed.  objectId:'%s' style:%d not available for %s" (Nice.str objectId) style fontdata.QuartetName
        if not <| State.Doc.Objects.Replace(objectId, annotation) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.TextObjectStyle failed.  objectId:'%s' bad style:%d" (Nice.str objectId) style
        State.Doc.Views.Redraw()

    ///<summary>Modifies the font style of multiple text objects. Keeps the font face</summary>
    ///<param name="objectIds">(Guid seq) The identifiers of multiple text objects</param>
    ///<param name="style">(int) The font style. Can be any of the following flags
    ///    0 = Normal
    ///    1 = Bold
    ///    2 = Italic
    ///    3 = Bold and Italic</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TextObjectStyle(objectIds:Guid seq, style:int) : unit = //MULTISET
        for objectId in objectIds do RhinoScriptSyntax.TextObjectStyle(objectId, style)


    ///<summary>Modifies the font used by a text object. Keeps the current state of bold and italic when possible.</summary>
    ///<param name="objectId">(Guid) The identifier of a text object</param>
    ///<param name="font">(string) The new Font Name</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TextObjectFont(objectId:Guid, font:string) : unit = //SET
        let annotation = RhinoScriptSyntax.CoerceTextEntity(objectId)
        let fontdata = annotation.Font
        let f =
            DocObjects.Font.FromQuartetProperties(font, fontdata.Bold, fontdata.Italic)
            // normally calls will not  go further than FromQuartetProperties(font, false, false)
            // but there are a few rare fonts that don"t have a regular font
            |? DocObjects.Font.FromQuartetProperties(font, bold=false, italic=false)
            |? DocObjects.Font.FromQuartetProperties(font, bold=true , italic=false)
            |? DocObjects.Font.FromQuartetProperties(font, bold=false, italic=true )
            |? DocObjects.Font.FromQuartetProperties(font, bold=true , italic=true )
            |? (RhinoScriptingException.Raise "RhinoScriptSyntax.TextObjectFont failed.  objectId:'%s' font:''%s''" (Nice.str objectId) font)
        annotation.Font <- f
        if not <| State.Doc.Objects.Replace(objectId, annotation) then RhinoScriptingException.Raise "RhinoScriptSyntax.TextObjectFont failed.  objectId:'%s' font:''%s''" (Nice.str objectId) font
        State.Doc.Views.Redraw()
        State.Doc.Views.Redraw()

    ///<summary>Modifies the font used by multiple text objects. Keeps the current state of bold and italic when possible.</summary>
    ///<param name="objectIds">(Guid seq) The identifiers of multiple text objects</param>
    ///<param name="font">(string) The new Font Name</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TextObjectFont(objectIds:Guid seq, font:string) : unit = //MULTISET
        for objectId in objectIds do  RhinoScriptSyntax.TextObjectFont(objectId, font)
        State.Doc.Views.Redraw()

    //---End of header marker: don't change: {@$%^&*()*&^%$@}


    ///<summary>Enables or disables an object's grips. For Curves and Surfaces, these are
    ///    also called control points.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<param name="enable">(bool) Optional, default value: <c>true</c>
    ///    If True, the specified object's grips will be turned on.
    ///    If False, they will be turned off</param>
    ///<returns>(bool) True on success, False on failure.</returns>
    static member EnableObjectGrips(objectId:Guid, [<OPT;DEF(true)>]enable:bool) : bool =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if enable <> rhobj.GripsOn then
            rhobj.GripsOn <- enable
            State.Doc.Views.Redraw()
        enable = rhobj.GripsOn


    ///<summary>Prompts the user to pick a single object grip. Fails if selection is empty.</summary>
    ///<param name="message">(string) Optional, Prompt for picking</param>
    ///<param name="preselect">(bool) Optional, default value: <c>false</c>
    ///    Allow for selection of pre-selected object grip</param>
    ///<param name="select">(bool) Optional, default value: <c>false</c>
    ///    Select the picked object grip</param>
    ///<returns>(Guid * int * Point3d) of a grip record.
    ///    [0] = identifier of the object that owns the grip
    ///    [1] = index value of the grip
    ///    [2] = location of the grip.</returns>
    static member GetObjectGrip( [<OPT;DEF(null:string)>]message:string,
                                 [<OPT;DEF(false)>]preselect:bool,
                                 [<OPT;DEF(false)>]select:bool) : Guid * int * Point3d =
        let get () =
            if not preselect then
                State.Doc.Objects.UnselectAll() |> ignore
                State.Doc.Views.Redraw()
            let grip = ref null
            let rc = Input.RhinoGet.GetGrip(grip, message)
            let grip = !grip
            if rc <> Commands.Result.Success || isNull grip then
                RhinoScriptingException.Raise "RhinoScriptSyntax.GetObjectGrip User failed to select a Grip for : %s " message
            else
                if select then
                    grip.Select(true, true)|> ignore
                    State.Doc.Views.Redraw()
                (grip.OwnerId, grip.Index, grip.CurrentLocation)
        RhinoSync.DoSyncRedrawHideEditor get



    ///<summary>Prompts user to pick one or more object grips from one or more objects.</summary>
    ///<param name="message">(string) Optional, Prompt for picking</param>
    ///<param name="preselect">(bool) Optional, default value: <c>false</c>
    ///    Allow for selection of pre-selected object grips</param>
    ///<param name="select">(bool) Optional, default value: <c>false</c>
    ///    Select the picked object grips</param>
    ///<returns>((Guid * int * Point3d) ResizeArray) containing one or more grip records. Each grip record is a tuple
    ///    [n][0] = identifier of the object that owns the grip
    ///    [n][1] = index value of the grip
    ///    [n][2] = location of the grip.</returns>
    static member GetObjectGrips( [<OPT;DEF(null:string)>]message:string,
                                  [<OPT;DEF(false)>]preselect:bool,
                                  [<OPT;DEF(false)>]select:bool) : ResizeArray<Guid * int * Point3d> =
        let get () =
            if not preselect then
                State.Doc.Objects.UnselectAll() |> ignore
                State.Doc.Views.Redraw()
            let grips = ref null
            let re = Input.RhinoGet.GetGrips(grips, message)
            let grips = !grips
            let rc = ResizeArray()
            if re = Commands.Result.Success && notNull grips then
                for grip in grips do
                    let objectId = grip.OwnerId
                    let index = grip.Index
                    let location = grip.CurrentLocation
                    rc.Add((objectId, index, location))
                    if select then grip.Select(true, true)|>ignore
                if select then State.Doc.Views.Redraw()
            rc
        RhinoSync.DoSyncRedrawHideEditor get



    /// Internal helper
    static member private neighborGrip(i, objectId:Guid, index, direction, enable) : Result<DocObjects.GripObject, string> =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let grips = rhobj.GetGrips()
        if isNull grips then Result.Error "rhobj.GetGrips() is null"
        else
            if grips.Length <= index then Result.Error "rhobj.GetGrips() failed:  grips.Length <= index "
            else
                let grip = grips.[index]
                let ng =
                    if direction = 0 then
                        grip.NeighborGrip(i, 0, 0, wrap=false)
                    else
                        grip.NeighborGrip(0, i, 0, wrap=false)
                if notNull ng && enable then
                    ng.Select(true) |> ignore // TODO needs sync ? apparently not needed!
                    State.Doc.Views.Redraw()
                Ok ng


    ///<summary>Returns the next grip index from a specified grip index of an object.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<param name="index">(int) Zero based grip index from which to get the next grip index</param>
    ///<param name="direction">(int ) Optional, default value: <c>0</c>
    ///    Direction to get the next grip index (0 = U, 1 = V)</param>
    ///<param name="enable">(bool) Optional, default value: <c>true</c>
    ///    If True, the next grip index found will be selected</param>
    ///<returns>(int) index of the next grip.</returns>
    static member NextObjectGrip( objectId:Guid,
                                  index:int,
                                  [<OPT;DEF(0)>]direction:int ,
                                  [<OPT;DEF(true)>]enable:bool) : int =
        match RhinoScriptSyntax.neighborGrip(1, objectId, index, direction, enable) with
        |Ok r -> r.Index
        |Error s -> RhinoScriptingException.Raise "RhinoScriptSyntax.NextObjectGrip failed with %s for index %d, direction %d on %A" s index direction objectId

    ///<summary>Returns number of grips owned by an object.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<returns>(int) number of grips.</returns>
    static member ObjectGripCount(objectId:Guid) : int =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let grips = rhobj.GetGrips()
        if isNull grips then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectGripCount failed.  objectId:'%s'" (Nice.str objectId)
        grips.Length


    ///<summary>Returns the location of an object's grip.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<param name="index">(int) Index of the grip to either query or modify</param>
    ///<returns>(Point3d) The current location of the grip referenced by index.</returns>
    static member ObjectGripLocation(objectId:Guid, index:int) : Point3d = //GET
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if not rhobj.GripsOn then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectGripLocation failed.  objectId:'%s' index:'%A'" (Nice.str objectId) index
        let grips = rhobj.GetGrips()
        if isNull grips || index<0 || index>=grips.Length then
            RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectGripLocation failed.  objectId:'%s' index:'%A'" (Nice.str objectId) index
        let grip = grips.[index]
        let rc = grip.CurrentLocation
        rc

    ///<summary>Modifies the location of an object's grip.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<param name="index">(int) Index of the grip to either query or modify</param>
    ///<param name="point">(Point3d) 3D point defining new location of the grip</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectGripLocation(objectId:Guid, index:int, point:Point3d) : unit = //SET
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if not rhobj.GripsOn then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectGripLocation failed.  objectId:'%s' index:'%A' point:'%A'" (Nice.str objectId) index point
        let grips = rhobj.GetGrips()
        if isNull grips || index<0 || index>=grips.Length then
            RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectGripLocation failed.  objectId:'%s' index:'%A' point:'%A'" (Nice.str objectId) index point
        let grip = grips.[index]
        grip.CurrentLocation <-  point
        State.Doc.Objects.GripUpdate(rhobj, true)|> ignore
        State.Doc.Views.Redraw()



    ///<summary>Returns the location of all grips owned by an object. The
    /// locations of the grips are returned in a list of Point3d with each position
    /// in the list corresponding to that grip's index. To modify the locations of
    /// the grips, you must provide a list of points that contain the same number
    /// of points at grips.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<returns>(Point3d ResizeArray) The current location of all grips.</returns>
    static member ObjectGripLocations(objectId:Guid) : Point3d ResizeArray = //GET
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if not rhobj.GripsOn then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectGripLocations failed.  objectId:'%s'" (Nice.str objectId)
        let grips = rhobj.GetGrips()
        if isNull grips then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectGripLocations failed.  objectId:'%s'" (Nice.str objectId)
        resizeArray { for grip in grips do yield grip.CurrentLocation }



    ///<summary>Modifies the location of all grips owned by an object. The
    /// locations of the grips are returned in a list of Point3d with each position
    /// in the list corresponding to that grip's index. To modify the locations of
    /// the grips, you must provide a list of points that contain the same number
    /// of points at grips.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<param name="points">(Point3d seq) List of 3D points identifying the new grip locations</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectGripLocations(objectId:Guid, points:Point3d seq) : unit = //SET
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if not rhobj.GripsOn then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectGripLocations failed.  objectId:'%s' points:'%A'" (Nice.str objectId) points
        let grips = rhobj.GetGrips()
        if grips |> isNull then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectGripLocations failed.  objectId:'%s' points:'%A'" (Nice.str objectId) points
        if Seq.length(points) = Seq.length(grips) then
            for pt, grip in Seq.zip points grips do
                grip.CurrentLocation <- pt
            State.Doc.Objects.GripUpdate(rhobj, true)|> ignore
            State.Doc.Views.Redraw()



    ///<summary>Checks if an object's grips are turned on.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<returns>(bool) True or False indicating Grips state.</returns>
    static member ObjectGripsOn(objectId:Guid) : bool =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        rhobj.GripsOn


    ///<summary>Checks if an object's grips are turned on and at least one grip
    ///    is selected.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member ObjectGripsSelected(objectId:Guid) : bool =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if not rhobj.GripsOn then false
        else
            let grips = rhobj.GetGrips()
            if isNull grips then false
            else
                grips
                |> Seq.exists (fun g -> g.IsSelected(false) > 0)



    ///<summary>Returns the previous grip index from a specified grip index of an object.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<param name="index">(int) Zero based grip index from which to get the previous grip index</param>
    ///<param name="direction">(int) Optional, default value: <c>0</c>
    ///    Direction to get the next grip index (0 = U, 1 = V)</param>
    ///<param name="enable">(bool) Optional, default value: <c>true</c>
    ///    If True, the next grip index found will be selected</param>
    ///<returns>(int) index of the next grip.</returns>
    static member PrevObjectGrip( objectId:Guid,
                                  index:int,
                                  [<OPT;DEF(0)>]direction:int,
                                  [<OPT;DEF(true)>]enable:bool) : int =
        match RhinoScriptSyntax.neighborGrip(-1, objectId, index, direction, enable) with
        |Ok r -> r.Index
        |Error s -> RhinoScriptingException.Raise "RhinoScriptSyntax.PrevObjectGrip failed with %s for index %d, direction %d on %A" s index direction objectId


    ///<summary>Returns a list of grip indices identifying an object's selected grips.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<returns>(int ResizeArray) list of indices.</returns>
    static member SelectedObjectGrips(objectId:Guid) : int ResizeArray =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let rc = ResizeArray()
        if not rhobj.GripsOn then rc
        else
            let grips = rhobj.GetGrips()

            if notNull grips then
                for i = 0 to grips.Length - 1 do
                    if grips.[i].IsSelected(false) > 0 then rc.Add(i)
            rc


    ///<summary>Selects a single grip owned by an object. If the object's grips are
    ///    not turned on, the grips will not be selected.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<param name="index">(int) Index of the grip to select</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member SelectObjectGrip(objectId:Guid, index:int) : bool =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if not rhobj.GripsOn then false
        else
            let grips = rhobj.GetGrips()
            if isNull grips then false
            else
                if index<0 || index>=grips.Length then false
                else
                    let grip = grips.[index]
                    if grip.Select(true, true) >0 then
                        State.Doc.Views.Redraw()
                        true
                    else
                        false


    ///<summary>Selects an object's grips. If the object's grips are not turned on,
    ///    they will not be selected.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<returns>(int) Number of grips selected.</returns>
    static member SelectObjectGrips(objectId:Guid) : int =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if not rhobj.GripsOn then RhinoScriptingException.Raise "RhinoScriptSyntax.SelectObjectGrips failed.  objectId:'%s'" (Nice.str objectId)
        let grips = rhobj.GetGrips()
        if isNull grips then RhinoScriptingException.Raise "RhinoScriptSyntax.SelectObjectGrips failed.  objectId:'%s'" (Nice.str objectId)
        let mutable count = 0
        for grip in grips do
            if grip.Select(true, true)>0 then count<- count +  1
        if count>0 then
            State.Doc.Views.Redraw()
            count
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.SelectObjectGrips failed.  objectId:'%s'" (Nice.str objectId)


    ///<summary>Unselects a single grip owned by an object. If the object's grips are
    ///    not turned on, the grips will not be unselected.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<param name="index">(int) Index of the grip to unselect</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member UnselectObjectGrip(objectId:Guid, index:int) : bool =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if not rhobj.GripsOn then false
        else
            let grips = rhobj.GetGrips()
            if isNull grips then false
            else
                if index<0 || index>=grips.Length then false
                else
                    let grip = grips.[index]
                    if grip.Select(false) = 0 then
                        State.Doc.Views.Redraw()
                        true
                    else
                        false


    ///<summary>Unselects an object's grips. Note, the grips will not be turned off.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<returns>(int) Number of grips unselected.</returns>
    static member UnselectObjectGrips(objectId:Guid) : int =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if not rhobj.GripsOn then RhinoScriptingException.Raise "RhinoScriptSyntax.UnselectObjectGrips failed.  objectId:'%s'" (Nice.str objectId)
        let grips = rhobj.GetGrips()
        if isNull grips then RhinoScriptingException.Raise "RhinoScriptSyntax.UnselectObjectGrips failed.  objectId:'%s'" (Nice.str objectId)
        let mutable count = 0
        for grip in grips do
            if grip.Select(false) = 0 then count <- count +   1
        if count>0 then
            State.Doc.Views.Redraw()
            count
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.UnselectObjectGrips failed.  objectId:'%s'" (Nice.str objectId)



    //---End of header marker: don't change: {@$%^&*()*&^%$@}



    ///<summary>Adds a new empty group to the document.</summary>
    ///<param name="groupName">(string) Optional, Name of the new group. If omitted, Rhino automatically
    ///    generates the group name</param>
    ///<returns>(string) name of the new group.</returns>
    static member AddGroup([<OPT;DEF(null:string)>]groupName:string) : string =
        let mutable index = -1
        if isNull groupName then
            index <- State.Doc.Groups.Add()
        else
            index <- State.Doc.Groups.Add( groupName )
        let rc = State.Doc.Groups.GroupName(index)
        if rc|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.AddGroup failed.  groupName:'%A'" groupName
        rc

    ///<summary>Adds one or more objects to an existing group.</summary>
    ///<param name="objectIds">(Guid seq) List of Strings or Guids representing the object identifiers</param>
    ///<param name="groupName">(string) The name of an existing group</param>
    ///<returns>(unit) void, nothing.</returns>
    static member AddObjectsToGroup(objectIds:Guid seq, groupName:string) : unit = //PLURAL
        let index = State.Doc.Groups.Find(groupName)
        if index < 0 then RhinoScriptingException.Raise "RhinoScriptSyntax.AddObjectsToGroup Can't add objects to group, group '%s' not found" groupName
        if Seq.isEmpty objectIds then RhinoScriptingException.Raise "RhinoScriptSyntax.AddObjectsToGroup Can't add empty seq to group %s" groupName
        if not <|  State.Doc.Groups.AddToGroup(index, objectIds) then RhinoScriptingException.Raise "RhinoScriptSyntax.AddObjectsToGroup failed '%s' and %A" groupName objectIds


    ///<summary>Adds two or more objects to new group.</summary>
    ///<param name="objectIds">(Guid seq) List of Strings or Guids representing the object identifiers</param>
    ///<returns>(unit) void, nothing.</returns>
    static member GroupObjects(objectIds:Guid seq) : unit =
        let index = State.Doc.Groups.Add()
        if objectIds |> Seq.hasMaximumItems 1 then RhinoScriptingException.Raise "RhinoScriptSyntax.GroupObjects needs to have more than one objects but has %d" (Seq.length objectIds)
        if not <|  State.Doc.Groups.AddToGroup(index, objectIds) then RhinoScriptingException.Raise "RhinoScriptSyntax.GroupObjects failed on %A"  objectIds
        //State.Doc.Groups.GroupName(index)

    ///<summary>Adds two or more objects to new group, sets group name.</summary>
    ///<param name="objectIds">(Guid seq) List of Strings or Guids representing the object identifiers</param>
    ///<param name="groupName">(string) The name of group to create</param>
    ///<returns>(unit) void, nothing.</returns>
    static member GroupObjects(objectIds:Guid seq, groupName:string) : unit =
        let index = State.Doc.Groups.Add( groupName )
        if index < 0 then RhinoScriptingException.Raise "RhinoScriptSyntax.GroupObjects failed to create group with name '%s' for %d objects" groupName (Seq.length objectIds)
        if objectIds |> Seq.hasMaximumItems 1 then RhinoScriptingException.Raise "RhinoScriptSyntax.GroupObjects to '%s' needs to have more than one objects but has %d" groupName (Seq.length objectIds)
        if not <|  State.Doc.Groups.AddToGroup(index, objectIds) then RhinoScriptingException.Raise "RhinoScriptSyntax.GroupObjects failed on %A"  objectIds
        //State.Doc.Groups.GroupName(index)

    ///<summary>Adds a single object to an existing group.</summary>
    ///<param name="objectId">(Guid) String or Guid representing the object identifier</param>
    ///<param name="groupName">(string) The name of an existing group</param>
    ///<returns>(unit) void, nothing.</returns>
    static member AddObjectToGroup(objectId:Guid, groupName:string) : unit =
        let index = State.Doc.Groups.Find(groupName)
        if index < 0 then RhinoScriptingException.Raise "RhinoScriptSyntax.AddObjectToGroup Can't add object to group, group '%s' not found" groupName
        if not <|  State.Doc.Groups.AddToGroup(index, objectId) then RhinoScriptingException.Raise "RhinoScriptSyntax.AddObjectToGroup failed '%s' and %A" groupName objectId


    ///<summary>Removes an existing group from the document. Reference groups cannot be
    ///    removed. Deleting a group does not delete the member objects.</summary>
    ///<param name="groupName">(string) The name of an existing group</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DeleteGroup(groupName:string) : unit =
        let index = State.Doc.Groups.Find(groupName)
        if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.DeleteGroup Can't DeleteGroup, group '%s' not found" groupName
        if not <| State.Doc.Groups.Delete(index) then RhinoScriptingException.Raise "RhinoScriptSyntax.DeleteGroup failed for group '%s' " groupName


    ///<summary>Returns the number of groups in the document.</summary>
    ///<returns>(int) The number of groups in the document.</returns>
    static member GroupCount() : int =
        State.Doc.Groups.Count


    ///<summary>Returns the names of all the groups in the document
    ///    None if no names exist in the document.</summary>
    ///<returns>(string array) The names of all the groups in the document. None if no names exist in the document.</returns>
    static member GroupNames() : string array =
        let names = State.Doc.Groups.GroupNames(true)
        if names|> isNull  then [| |]
        else names


    ///<summary>Hides a group of objects. Hidden objects are not visible, cannot be
    ///    snapped to, and cannot be selected.</summary>
    ///<param name="groupName">(string) The name of an existing group</param>
    ///<returns>(int) The number of objects that were hidden.</returns>
    static member HideGroup(groupName:string) : int =
        let index = State.Doc.Groups.Find(groupName)
        if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.HideGroup: Can't HideGroup, group '%s' not found" groupName
        State.Doc.Groups.Hide(index);


    ///<summary>Verifies the existence of a group.</summary>
    ///<param name="groupName">(string) The name of the group to check for</param>
    ///<returns>(bool) True or False.</returns>
    static member IsGroup(groupName:string) : bool =
        State.Doc.Groups.Find(groupName)>=0


    ///<summary>Checks if an existing group is empty, or contains no object members.</summary>
    ///<param name="groupName">(string) The name of an existing group</param>
    ///<returns>(bool) True or False if groupName is empty.</returns>
    static member IsGroupEmpty(groupName:string) : bool =
        let index = State.Doc.Groups.Find(groupName)
        if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.IsGroupEmpty: Can't check IsGroupEmpty, group '%s' not found" groupName
        State.Doc.Groups.GroupObjectCount(index)>0


    ///<summary>Locks a group of objects. Locked objects are visible and they can be
    ///    snapped to. But, they cannot be selected.</summary>
    ///<param name="groupName">(string) The name of an existing group</param>
    ///<returns>(int) Number of objects that were locked.</returns>
    static member LockGroup(groupName:string) : int =
        let index = State.Doc.Groups.Find(groupName)
        if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.LockGroup failed.  groupName:'%A'" groupName
        State.Doc.Groups.Lock(index);


    ///<summary>Removes a single object from any and all groups that it is a member.
    ///    Neither the object nor the group can be reference objects.</summary>
    ///<param name="objectId">(Guid) The object identifier</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member RemoveObjectFromAllGroups(objectId:Guid) : bool =
        let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if rhinoObject.GroupCount<1 then false
        else
            let attrs = rhinoObject.Attributes
            attrs.RemoveFromAllGroups()
            State.Doc.Objects.ModifyAttributes(rhinoObject, attrs, true)


    ///<summary>Remove a single object from an existing group.</summary>
    ///<param name="objectId">(Guid) The object identifier</param>
    ///<param name="groupName">(string) The name of an existing group</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RemoveObjectFromGroup(objectId:Guid, groupName:string) : unit =
        let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let index = State.Doc.Groups.Find(groupName)
        if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.RemoveObjectFromGroup failed.  objectId:'%s' groupName:'%A'" (Nice.str objectId) groupName
        let attrs = rhinoObject.Attributes
        attrs.RemoveFromGroup(index)
        if not <| State.Doc.Objects.ModifyAttributes(rhinoObject, attrs, true) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.RemoveObjectFromGroup failed.  objectId:'%s' groupName:'%A'" (Nice.str objectId) groupName


    ///<summary>Removes multiple objects from an existing group.</summary>
    ///<param name="objectIds">(Guid seq) A list of object identifiers</param>
    ///<param name="groupName">(string) The name of an existing group</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RemoveObjectsFromGroup(objectIds:Guid seq, groupName:string) : unit = //PLURAL
        let index = State.Doc.Groups.Find(groupName)
        if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.RemoveObjectsFromGroup failed.  objectIds:'%A' groupName:'%A'" (Nice.str objectIds) groupName
        for objectId in objectIds do
            let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            let attrs = rhinoObject.Attributes
            attrs.RemoveFromGroup(index)
            if not <| State.Doc.Objects.ModifyAttributes(rhinoObject, attrs, true) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.RemoveObjectsFromGroup failed.  objectId:'%s' groupName:'%A'" (Nice.str objectId) groupName



    ///<summary>Renames an existing group.</summary>
    ///<param name="oldName">(string) The name of an existing group</param>
    ///<param name="newName">(string) The new group name</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RenameGroup(oldName:string, newName:string) : unit =
        let index = State.Doc.Groups.Find(oldName)
        if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.RenameGroup failed.  oldName:'%A' newName:'%A'" oldName newName
        if not <| State.Doc.Groups.ChangeGroupName(index, newName) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.RenameGroup failed.  oldName:'%A' newName:'%A'" oldName newName


    ///<summary>Shows a group of previously hidden objects. Hidden objects are not
    ///    visible, cannot be snapped to, and cannot be selected.</summary>
    ///<param name="groupName">(string) The name of an existing group</param>
    ///<returns>(int) The number of objects that were shown.</returns>
    static member ShowGroup(groupName:string) : int =
        let index = State.Doc.Groups.Find(groupName)
        if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.ShowGroup failed.  groupName:'%A'" groupName
        State.Doc.Groups.Show(index)


    ///<summary>Unlocks a group of previously locked objects. Locks objects are visible,
    ///    can be snapped to, but cannot be selected.</summary>
    ///<param name="groupName">(string) The name of an existing group</param>
    ///<returns>(int) The number of objects that were unlocked.</returns>
    static member UnlockGroup(groupName:string) : int =
        let index = State.Doc.Groups.Find(groupName)
        if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.UnlockGroup failed.  groupName:'%A'" groupName
        State.Doc.Groups.Unlock(index)

    ///<summary>Returns the top most group name that an object is assigned.
    ///   This function primarily applies to objects that are members of nested groups.</summary>
    ///<param name="objId">(Guid) id of the object to query </param>
    ///<returns>(int) The top group's name. Fails if object is not in a group.</returns>
    static member ObjectTopGroup(objId:Guid) : string =
        let obj = RhinoScriptSyntax.CoerceRhinoObject(objId)
        let groupIndexes = obj.GetGroupList()
        if isNull groupIndexes then  RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectTopGroup objId not part of a group:'%s'" (Nice.str objId)
        else
            let topGroupIndex = Array.max(groupIndexes) // this is a bad assumption. See RH-49189
            State.Doc.Groups.FindIndex(topGroupIndex).Name

    ///<summary>Returns the names of all groups that an object is part of .
    ///   This function primarily applies to objects that are members of nested groups.</summary>
    ///<param name="objId">(Guid) id of the object to query </param>
    ///<returns>(int) The group's names sorted from bottom to top. Or an empty List if object is not in a group.</returns>
    static member ObjectGroups(objId:Guid) : ResizeArray<string> =
        let obj = RhinoScriptSyntax.CoerceRhinoObject(objId)
        let groupIndexes = obj.GetGroupList()
        if isNull groupIndexes then  (new ResizeArray<string>(0))
        else
            groupIndexes
            |>  ResizeArray.ofArray
            |>! ResizeArray.sortInPlace
            |>  ResizeArray.map (fun i -> State.Doc.Groups.FindIndex(i).Name)


    //---End of header marker: don't change: {@$%^&*()*&^%$@}


    static member private InitHatchPatterns() : unit = // TODO, optimize so that this init is ony done once ?
        if isNull <| State.Doc.HatchPatterns.FindName(DocObjects.HatchPattern.Defaults.Solid.Name) then
            State.Doc.HatchPatterns.Add(DocObjects.HatchPattern.Defaults.Solid) |> ignore

        if isNull <| State.Doc.HatchPatterns.FindName(DocObjects.HatchPattern.Defaults.Hatch1.Name) then
            State.Doc.HatchPatterns.Add(DocObjects.HatchPattern.Defaults.Hatch1)|> ignore

        if isNull <| State.Doc.HatchPatterns.FindName(DocObjects.HatchPattern.Defaults.Hatch2.Name) then
            State.Doc.HatchPatterns.Add(DocObjects.HatchPattern.Defaults.Hatch2)|> ignore

        if isNull <| State.Doc.HatchPatterns.FindName(DocObjects.HatchPattern.Defaults.Hatch3.Name) then
            State.Doc.HatchPatterns.Add(DocObjects.HatchPattern.Defaults.Hatch3)|> ignore

        if isNull <| State.Doc.HatchPatterns.FindName(DocObjects.HatchPattern.Defaults.Dash.Name) then
            State.Doc.HatchPatterns.Add(DocObjects.HatchPattern.Defaults.Dash)|> ignore

        if isNull <| State.Doc.HatchPatterns.FindName(DocObjects.HatchPattern.Defaults.Grid.Name) then
            State.Doc.HatchPatterns.Add(DocObjects.HatchPattern.Defaults.Grid)|> ignore

        if isNull <| State.Doc.HatchPatterns.FindName(DocObjects.HatchPattern.Defaults.Grid60.Name) then
            State.Doc.HatchPatterns.Add(DocObjects.HatchPattern.Defaults.Grid60)|> ignore

        if isNull <| State.Doc.HatchPatterns.FindName(DocObjects.HatchPattern.Defaults.Plus.Name) then
            State.Doc.HatchPatterns.Add(DocObjects.HatchPattern.Defaults.Plus)|> ignore

        if isNull <| State.Doc.HatchPatterns.FindName(DocObjects.HatchPattern.Defaults.Squares.Name) then
            State.Doc.HatchPatterns.Add(DocObjects.HatchPattern.Defaults.Squares)|> ignore



    ///<summary>Creates one or more new Hatch objects from a list of closed planar Curves.</summary>
    ///<param name="curves">(Curve seq) Geometry of the closed planar Curves that defines the boundary of the Hatch objects</param>
    ///<param name="hatchPattern">(string) Optional, Name of the Hatch pattern to be used by the Hatch object.  If omitted, the current Hatch pattern will be used</param>
    ///<param name="scale">(float) Optional, default value: <c>1.0</c>  Hatch pattern scale factor</param>
    ///<param name="rotation">(float) Optional, default value: <c>0.0</c>  Hatch pattern rotation angle in degrees</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c>  Tolerance for Hatch fills</param>
    ///<returns>(Guid ResizeArray) identifiers of the newly created Hatch.</returns>
    static member AddHatches( curves:Curve seq,
                              [<OPT;DEF(null:string)>]hatchPattern:string,
                              [<OPT;DEF(1.0)>]scale:float,
                              [<OPT;DEF(0.0)>]rotation:float,
                              [<OPT;DEF(0.0)>]tolerance:float) : Guid ResizeArray =
        RhinoScriptSyntax.InitHatchPatterns()
        let mutable index = State.Doc.HatchPatterns.CurrentHatchPatternIndex
        if notNull hatchPattern then
            let patternInstance = State.Doc.HatchPatterns.FindName(hatchPattern)
            index <-  if patternInstance|> isNull then RhinoMath.UnsetIntIndex else patternInstance.Index
            if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.AddHatches failed to find hatchPattern:'%s'"  hatchPattern
        let rotation = RhinoMath.ToRadians(rotation)

        let tolerance = if tolerance <= 0.0 then State.Doc.ModelAbsoluteTolerance else tolerance
        let hatches = Hatch.Create(curves, index, rotation, scale, tolerance)
        if isNull hatches then
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddHatches failed to create hatch from %d curves, not closed: %d, not planar %d, tolerance:'%g' "
                (Seq.length curves)
                (curves |> Seq.countIf ( fun c -> c.IsClosed   |> not ))
                (curves |> Seq.countIf ( fun c -> c.IsPlanar() |> not ))
                tolerance
        let ids = ResizeArray()
        for hatch in hatches do
            let objectId = State.Doc.Objects.AddHatch(hatch)
            if objectId <> Guid.Empty then
                ids.Add(objectId)
        if ids.Count = 0 then
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddHatches failed to add any hatches from %d curves, not closed: %d, not planar %d, tolerance:'%g' "
                (Seq.length curves)
                (curves |> Seq.countIf ( fun c -> c.IsClosed   |> not ))
                (curves |> Seq.countIf ( fun c -> c.IsPlanar() |> not ))
                tolerance
        State.Doc.Views.Redraw()
        ids

    ///<summary>Creates one  Hatch objects from one closed planar Curve.</summary>
    ///<param name="curve">(Curve) Curve Geometry of the closed planar Curve that defines the boundary of the Hatch object</param>
    ///<param name="hatchPattern">(string) Optional, Name of the Hatch pattern to be used by the Hatch object. If omitted, the current Hatch pattern will be used</param>
    ///<param name="scale">(float) Optional, default value: <c>1.0</c>   Hatch pattern scale factor</param>
    ///<param name="rotation">(float) Optional, default value: <c>0.0</c> Hatch pattern rotation angle in degrees</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c> Tolerance for Hatch fills</param>
    ///<returns>(Guid) identifier of the newly created Hatch.</returns>
    static member AddHatch(   curve:Curve,
                              [<OPT;DEF(null:string)>]hatchPattern:string,
                              [<OPT;DEF(1.0)>]scale:float,
                              [<OPT;DEF(0.0)>]rotation:float,
                              [<OPT;DEF(0.0)>]tolerance:float) : Guid  =
        try
           let rc = RhinoScriptSyntax.AddHatches([curve], hatchPattern, scale, rotation,tolerance)
           if rc.Count = 1 then rc.[0]
           else RhinoScriptingException.Raise "RhinoScriptSyntax.AddHatch failed to create exactly on hatch from curve. It created %d Hatches"  rc.Count
        with e->
            let tolerance = if tolerance <= 0.0 then State.Doc.ModelAbsoluteTolerance else tolerance
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddHatch failed on one curve using tolerance %f \r\nMessage: %s" tolerance  e.Message


    ///<summary>Creates one or more new Hatch objects from a list of closed planar Curves.</summary>
    ///<param name="curveIds">(Guid seq) Identifiers of the closed planar Curves that defines the   boundary of the Hatch objects</param>
    ///<param name="hatchPattern">(string) Optional, Name of the Hatch pattern to be used by the Hatch object. If omitted, the current Hatch pattern will be used</param>
    ///<param name="scale">(float) Optional, default value: <c>1.0</c>   Hatch pattern scale factor</param>
    ///<param name="rotation">(float) Optional, default value: <c>0.0</c> Hatch pattern rotation angle in degrees</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c> Tolerance for Hatch fills</param>
    ///<returns>(Guid ResizeArray) identifiers of the newly created Hatch.</returns>
    static member AddHatches(  curveIds:Guid seq,
                              [<OPT;DEF(null:string)>]hatchPattern:string,
                              [<OPT;DEF(1.0)>]scale:float,
                              [<OPT;DEF(0.0)>]rotation:float,
                              [<OPT;DEF(0.0)>]tolerance:float) : Guid ResizeArray =
        let curves =  resizeArray { for objectId in curveIds do yield RhinoScriptSyntax.CoerceCurve(objectId) }
        try RhinoScriptSyntax.AddHatches(curves, hatchPattern, scale, rotation)
        with e->
            let tolerance = if tolerance <= 0.0 then State.Doc.ModelAbsoluteTolerance else tolerance
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddHatches failed on curveIds using tolerance %f :'%s' \r\nMessage: %s" tolerance (Nice.str curveIds)  e.Message

    ///<summary>Creates a new Hatch object from a closed planar Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of the closed planar Curve that defines the boundary of the Hatch object</param>
    ///<param name="hatchPattern">(string) Optional, Name of the Hatch pattern to be used by the Hatch object. If omitted, the current Hatch pattern will be used</param>
    ///<param name="scale">(float) Optional, default value: <c>1.0</c>  Hatch pattern scale factor</param>
    ///<param name="rotation">(float) Optional, default value: <c>0.0</c> Hatch pattern rotation angle in degrees</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c> Tolerance for Hatch fills</param>
    ///<returns>(Guid) identifier of the newly created Hatch.</returns>
    static member AddHatch( curveId:Guid,
                            [<OPT;DEF(null:string)>]hatchPattern:string,
                            [<OPT;DEF(1.0)>]scale:float,
                            [<OPT;DEF(0.0)>]rotation:float,
                            [<OPT;DEF(0.0)>]tolerance:float) : Guid =
        try RhinoScriptSyntax.AddHatch(RhinoScriptSyntax.CoerceCurve(curveId), hatchPattern, scale, rotation, tolerance)
        with e->
            let tolerance = if tolerance <= 0.0 then State.Doc.ModelAbsoluteTolerance else tolerance
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddHatch failed on one curve using tolerance %f : %s\r\nMessage: %s" tolerance (Nice.str curveId)  e.Message




    ///<summary>Adds Hatch patterns to the document by importing Hatch pattern definitions
    ///    from a pattern file.</summary>
    ///<param name="filename">(string) Name of the Hatch pattern file</param>
    ///<param name="replace">(bool) Optional, default value: <c>false</c>
    ///    If Hatch pattern names already in the document match Hatch
    ///    pattern names in the pattern definition file, then the existing Hatch
    ///    patterns will be redefined</param>
    ///<returns>(string ResizeArray) Names of the newly added Hatch patterns.</returns>
    static member AddHatchPatterns(filename:string, [<OPT;DEF(false)>]replace:bool) : string ResizeArray =
        let patterns = DocObjects.HatchPattern.ReadFromFile(filename, true)
        if isNull patterns then RhinoScriptingException.Raise "RhinoScriptSyntax.AddHatchPatterns failed. filename:'%A' replace:'%A'" filename replace
        let rc = ResizeArray()
        for pattern in patterns do
             let index = State.Doc.HatchPatterns.Add(pattern)
             if index>=0 then
                 let pattern = State.Doc.HatchPatterns.[index]
                 rc.Add(pattern.Name)
        if  rc.Count = 0 then RhinoScriptingException.Raise "RhinoScriptSyntax.AddHatchPatterns failed. filename:'%A' replace:'%A'" filename replace
        rc


    ///<summary>Returns the current Hatch pattern file.</summary>
    ///<returns>(string) The current Hatch pattern.</returns>
    static member CurrentHatchPattern() : string = //GET
        let i = State.Doc.HatchPatterns.CurrentHatchPatternIndex
        let hp = State.Doc.HatchPatterns.[i]
        hp.Name



    ///<summary>Sets the current Hatch pattern file.</summary>
    ///<param name="hatchPattern">(string) Name of an existing Hatch pattern to make current</param>
    ///<returns>(unit) void, nothing.</returns>
    static member CurrentHatchPattern(hatchPattern:string) : unit = //SET
        RhinoScriptSyntax.InitHatchPatterns()
        let patternInstance = State.Doc.HatchPatterns.FindName(hatchPattern)
        if patternInstance|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.CurrentHatchPattern: Setting it failed. hatchPattern:'%A'" hatchPattern
        State.Doc.HatchPatterns.CurrentHatchPatternIndex <- patternInstance.Index


    ///<summary>Explodes a Hatch object into its component objects. The exploded objects
    ///    will be added to the document. If the Hatch object uses a solid pattern,
    ///    then planar face Brep objects will be created. Otherwise, line Curve objects
    ///    will be created.</summary>
    ///<param name="hatchId">(Guid) Identifier of a Hatch object</param>
    ///<param name="delete">(bool) Optional, default value: <c>false</c>
    ///    Delete the Hatch object</param>
    ///<returns>(Guid ResizeArray) list of identifiers for the newly created objects.</returns>
    static member ExplodeHatch(hatchId:Guid, [<OPT;DEF(false)>]delete:bool) : Guid ResizeArray =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(hatchId)
        let geo =  RhinoScriptSyntax.CoerceHatch(hatchId)
        let pieces = geo.Explode()
        if isNull pieces then RhinoScriptingException.Raise "RhinoScriptSyntax.ExplodeHatch failed.  hatchId:'%s' delete:'%A'" (Nice.str hatchId) delete
        let attr = rhobj.Attributes
        let rc = ResizeArray()
        for piece in pieces do
            match piece with
            | :? Curve as c->
                let g = State.Doc.Objects.AddCurve(c, attr)
                if g<>Guid.Empty then rc.Add(g)
            | :? Brep as c->
                let g = State.Doc.Objects.AddBrep(c, attr)
                if g<>Guid.Empty then rc.Add(g)
            | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.ExplodeHatch: drawing of %A objects after exploding not implemented" piece.ObjectType //TODO test with hatch patterns that have points
        if delete then State.Doc.Objects.Delete(rhobj)|> ignore
        rc


    ///<summary>Returns a Hatch object's Hatch pattern.</summary>
    ///<param name="hatchId">(Guid) Identifier of a Hatch object</param>
    ///<returns>(string) The current Hatch pattern.</returns>
    static member HatchPattern(hatchId:Guid) : string = //GET
        let hatchObj = RhinoScriptSyntax.CoerceHatchObject(hatchId)
        let oldIndex = hatchObj.HatchGeometry.PatternIndex
        State.Doc.HatchPatterns.[oldIndex].Name

    ///<summary>Changes a Hatch object's Hatch pattern.</summary>
    ///<param name="hatchId">(Guid) Identifier of a Hatch object</param>
    ///<param name="hatchPattern">(string) Name of an existing Hatch pattern to replace the
    ///    current Hatch pattern</param>
    ///<returns>(unit) void, nothing.</returns>
    static member HatchPattern(hatchId:Guid, hatchPattern:string) : unit = //SET
        let hatchObj = RhinoScriptSyntax.CoerceHatchObject(hatchId)
        RhinoScriptSyntax.InitHatchPatterns()
        let newPattern = State.Doc.HatchPatterns.FindName(hatchPattern)
        if newPattern|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.HatchPattern failed.  hatchId:'%s' hatchPattern:'%A'" (Nice.str hatchId) hatchPattern
        hatchObj.HatchGeometry.PatternIndex <- newPattern.Index
        hatchObj.CommitChanges() |> ignore
        State.Doc.Views.Redraw()

    ///<summary>Changes multiple Hatch objects's Hatch pattern.</summary>
    ///<param name="hatchIds">(Guid seq) Identifiers of multiple Hatch objects</param>
    ///<param name="hatchPattern">(string) Name of multiple existing Hatch pattern to replace the
    ///    current Hatch pattern</param>
    ///<returns>(unit) void, nothing.</returns>
    static member HatchPattern(hatchIds:Guid seq, hatchPattern:string) : unit = //MULTISET
        RhinoScriptSyntax.InitHatchPatterns()
        for hatchId in hatchIds do
            let hatchObj = RhinoScriptSyntax.CoerceHatchObject(hatchId)
            let newPattern = State.Doc.HatchPatterns.FindName(hatchPattern)
            if newPattern|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.HatchPattern failed.  hatchId:'%s' hatchPattern:'%A'" (Nice.str hatchId) hatchPattern
            hatchObj.HatchGeometry.PatternIndex <- newPattern.Index
            hatchObj.CommitChanges() |> ignore
        State.Doc.Views.Redraw()


    ///<summary>Returns the number of Hatch patterns in the document.</summary>
    ///<returns>(int) The number of Hatch patterns in the document.</returns>
    static member HatchPatternCount() : int =
        RhinoScriptSyntax.InitHatchPatterns()
        State.Doc.HatchPatterns.Count


    ///<summary>Returns the description of a Hatch pattern. Note, not all Hatch patterns
    ///    have descriptions.</summary>
    ///<param name="hatchPattern">(string) Name of an existing Hatch pattern</param>
    ///<returns>(string) description of the Hatch pattern.</returns>
    static member HatchPatternDescription(hatchPattern:string) : string =
        RhinoScriptSyntax.InitHatchPatterns()
        let patternInstance = State.Doc.HatchPatterns.FindName(hatchPattern)
        if patternInstance|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.HatchPatternDescription failed.  hatchPattern:'%A'" hatchPattern
        patternInstance.Description


    ///<summary>Returns the fill type of a Hatch pattern.</summary>
    ///<param name="hatchPattern">(string) Name of an existing Hatch pattern</param>
    ///<returns>(int) Hatch pattern's fill type
    ///    0 = solid, uses object color
    ///    1 = lines, uses pattern file definition
    ///    2 = gradient, uses fill color definition.</returns>
    static member HatchPatternFillType(hatchPattern:string) : int =
        RhinoScriptSyntax.InitHatchPatterns()
        let patternInstance = State.Doc.HatchPatterns.FindName(hatchPattern)
        if patternInstance|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.HatchPatternFillType failed.  hatchPattern:'%A'" hatchPattern
        int(patternInstance.FillType)


    ///<summary>Returns the names of all of the Hatch patterns in the document.</summary>
    ///<returns>(string ResizeArray) The names of all of the Hatch patterns in the document.</returns>
    static member HatchPatternNames() : string ResizeArray =
        RhinoScriptSyntax.InitHatchPatterns()
        let rc = ResizeArray()
        for i = 0 to State.Doc.HatchPatterns.Count - 1 do
            let hatchPattern = State.Doc.HatchPatterns.[i]
            if not hatchPattern.IsDeleted then
                rc.Add(hatchPattern.Name)
        rc


    ///<summary>Returns the rotation applied to the Hatch pattern when
    /// it is mapped to the Hatch's Plane.</summary>
    ///<param name="hatchId">(Guid) Identifier of a Hatch object</param>
    ///<returns>(float) if rotation is not defined, the current rotation angle.</returns>
    static member HatchRotation(hatchId:Guid) : float = //GET
        let hatchObj = RhinoScriptSyntax.CoerceHatchObject(hatchId)
        let rc = hatchObj.HatchGeometry.PatternRotation
        RhinoMath.ToDegrees(rc)


    ///<summary>Modifies the rotation applied to the Hatch pattern when
    /// it is mapped to the Hatch's Plane.</summary>
    ///<param name="hatchId">(Guid) Identifier of a Hatch object</param>
    ///<param name="rotation">(float) Rotation angle in degrees</param>
    ///<returns>(unit) void, nothing.</returns>
    static member HatchRotation(hatchId:Guid, rotation:float) : unit = //SET
        let hatchObj = RhinoScriptSyntax.CoerceHatchObject(hatchId)
        let mutable rc = hatchObj.HatchGeometry.PatternRotation
        rc <- RhinoMath.ToDegrees(rc)
        if rotation <> rc then
            let rotation = RhinoMath.ToRadians(rotation)
            hatchObj.HatchGeometry.PatternRotation <- rotation
            hatchObj.CommitChanges() |> ignore
            State.Doc.Views.Redraw()

    ///<summary>Modifies the rotation applied to the Hatch pattern when
    /// it is mapped to the Hatch's Plane.</summary>
    ///<param name="hatchIds">(Guid seq) Identifiers of multiple Hatch objects</param>
    ///<param name="rotation">(float) Rotation angle in degrees</param>
    ///<returns>(unit) void, nothing.</returns>
    static member HatchRotation(hatchIds:Guid seq, rotation:float) : unit = //MULTISET
        for hatchId in hatchIds do
            let hatchObj = RhinoScriptSyntax.CoerceHatchObject(hatchId)
            let mutable rc = hatchObj.HatchGeometry.PatternRotation
            rc <- RhinoMath.ToDegrees(rc)
            if rotation <> rc then
                let rotation = RhinoMath.ToRadians(rotation)
                hatchObj.HatchGeometry.PatternRotation <- rotation
                hatchObj.CommitChanges() |> ignore
        State.Doc.Views.Redraw()


    ///<summary>Returns the scale applied to the Hatch pattern when it is
    /// mapped to the Hatch's Plane.</summary>
    ///<param name="hatchId">(Guid) Identifier of a Hatch object</param>
    ///<returns>(float) if scale is not defined, the current scale factor.</returns>
    static member HatchScale(hatchId:Guid) : float = //GET
        let hatchObj = RhinoScriptSyntax.CoerceHatchObject(hatchId)
        hatchObj.HatchGeometry.PatternScale


    ///<summary>Modifies the scale applied to the Hatch pattern when it is
    /// mapped to the Hatch's Plane.</summary>
    ///<param name="hatchId">(Guid) Identifier of a Hatch object</param>
    ///<param name="scale">(float) Scale factor</param>
    ///<returns>(unit) void, nothing.</returns>
    static member HatchScale(hatchId:Guid, scale:float) : unit = //SET
        let hatchObj = RhinoScriptSyntax.CoerceHatchObject(hatchId)
        let rc = hatchObj.HatchGeometry.PatternScale
        if scale <> rc then
            hatchObj.HatchGeometry.PatternScale <- scale
            hatchObj.CommitChanges() |> ignore
            State.Doc.Views.Redraw()

    ///<summary>Modifies the scale applied to the Hatch pattern when it is
    /// mapped to the Hatch's Plane.</summary>
    ///<param name="hatchIds">(Guid seq) Identifiers of multiple Hatch objects</param>
    ///<param name="scale">(float) Scale factor</param>
    ///<returns>(unit) void, nothing.</returns>
    static member HatchScale(hatchIds:Guid seq, scale:float) : unit = //MULTISET
        for hatchId in hatchIds do
            let hatchObj = RhinoScriptSyntax.CoerceHatchObject(hatchId)
            let rc = hatchObj.HatchGeometry.PatternScale
            if scale <> rc then
                hatchObj.HatchGeometry.PatternScale <- scale
                hatchObj.CommitChanges() |> ignore
        State.Doc.Views.Redraw()


    ///<summary>Verifies the existence of a Hatch object in the document.</summary>
    ///<param name="objectId">(Guid) Identifier of an object</param>
    ///<returns>(bool) True or False.</returns>
    static member IsHatch(objectId:Guid) : bool =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        match rhobj with :? DocObjects.HatchObject  -> true |_ -> false


    ///<summary>Verifies the existence of a Hatch pattern in the document.</summary>
    ///<param name="name">(string) The name of a Hatch pattern</param>
    ///<returns>(bool) True or False.</returns>
    static member IsHatchPattern(name:string) : bool =
        RhinoScriptSyntax.InitHatchPatterns()
        State.Doc.HatchPatterns.FindName(name) |> notNull


    ///<summary>Checks if a Hatch pattern is the current Hatch pattern.</summary>
    ///<param name="hatchPattern">(string) Name of an existing Hatch pattern</param>
    ///<returns>(bool) True or False.</returns>
    static member IsHatchPatternCurrent(hatchPattern:string) : bool =
        RhinoScriptSyntax.InitHatchPatterns()
        let patternInstance = State.Doc.HatchPatterns.FindName(hatchPattern)
        if patternInstance|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.IsHatchPatternCurrent failed.  hatchPattern:'%A'" hatchPattern
        patternInstance.Index = State.Doc.HatchPatterns.CurrentHatchPatternIndex


    ///<summary>Checks if a Hatch pattern is from a reference file.</summary>
    ///<param name="hatchPattern">(string) Name of an existing Hatch pattern</param>
    ///<returns>(bool) True or False.</returns>
    static member IsHatchPatternReference(hatchPattern:string) : bool =
        RhinoScriptSyntax.InitHatchPatterns()
        let patternInstance = State.Doc.HatchPatterns.FindName(hatchPattern)
        if patternInstance|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.IsHatchPatternReference failed.  hatchPattern:'%A'" hatchPattern
        patternInstance.IsReference



    //---End of header marker: don't change: {@$%^&*()*&^%$@}


    ///<summary>Adds a new directional light object to the document.</summary>
    ///<param name="startPoint">(Point3d) Starting point of the light</param>
    ///<param name="endPoint">(Point3d) Ending point and direction of the light</param>
    ///<returns>(Guid) identifier of the new object.</returns>
    static member AddDirectionalLight(startPoint:Point3d, endPoint:Point3d) : Guid =
        let start =  startPoint
        let ende =  endPoint
        let light = new Light()
        light.LightStyle <- LightStyle.WorldDirectional
        light.Location <- start
        light.Direction <- ende-start
        let index = State.Doc.Lights.Add(light)
        if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.AddDirectionalLight: Unable to add light to LightTable.  startPoint:'%A' endPoint:'%A'" startPoint endPoint
        let rc = State.Doc.Lights.[index].Id
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds a new linear light object to the document.</summary>
    ///<param name="startPoint">(Point3d) Starting point of the light</param>
    ///<param name="endPoint">(Point3d) Ending point and direction of the light</param>
    ///<param name="lightWidth">(float) Optional, Width of the light</param>
    ///<returns>(Guid) identifier of the new object.</returns>
    static member AddLinearLight( startPoint:Point3d,
                                  endPoint:Point3d,
                                  [<OPT;DEF(0.0)>]lightWidth:float) : Guid =
        let start =  startPoint
        let ende =  endPoint
        let mutable width = lightWidth
        if width = 0.0  then
            let mutable radius = 0.5
            let units = State.Doc.ModelUnitSystem
            if units <> UnitSystem.None then
                let scale = RhinoMath.UnitScale(UnitSystem.Millimeters, units)
                radius <- radius * scale
            width <- radius
        let light = new Light()
        light.LightStyle <- LightStyle.WorldLinear
        light.Location <- start
        let v = ende-start
        light.Direction <- v
        light.Length <- light.Direction
        light.Width <- -light.Width
        let mutable plane = Plane(light.Location, light.Direction)
        let xAxis = plane.XAxis
        xAxis.Unitize() |> ignore
        plane.XAxis <- xAxis
        light.Width <- xAxis * ( min width ( v.Length/20.0))
        //light.Location <- start - light.Direction
        let index = State.Doc.Lights.Add(light)
        if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.AddLinearLight: Unable to add light to LightTable.  startPoint:'%A' endPoint:'%A' width:'%A'" startPoint endPoint lightWidth
        let rc = State.Doc.Lights.[index].Id
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds a new point light object to the document.</summary>
    ///<param name="point">(Point3d) The 3d location of the point</param>
    ///<returns>(Guid) identifier of the new object.</returns>
    static member AddPointLight(point:Point3d) : Guid =
        let light = new Light()
        light.LightStyle <- LightStyle.WorldPoint
        light.Location <- point
        let index = State.Doc.Lights.Add(light)
        if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.AddPointLight: Unable to add light to LightTable.  point:'%A'" point
        let rc = State.Doc.Lights.[index].Id
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds a new rectangular light object to the document.</summary>
    ///<param name="origin">(Point3d) 3d origin point of the light</param>
    ///<param name="widthPoint">(Point3d) 3d width and direction point of the light</param>
    ///<param name="heightPoint">(Point3d) 3d height and direction point of the light</param>
    ///<returns>(Guid) identifier of the new object.</returns>
    static member AddRectangularLight( origin:Point3d,
                                       widthPoint:Point3d,
                                       heightPoint:Point3d) : Guid =
        let ptx =  widthPoint
        let pty =  heightPoint
        let length = pty-origin
        let width = ptx-origin
        let normal = Vector3d.CrossProduct(width, length)
        normal.Unitize() |> ignore
        let light = new Light()
        light.LightStyle <- LightStyle.WorldRectangular
        light.Location <- origin
        light.Width <- width
        light.Length <- length
        light.Direction <- normal
        let index = State.Doc.Lights.Add(light)
        if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.AddRectangularLight: Unable to add light to LightTable.  origin:'%A' widthPoint:'%A' heightPoint:'%A'" origin widthPoint heightPoint
        let rc = State.Doc.Lights.[index].Id
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds a new spot light object to the document.</summary>
    ///<param name="origin">(Point3d) 3d origin point of the light</param>
    ///<param name="radius">(float) Radius of the cone</param>
    ///<param name="apexPoint">(Point3d) 3d apex point of the light</param>
    ///<returns>(Guid) identifier of the new object.</returns>
    static member AddSpotLight( origin:Point3d,
                                radius:float,
                                apexPoint:Point3d) : Guid =
        let mutable radius = radius
        if radius<0.0 then radius<-1.0
        let light = new Light()
        light.LightStyle <- LightStyle.WorldSpot
        light.Location <- apexPoint
        light.Direction <- origin-apexPoint
        light.SpotAngleRadians <- Math.Atan(radius / (light.Direction.Length))
        light.HotSpot <- 0.50
        let index = State.Doc.Lights.Add(light)
        if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.AddSpotLight: Unable to add light to LightTable.  origin:'%A' radius:'%A' apexPoint:'%A'" origin radius apexPoint
        let rc = State.Doc.Lights.[index].Id
        State.Doc.Views.Redraw()
        rc

    ///<summary>Get On / Off status of a light object.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<returns>(bool) The current enabled status.</returns>
    static member EnableLight(objectId:Guid) : bool = //GET
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        let rc = light.IsEnabled
        rc

    ///<summary>Enables or disables a light object.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<param name="enable">(bool) The light's enabled status</param>
    ///<returns>(unit) void, nothing.</returns>
    static member EnableLight(objectId:Guid, enable:bool) : unit = //SET
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        light.IsEnabled <- enable
        if not <| State.Doc.Lights.Modify(objectId, light) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.EnableLight failed.  objectId:'%s' enable:'%A'" (Nice.str objectId) enable
        State.Doc.Views.Redraw()

    ///<summary>Enables or disables multiple light objects.</summary>
    ///<param name="objectIds">(Guid seq) The light objects's identifiers</param>
    ///<param name="enable">(bool) The light's enabled status</param>
    ///<returns>(unit) void, nothing.</returns>
    static member EnableLight(objectIds:Guid seq, enable:bool) : unit = //MULTISET
        for objectId in objectIds do
            let light = RhinoScriptSyntax.CoerceLight(objectId)
            light.IsEnabled <- enable
            if not <| State.Doc.Lights.Modify(objectId, light) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.EnableLight failed.  objectId:'%s' enable:'%A'" (Nice.str objectId) enable
        State.Doc.Views.Redraw()


    ///<summary>Verifies a light object is a directional light.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<returns>(bool) True or False.</returns>
    static member IsDirectionalLight(objectId:Guid) : bool =
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        light.IsDirectionalLight


    ///<summary>Verifies an object is a light object.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<returns>(bool) True or False.</returns>
    static member IsLight(objectId:Guid) : bool =
        RhinoScriptSyntax.TryCoerceLight(objectId)
        |> Option.isSome


    ///<summary>Verifies a light object is enabled.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<returns>(bool) True or False.</returns>
    static member IsLightEnabled(objectId:Guid) : bool =
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        light.IsEnabled


    ///<summary>Verifies a light object is referenced from another file.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<returns>(bool) True or False.</returns>
    static member IsLightReference(objectId:Guid) : bool =
        let light = State.Doc.Lights.FindId(objectId)
        if isNull light then RhinoScriptingException.Raise "RhinoScriptSyntax.IsLightReference light (a %s) not found" (Nice.str objectId)
        light.IsReference


    ///<summary>Verifies a light object is a linear light.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<returns>(bool) True or False.</returns>
    static member IsLinearLight(objectId:Guid) : bool =
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        light.IsLinearLight


    ///<summary>Verifies a light object is a point light.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<returns>(bool) True or False.</returns>
    static member IsPointLight(objectId:Guid) : bool =
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        light.IsPointLight


    ///<summary>Verifies a light object is a rectangular light.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<returns>(bool) True or False.</returns>
    static member IsRectangularLight(objectId:Guid) : bool =
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        light.IsRectangularLight


    ///<summary>Verifies a light object is a spot light.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<returns>(bool) True or False.</returns>
    static member IsSpotLight(objectId:Guid) : bool =
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        light.IsSpotLight


    ///<summary>Returns the color of a light.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<returns>(Drawing.Color) The current color.</returns>
    static member LightColor(objectId:Guid) : Drawing.Color = //GET
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        let rc = light.Diffuse
        rc

    ///<summary>Changes the color of a light.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<param name="color">(Drawing.Color) The light's new color</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LightColor(objectId:Guid, color:Drawing.Color) : unit = //SET
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        light.Diffuse <- color
        if not <|  State.Doc.Lights.Modify(objectId, light) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.LightColor failed.  objectId:'%s' color:'%A'" (Nice.str objectId) color
        State.Doc.Views.Redraw()

    ///<summary>Changes the color of multiple light.</summary>
    ///<param name="objectIds">(Guid seq) The light objects's identifiers</param>
    ///<param name="color">(Drawing.Color) The light's new color</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LightColor(objectIds:Guid seq, color:Drawing.Color) : unit = //MULTISET
        for objectId in objectIds do
            let light = RhinoScriptSyntax.CoerceLight(objectId)
            light.Diffuse <- color
            if not <|  State.Doc.Lights.Modify(objectId, light) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.LightColor failed.  objectId:'%s' color:'%A'" (Nice.str objectId) color
        State.Doc.Views.Redraw()


    ///<summary>Returns the number of light objects in the document.</summary>
    ///<returns>(int) The number of light objects in the document.</returns>
    static member LightCount() : int =
        State.Doc.Lights.Count


    ///<summary>Returns the direction of a light object.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<returns>(Vector3d) The current direction.</returns>
    static member LightDirection(objectId:Guid) : Vector3d = //GET
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        let rc = light.Direction
        rc

    ///<summary>Changes the direction of a light object.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<param name="direction">(Vector3d) The light's new direction</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LightDirection(objectId:Guid, direction:Vector3d) : unit = //SET
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        light.Direction <- direction
        if not<|  State.Doc.Lights.Modify(objectId, light) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.LightDirection failed.  objectId:'%s' direction:'%A'" (Nice.str objectId) direction
        State.Doc.Views.Redraw()

    ///<summary>Changes the direction of multiple light objects.</summary>
    ///<param name="objectIds">(Guid seq) The light objects's identifiers</param>
    ///<param name="direction">(Vector3d) The light's new direction</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LightDirection(objectIds:Guid seq, direction:Vector3d) : unit = //MULTISET
        for objectId in objectIds do
            let light = RhinoScriptSyntax.CoerceLight(objectId)
            light.Direction <- direction
            if not<|  State.Doc.Lights.Modify(objectId, light) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.LightDirection failed.  objectId:'%s' direction:'%A'" (Nice.str objectId) direction
        State.Doc.Views.Redraw()


    ///<summary>Returns the location of a light object.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<returns>(Point3d) The current location.</returns>
    static member LightLocation(objectId:Guid) : Point3d = //GET
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        let rc = light.Location
        rc

    ///<summary>Changes the location of a light object.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<param name="location">(Point3d) The light's new location</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LightLocation(objectId:Guid, location:Point3d) : unit = //SET
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        light.Location <- location
        if not<|  State.Doc.Lights.Modify(objectId, light) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.LightLocation failed.  objectId:'%s' location:'%A'" (Nice.str objectId) location
        State.Doc.Views.Redraw()

    ///<summary>Changes the location of multiple light objects.</summary>
    ///<param name="objectIds">(Guid seq) The light objects's identifiers</param>
    ///<param name="location">(Point3d) The light's new location</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LightLocation(objectIds:Guid seq, location:Point3d) : unit = //MULTISET
        for objectId in objectIds do
            let light = RhinoScriptSyntax.CoerceLight(objectId)
            light.Location <- location
            if not<|  State.Doc.Lights.Modify(objectId, light) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.LightLocation failed.  objectId:'%s' location:'%A'" (Nice.str objectId) location
        State.Doc.Views.Redraw()


    ///<summary>Returns the name of a light object.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<returns>(string) The current name.</returns>
    static member LightName(objectId:Guid) : string = //GET
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        let rc = light.Name
        rc

    ///<summary>Changes the name of a light object.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<param name="name">(string) The light's new name</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LightName(objectId:Guid, name:string) : unit = //SET
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        light.Name <- name
        if not <|  State.Doc.Lights.Modify(objectId, light) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.LightName failed.  objectId:'%s' name:'%A'" (Nice.str objectId) name
        State.Doc.Views.Redraw()
    ///<summary>Changes the name of multiple light objects.</summary>
    ///<param name="objectIds">(Guid seq) The light objects's identifiers</param>
    ///<param name="name">(string) The light's new name</param>
    ///<returns>(unit) void, nothing.</returns>
    static member LightName(objectIds:Guid seq, name:string) : unit = //MULTISET
        for objectId in objectIds do
            let light = RhinoScriptSyntax.CoerceLight(objectId)
            light.Name <- name
            if not <|  State.Doc.Lights.Modify(objectId, light) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.LightName failed.  objectId:'%s' name:'%A'" (Nice.str objectId) name
        State.Doc.Views.Redraw()


    ///<summary>Returns list of identifiers of light objects in the document.</summary>
    ///<returns>(Guid ResizeArray) The list of identifiers of light objects in the document.</returns>
    static member LightObjects() : Guid ResizeArray =
        let count = State.Doc.Lights.Count
        let rc = ResizeArray()
        for i = 0 to count - 1 do
            let rhlight = State.Doc.Lights.[i]
            if not rhlight.IsDeleted then rc.Add(rhlight.Id)
        rc


    ///<summary>Returns the Plane of a rectangular light object.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<returns>(Plane*float*float) The Plane, X and Y length.</returns>
    static member RectangularLightPlane(objectId:Guid) : Plane*float*float =
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        if light.LightStyle <> LightStyle.WorldRectangular then
            RhinoScriptingException.Raise "RhinoScriptSyntax.RectangularLightPlane failed.  objectId:'%s'" (Nice.str objectId)
        let location = light.Location
        let length = light.Length
        let width = light.Width
        let plane = Plane(location, length, width)
        plane, length.Length, width.Length


    ///<summary>Returns the hardness of a spot light. Spotlight hardness
    /// controls the fully illuminated region.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<returns>(float) The current hardness.</returns>
    static member SpotLightHardness(objectId:Guid) : float = //GET
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        if light.LightStyle <> LightStyle.WorldSpot then
            RhinoScriptingException.Raise "RhinoScriptSyntax.SpotLightHardness failed.  objectId:'%s'" (Nice.str objectId)
        let rc = light.HotSpot
        rc

    ///<summary>Changes the hardness of a spot light. Spotlight hardness
    /// controls the fully illuminated region.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<param name="hardness">(float) The light's new hardness</param>
    ///<returns>(unit) void, nothing.</returns>
    static member SpotLightHardness(objectId:Guid, hardness:float) : unit = //SET
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        if light.LightStyle <> LightStyle.WorldSpot then
            RhinoScriptingException.Raise "RhinoScriptSyntax.SpotLightHardness failed.  objectId:'%s' hardness:'%A'" (Nice.str objectId) hardness
        light.HotSpot <- hardness
        if not <|  State.Doc.Lights.Modify(objectId, light) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.SpotLightHardness failed.  objectId:'%s' hardness:'%A'" (Nice.str objectId) hardness
        State.Doc.Views.Redraw()

    ///<summary>Changes the hardness of multiple spot light. Spotlight hardness
    /// controls the fully illuminated region.</summary>
    ///<param name="objectIds">(Guid seq) The light objects's identifiers</param>
    ///<param name="hardness">(float) The light's new hardness</param>
    ///<returns>(unit) void, nothing.</returns>
    static member SpotLightHardness(objectIds:Guid seq, hardness:float) : unit = //MULTISET
        for objectId in objectIds do
            let light = RhinoScriptSyntax.CoerceLight(objectId)
            if light.LightStyle <> LightStyle.WorldSpot then
                RhinoScriptingException.Raise "RhinoScriptSyntax.SpotLightHardness failed.  objectId:'%s' hardness:'%A'" (Nice.str objectId) hardness
            light.HotSpot <- hardness
            if not <|  State.Doc.Lights.Modify(objectId, light) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.SpotLightHardness failed.  objectId:'%s' hardness:'%A'" (Nice.str objectId) hardness
        State.Doc.Views.Redraw()


    ///<summary>Returns the radius of a spot light.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<returns>(float) The current radius.</returns>
    static member SpotLightRadius(objectId:Guid) : float = //GET
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        if light.LightStyle <> LightStyle.WorldSpot then
            RhinoScriptingException.Raise "RhinoScriptSyntax.SpotLightRadius failed.  objectId:'%s'" (Nice.str objectId)
        let radians = light.SpotAngleRadians
        let rc = light.Direction.Length * tan(radians)
        rc

    ///<summary>Changes the radius of a spot light.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<param name="radius">(float) The light's new radius</param>
    ///<returns>(unit) void, nothing.</returns>
    static member SpotLightRadius(objectId:Guid, radius:float) : unit = //SET
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        if light.LightStyle <> LightStyle.WorldSpot then
            RhinoScriptingException.Raise "RhinoScriptSyntax.SpotLightRadius failed.  objectId:'%s' radius:'%A'" (Nice.str objectId) radius
        let radians = Math.Atan(radius/light.Direction.Length)
        light.SpotAngleRadians <- radians
        if not <|  State.Doc.Lights.Modify(objectId, light) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.SpotLightRadius failed.  objectId:'%s' radius:'%A'" (Nice.str objectId) radius
        State.Doc.Views.Redraw()

    ///<summary>Changes the radius of multiple spot light.</summary>
    ///<param name="objectIds">(Guid seq) The light objects's identifiers</param>
    ///<param name="radius">(float) The light's new radius</param>
    ///<returns>(unit) void, nothing.</returns>
    static member SpotLightRadius(objectIds:Guid seq, radius:float) : unit = //MULTISET
        for objectId in objectIds do
            let light = RhinoScriptSyntax.CoerceLight(objectId)
            if light.LightStyle <> LightStyle.WorldSpot then
                RhinoScriptingException.Raise "RhinoScriptSyntax.SpotLightRadius failed.  objectId:'%s' radius:'%A'" (Nice.str objectId) radius
            let radians = Math.Atan(radius/light.Direction.Length)
            light.SpotAngleRadians <- radians
            if not <|  State.Doc.Lights.Modify(objectId, light) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.SpotLightRadius failed.  objectId:'%s' radius:'%A'" (Nice.str objectId) radius
        State.Doc.Views.Redraw()


    ///<summary>Returns the shadow intensity of a spot light.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<returns>(float) The current intensity.</returns>
    static member SpotLightShadowIntensity(objectId:Guid) : float = //GET
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        if light.LightStyle <> LightStyle.WorldSpot then
            RhinoScriptingException.Raise "RhinoScriptSyntax.SpotLightShadowIntensity failed.  objectId:'%s'" (Nice.str objectId)
        let rc = light.ShadowIntensity
        rc

    ///<summary>Changes the shadow intensity of a spot light.</summary>
    ///<param name="objectId">(Guid) The light object's identifier</param>
    ///<param name="intensity">(float) The light's new intensity</param>
    ///<returns>(unit) void, nothing.</returns>
    static member SpotLightShadowIntensity(objectId:Guid, intensity:float) : unit = //SET
        let light = RhinoScriptSyntax.CoerceLight(objectId)
        if light.LightStyle <> LightStyle.WorldSpot then
            RhinoScriptingException.Raise "RhinoScriptSyntax.SpotLightShadowIntensity failed.  objectId:'%s' intensity:'%A'" (Nice.str objectId) intensity
        light.ShadowIntensity <- intensity
        if not <|  State.Doc.Lights.Modify(objectId, light) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.SpotLightShadowIntensity failed.  objectId:'%s' intensity:'%A'" (Nice.str objectId) intensity
        State.Doc.Views.Redraw()

    ///<summary>Changes the shadow intensity of multiple spot light.</summary>
    ///<param name="objectIds">(Guid seq) The light objects's identifiers</param>
    ///<param name="intensity">(float) The light's new intensity</param>
    ///<returns>(unit) void, nothing.</returns>
    static member SpotLightShadowIntensity(objectIds:Guid seq, intensity:float) : unit = //MULTISET
        for objectId in objectIds do
            let light = RhinoScriptSyntax.CoerceLight(objectId)
            if light.LightStyle <> LightStyle.WorldSpot then
                RhinoScriptingException.Raise "RhinoScriptSyntax.SpotLightShadowIntensity failed.  objectId:'%s' intensity:'%A'" (Nice.str objectId) intensity
            light.ShadowIntensity <- intensity
            if not <|  State.Doc.Lights.Modify(objectId, light) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.SpotLightShadowIntensity failed.  objectId:'%s' intensity:'%A'" (Nice.str objectId) intensity
        State.Doc.Views.Redraw()




    //---End of header marker: don't change: {@$%^&*()*&^%$@}



    ///<summary>Finds the point on an FINITE line that is closest to a test point.</summary>
    ///<param name="line">(Geometry.Line) The finite line</param>
    ///<param name="testPoint">(Point3d) List of 3 numbers or Point3d. The test point</param>
    ///<returns>(Point3d) The point on the finite line that is closest to the test point.</returns>
    static member LineClosestPointFinite(line:Line, testPoint:Point3d) : Point3d =
        line.ClosestPoint(testPoint, true)



    ///<summary>Finds the point on an INFINITE line (ray) that is closest to a test point.</summary>
    ///<param name="line">(Geometry.Line) The line to be considered infinite</param>
    ///<param name="testPoint">(Point3d) The test point</param>
    ///<returns>(Point3d) The point on the infinite line (ray) that is closest to the test point.</returns>
    static member LineClosestPoint(line:Line, testPoint:Point3d) : Point3d =
        line.ClosestPoint(testPoint, limitToFiniteSegment=false)



    ///<summary>Calculates the intersection of a line and a cylinder.</summary>
    ///<param name="line">(Geometry.Line) The line to intersect</param>
    ///<param name="cylinderPlane">(Plane) Base Plane of the cylinder</param>
    ///<param name="cylinderHeight">(float) Height of the cylinder</param>
    ///<param name="cylinderRadius">(float) Radius of the cylinder</param>
    ///<returns>(Point3d array) list of intersection points (0, 1, or 2 points).</returns>
    static member LineCylinderIntersection(line:Line, cylinderPlane:Plane, cylinderHeight:float, cylinderRadius:float) : Point3d array =
        let circle = Geometry.Circle( cylinderPlane, cylinderRadius )
        if not <| circle.IsValid then  RhinoScriptingException.Raise "RhinoScriptSyntax.LineCylinderIntersection: Unable to create valid circle with given plane && radius.  line:'%A' cylinderPlane:'%A' cylinderHeight:'%A' cylinderRadius:'%A'" line cylinderPlane cylinderHeight cylinderRadius
        let cyl = Geometry.Cylinder( circle, cylinderHeight )
        if not <| cyl.IsValid then  RhinoScriptingException.Raise "RhinoScriptSyntax.LineCylinderIntersection: Unable to create valid cylinder with given circle && height.  line:'%A' cylinderPlane:'%A' cylinderHeight:'%A' cylinderRadius:'%A'" line cylinderPlane cylinderHeight cylinderRadius
        let rc, pt1, pt2 = Intersect.Intersection.LineCylinder(line, cyl)
        if rc= Intersect.LineCylinderIntersection.None then
            [| |]
        elif rc= Intersect.LineCylinderIntersection.Single then
            [|pt1|]
        else
            [|pt1; pt2|]




    ///<summary>Determines if the shortest distance from a line to a point or another
    ///    line is greater than a specified distance.</summary>
    ///<param name="line">(Geometry.Line) a Geometry.Line</param>
    ///<param name="distance">(float) The distance</param>
    ///<param name="point">(Point3d) The test point</param>
    ///<returns>(bool) True if the shortest distance from the line to the other project is
    ///    greater than distance, False otherwise.</returns>
    static member LineIsFartherThan(line:Line, distance:float, point:Point3d) : bool =
        let minDist = line.MinimumDistanceTo(point)
        minDist > distance
    ///<summary>Determines if the shortest distance from a line to a point or another
    ///    line is greater than a specified distance.</summary>
    ///<param name="line">(Geometry.Line) a Geometry.Line</param>
    ///<param name="distance">(float) The distance</param>
    ///<param name="line2">(Geometry.Line) The test line</param>
    ///<returns>(bool) True if the shortest distance from the line to the other project is
    ///    greater than distance, False otherwise.</returns>
    static member LineIsFartherThan(line:Line, distance:float, line2:Line) : bool =
        let minDist = line.MinimumDistanceTo(line2)
        minDist > distance



    ///<summary>Calculates the intersection of two non-parallel lines. The lines are considered endless.
    /// If the two lines do not actually intersect the closest point on each is returned.
    /// Fails on parallel or collinear lines</summary>
    ///<param name="lineA">(Geometry.Line) LineA of lines to intersect</param>
    ///<param name="lineB">(Geometry.Line) LineB of lines to intersect</param>
    ///<returns>(Point3d * Point3d) containing a point on the first line and a point on the second line.</returns>
    static member LineLineIntersection(lineA:Line, lineB:Line) : Point3d * Point3d =
        let rc, a, b = Intersect.Intersection.LineLine(lineA, lineB)
        if not <| rc then  RhinoScriptingException.Raise "RhinoScriptSyntax.LineLineIntersection failed on lineA:%A lineB:%A , are they parallel?" lineA lineB
        lineA.PointAt(a), lineB.PointAt(b)

    ///<summary>Finds the longest distance between a line as a finite chord, and a point.</summary>
    ///<param name="line">(Geometry.Line) Line</param>
    ///<param name="point">(Point3d) The test point or test line</param>
    ///<returns>(float) A distance (D) such that if Q is any point on the line and P is any point on the other object,
    /// then D is bigger than Rhino.Distance(Q, P).</returns>
    static member LineMaxDistanceTo(line:Line, point:Point3d) : float =
        line.MaximumDistanceTo(point)
    ///<summary>Finds the longest distance between a line as a finite chord, and a line.</summary>
    ///<param name="line">(Geometry.Line) Line</param>
    ///<param name="line2">(Geometry.Line) The test line</param>
    ///<returns>(float) A distance (D) such that if Q is any point on the line and P is any point on the other object,
    /// then D is bigger than Rhino.Distance(Q, P).</returns>
    static member LineMaxDistanceTo(line:Line, line2:Line) : float =
        line.MaximumDistanceTo(line2)


    ///<summary>Finds the shortest distance between a line as a finite chord, and a point or another line.</summary>
    ///<param name="line">(Geometry.Line) Line</param>
    ///<param name="point">(Point3d) The test point</param>
    ///<returns>(float) A distance (D) such that if Q is any point on the line and P is any point on the other object,
    /// then D is smaller than Rhino.Distance(Q, P).</returns>
    static member LineMinDistanceTo(line:Line, point:Point3d) : float =
        line.MinimumDistanceTo(point)

    ///<summary>Finds the shortest distance between a line as a finite chord, and a point or another line.</summary>
    ///<param name="line">(Geometry.Line) Line</param>
    ///<param name="line2">(Geometry.Line) The test line</param>
    ///<returns>(float) A distance (D) such that if Q is any point on the line and P is any point on the other object,
    /// then D is smaller than Rhino.Distance(Q, P).</returns>
    static member LineMinDistanceTo(line:Line, line2:Line) : float =
        line.MinimumDistanceTo(line2)



    ///<summary>Returns a Plane that contains the line. The origin of the Plane is at the start of
    ///    the line. If possible, a Plane parallel to the world XY, YZ, or ZX Plane is returned.</summary>
    ///<param name="line">(Geometry.Line) a Line</param>
    ///<returns>(Plane) The Plane.</returns>
    static member LinePlane(line:Line) : Plane =
        let rc, plane = line.TryGetPlane()
        if not <| rc then  RhinoScriptingException.Raise "RhinoScriptSyntax.LinePlane failed.  line:'%A'" line
        plane


    ///<summary>Calculates the intersection of a line and a Plane.</summary>
    ///<param name="line">(Line) The line to intersect</param>
    ///<param name="plane">(Plane) The Plane to intersect</param>
    ///<returns>(Point3d) The 3D point of intersection is successful.</returns>
    static member LinePlaneIntersection(line:Line, plane:Plane) : Point3d =
        let rc, t = Intersect.Intersection.LinePlane(line, plane)
        if  not <| rc then  RhinoScriptingException.Raise "RhinoScriptSyntax.LinePlaneIntersection failed. Parallel? line:'%A' plane:'%A'" line plane
        line.PointAt(t)


    ///<summary>Calculates the intersection of a line and a sphere.</summary>
    ///<param name="line">(Geometry.Line) The line</param>
    ///<param name="sphereCenter">(Point3d) The center point of the sphere</param>
    ///<param name="sphereRadius">(float) The radius of the sphere</param>
    ///<returns>(Point3d array) list of intersection points.</returns>
    static member LineSphereIntersection(line:Line, sphereCenter:Point3d, sphereRadius:float) : Point3d array =
        let sphere = Sphere(sphereCenter, sphereRadius)
        let rc, pt1, pt2 = Intersect.Intersection.LineSphere(line, sphere)
        if rc= Intersect.LineSphereIntersection.None then  [||]
        elif rc= Intersect.LineSphereIntersection.Single then  [|pt1|]
        else [|pt1; pt2|]


    ///<summary>Transforms a line.</summary>
    ///<param name="lineId">(Guid) The line to transform</param>
    ///<param name="xForm">(Transform) The transformation to apply</param>
    ///<param name="copy">(bool) Optional, default value: <c>false</c>. Copy the Line object</param>
    ///<returns>(Guid) The same Guid, or a new Guid if copy=true.</returns>
    static member LineTransform(    lineId:Guid,
                                    xForm:Transform,
                                    [<OPT;DEF(false)>]copy:bool)  : Guid =

        // the original python  implementation has a bug, does not return Guid: https://github.com/mcneel/rhinoscriptsyntax/pull/204
        let line = RhinoScriptSyntax.CoerceLine lineId
        if copy then
            let ln = Line(line.From,line.To)
            let success = ln.Transform(xForm)
            if not <| success then  RhinoScriptingException.Raise "RhinoScriptSyntax.LineTransform unable to transform line %A with  %A" line xForm
            State.Ot.AddLine(ln)
        else
            // if not <| State.Ot.Replace(lineId,ln) then  RhinoScriptingException.Raise "RhinoScriptSyntax.LineTransform unable to replace geometry: line %A with  %A" line xForm
            let success =line.Transform(xForm)
            if not <| success then  RhinoScriptingException.Raise "RhinoScriptSyntax.LineTransform unable to transform line %A with  %A" line xForm
            lineId


    //---End of header marker: don't change: {@$%^&*()*&^%$@}


    ///<summary>Verifies the existence of a line-type in the document.</summary>
    ///<param name="name">(string) The name of an existing line-type</param>
    ///<returns>(bool) True or False.</returns>
    static member IsLinetype(name:string) : bool =
        notNull <| State.Doc.Linetypes.FindName(name)


    ///<summary>Checks if an existing line-type is from a reference file.</summary>
    ///<param name="name">(string) The name of an existing line-type</param>
    ///<returns>(bool) True or False.</returns>
    static member IsLinetypeReference(name:string) : bool =
        let lt = State.Doc.Linetypes.FindName(name)
        if isNull lt then RhinoScriptingException.Raise "RhinoScriptSyntax.IsLinetypeReference unable to find '%s' in a line-types" name
        lt.IsReference


    ///<summary>Returns number of line-types in the document.</summary>
    ///<returns>(int) The number of line-types in the document.</returns>
    static member LinetypeCount() : int =
        State.Doc.Linetypes.Count


    ///<summary>Returns names of all line-types in the document.</summary>
    ///<returns>(string ResizeArray) list of line-type names.</returns>
    static member LinetypeNames() : string ResizeArray =
        let count = State.Doc.Linetypes.Count
        let rc = ResizeArray()
        for i = 0 to count - 1 do
            let linetype = State.Doc.Linetypes.[i]
            if not linetype.IsDeleted then  rc.Add(linetype.Name)
        rc



    //---End of header marker: don't change: {@$%^&*()*&^%$@}



    ///<summary>Add material to a layer and returns the new material's index. If the
    ///    layer already has a material, then the layer's current material index is
    ///    returned.</summary>
    ///<param name="layer">(string) Name of an existing layer.</param>
    ///<returns>(int) Material index of the layer.</returns>
    static member AddMaterialToLayer(layer:string) : int =
        let layer = RhinoScriptSyntax.CoerceLayer(layer)
        if layer.RenderMaterialIndex> -1 then layer.RenderMaterialIndex
        else
            let materialindex = State.Doc.Materials.Add()
            layer.RenderMaterialIndex <- materialindex
            State.Doc.Views.Redraw()
            materialindex

    ///<summary>Adds material to an object and returns the new material's index. If the
    ///    object already has a material, the object's current material index is returned.</summary>
    ///<param name="objectId">(Guid) Identifier of an object.</param>
    ///<returns>(int) material index of the object.</returns>
    static member AddMaterialToObject(objectId:Guid) : int =
        let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let mutable attr = rhinoObject.Attributes
        if attr.MaterialSource <> DocObjects.ObjectMaterialSource.MaterialFromObject then
            attr.MaterialSource <- DocObjects.ObjectMaterialSource.MaterialFromObject
            State.Doc.Objects.ModifyAttributes(rhinoObject, attr, true)|> ignore
            attr <- rhinoObject.Attributes
        let mutable materialindex = attr.MaterialIndex
        if materialindex> -1 then materialindex
        else
            materialindex <- State.Doc.Materials.Add()
            attr.MaterialIndex <- materialindex
            State.Doc.Objects.ModifyAttributes(rhinoObject, attr, true)|> ignore
            materialindex


    ///<summary>Copies definition of a source material to a destination material.</summary>
    ///<param name="sourceIndex">(int) Source index of materials to copy.</param>
    ///<param name="destinationIndex">(int) Destination index materials to copy.</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member CopyMaterial(sourceIndex:int, destinationIndex:int) : bool =
        if sourceIndex = destinationIndex then true // originally false
        else
            let source = State.Doc.Materials.[sourceIndex]
            if source|> isNull  then false
            else
                let rc = State.Doc.Materials.Modify(source, destinationIndex, true)
                if rc then State.Doc.Views.Redraw()
                rc


    ///<summary>Verifies a material is a copy of Rhino's built-in "default" material.
    ///    The default material is used by objects and layers that have not been
    ///    assigned a material.</summary>
    ///<param name="materialIndex">(int) The zero-based material index.</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member IsMaterialDefault(materialIndex:int) : bool =
        let mat = State.Doc.Materials.[materialIndex]
        notNull mat && mat.IsDefaultMaterial


    ///<summary>Verifies a material is referenced from another file.</summary>
    ///<param name="materialIndex">(int) The zero-based material index.</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member IsMaterialReference(materialIndex:int) : bool =
        let mat = State.Doc.Materials.[materialIndex]
        notNull mat && mat.IsReference


    ///<summary>Copies the material definition from one material to one or more objects.</summary>
    ///<param name="source">(Guid) Source material index -or- identifier of the source object.
    ///    The object must have a material assigned.</param>
    ///<param name="destination">(Guid seq) Id of the destination object.</param>
    ///<returns>(unit) void, nothing.</returns>
    static member MatchMaterial(source:Guid, destination:Guid seq) : unit =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(source)
        let source = rhobj.Attributes.MaterialIndex
        let mat = State.Doc.Materials.[source]
        if isNull mat then RhinoScriptingException.Raise "RhinoScriptSyntax.MatchMaterial failed.  source:'%A' destination:'%A'" source destination

        for objectId in destination do
            let rhobj = State.Doc.Objects.FindId(objectId)
            if notNull rhobj then
                rhobj.Attributes.MaterialIndex <- source
                rhobj.Attributes.MaterialSource <- DocObjects.ObjectMaterialSource.MaterialFromObject
                rhobj.CommitChanges() |> ignore
        State.Doc.Views.Redraw()



    ///<summary>Returns a material's bump bitmap filename.</summary>
    ///<param name="materialIndex">(int) Zero based material index.</param>
    ///<returns>(string) The current bump bitmap filename.
    /// Or an empty string if no Bump texture is present on the Material.</returns>
    static member MaterialBump(materialIndex:int) : string = //GET
        let mat = State.Doc.Materials.[materialIndex]
        if mat|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialBump failed.  materialIndex:'%A'" materialIndex
        let texture = mat.GetTexture(DocObjects.TextureType.Bump)
        if notNull texture then texture.FileName else ""


    ///<summary>Modifies a material's bump bitmap filename.</summary>
    ///<param name="materialIndex">(int) Zero based material index.</param>
    ///<param name="filename">(string) The bump bitmap filename.</param>
    ///<returns>(unit) void, nothing.</returns>
    static member MaterialBump(materialIndex:int, filename:string) : unit = //SET
        let mat = State.Doc.Materials.[materialIndex]
        if mat|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialBump failed.  materialIndex:'%A' filename:'%A'" materialIndex filename
        if IO.File.Exists filename then
            let texture = new DocObjects.Texture()
            texture.FileName <- filename
            if not <| mat.SetTexture(texture,DocObjects.TextureType.Bump) then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialBump failed.  materialIndex:'%A' filename:'%A'" materialIndex filename
            mat.CommitChanges() |> ignore
            State.Doc.Views.Redraw()
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialBump failed.  materialIndex:'%A' filename:'%A'" materialIndex filename


    ///<summary>Returns a material's diffuse color.</summary>
    ///<param name="materialIndex">(int) Zero based material index.</param>
    ///<returns>(Drawing.Color) The current material color.</returns>
    static member MaterialColor(materialIndex:int) : Drawing.Color = //GET
        let mat = State.Doc.Materials.[materialIndex]
        if mat|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialColor failed.  materialIndex:'%A'" materialIndex
        let rc = mat.DiffuseColor
        rc

    ///<summary>Modifies a material's diffuse color.</summary>
    ///<param name="materialIndex">(int) Zero based material index.</param>
    ///<param name="color">(Drawing.Color) The new color value</param>
    ///<returns>(unit) void, nothing.</returns>
    static member MaterialColor(materialIndex:int, color:Drawing.Color) : unit = //SET
        let mat = State.Doc.Materials.[materialIndex]
        if mat|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialColor failed.  materialIndex:'%A' color:'%A'" materialIndex color
        mat.DiffuseColor <- color
        mat.CommitChanges() |> ignore
        State.Doc.Views.Redraw()


    ///<summary>Returns a material's environment bitmap filename.</summary>
    ///<param name="materialIndex">(int) Zero based material index.</param>
    ///<returns>(string) The current environment bitmap filename.
    /// Or an empty string if no MaterialEnvironmentMap texture is present on the Material.</returns>
    static member MaterialEnvironmentMap(materialIndex:int) : string = //GET
        let mat = State.Doc.Materials.[materialIndex]
        if mat|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialEnvironmentMap failed.  materialIndex:'%A'" materialIndex
        let texture = mat.GetTexture(DocObjects.TextureType.Emap)
        if notNull texture then texture.FileName  else ""

    ///<summary>Modifies a material's environment bitmap filename.</summary>
    ///<param name="materialIndex">(int) Zero based material index.</param>
    ///<param name="filename">(string) The environment bitmap filename</param>
    ///<returns>(unit) void, nothing.</returns>
    static member MaterialEnvironmentMap(materialIndex:int, filename:string) : unit = //SET
        let mat = State.Doc.Materials.[materialIndex]
        if mat|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialEnvironmentMap failed.  materialIndex:'%A' filename:'%A'" materialIndex filename
        if IO.File.Exists filename then
            let texture = new DocObjects.Texture()
            texture.FileName <- filename
            if not <| mat.SetTexture(texture,DocObjects.TextureType.Emap)then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialEnvironmentMap failed.  materialIndex:'%A' filename:'%A'" materialIndex filename
            mat.CommitChanges() |> ignore
            State.Doc.Views.Redraw()
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialEnvironmentMap failed.  materialIndex:'%A' filename:'%A'" materialIndex filename



    ///<summary>Returns a material's user defined name.</summary>
    ///<param name="materialIndex">(int) Zero based material index.</param>
    ///<returns>(string) The current material name.</returns>
    static member MaterialName(materialIndex:int) : string = //GET
        let mat = State.Doc.Materials.[materialIndex]
        if mat|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialName failed.  materialIndex:'%A'" materialIndex
        let rc = mat.Name
        rc

    ///<summary>Modifies a material's user defined name.</summary>
    ///<param name="materialIndex">(int) Zero based material index</param>
    ///<param name="name">(string) The new name</param>
    ///<returns>(unit) void, nothing.</returns>
    static member MaterialName(materialIndex:int, name:string) : unit = //SET
        let mat = State.Doc.Materials.[materialIndex]
        if mat|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialName failed.  materialIndex:'%A' name:'%A'" materialIndex name
        mat.Name <- name
        mat.CommitChanges() |> ignore



    ///<summary>Returns a material's reflective color.</summary>
    ///<param name="materialIndex">(int) Zero based material index.</param>
    ///<returns>(Drawing.Color) The current material reflective color.</returns>
    static member MaterialReflectiveColor(materialIndex:int) : Drawing.Color = //GET
        let mat = State.Doc.Materials.[materialIndex]
        if mat|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialReflectiveColor failed.  materialIndex:'%A'" materialIndex
        let rc = mat.ReflectionColor
        rc

    ///<summary>Modifies a material's reflective color.</summary>
    ///<param name="materialIndex">(int) Zero based material index.</param>
    ///<param name="color">(Drawing.Color) The new color value.</param>
    ///<returns>(unit) void, nothing.</returns>
    static member MaterialReflectiveColor(materialIndex:int, color:Drawing.Color) : unit = //SET
        let mat = State.Doc.Materials.[materialIndex]
        if mat|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialReflectiveColor failed.  materialIndex:'%A' color:'%A'" materialIndex color
        mat.ReflectionColor <- color
        mat.CommitChanges() |> ignore
        State.Doc.Views.Redraw()



    ///<summary>Returns a material's shine value.</summary>
    ///<param name="materialIndex">(int) Zero based material index.</param>
    ///<returns>(float) The current material shine value
    ///    0.0 being matte and 255.0 being glossy.</returns>
    static member MaterialShine(materialIndex:int) : float = //GET
        let mat = State.Doc.Materials.[materialIndex]
        if mat|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialShine failed.  materialIndex:'%A'" materialIndex
        let rc = mat.Shine
        rc

    ///<summary>Modifies a material's shine value.</summary>
    ///<param name="materialIndex">(int) Zero based material index</param>
    ///<param name="shine">(float) The new shine value. A material's shine value ranges from 0.0 to 255.0, with
    ///    0.0 being matte and 255.0 being glossy</param>
    ///<returns>(unit) void, nothing.</returns>
    static member MaterialShine(materialIndex:int, shine:float) : unit = //SET
        let mat = State.Doc.Materials.[materialIndex]
        if mat|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialShine failed.  materialIndex:'%A' shine:'%A'" materialIndex shine
        mat.Shine <- shine
        mat.CommitChanges() |> ignore
        State.Doc.Views.Redraw()



    ///<summary>Returns a material's texture bitmap filename.</summary>
    ///<param name="materialIndex">(int) Zero based material index.</param>
    ///<returns>(string) The current texture bitmap filename.
    /// Or an empty string if no MaterialTexture is present on the Material</returns>
    static member MaterialTexture(materialIndex:int) : string = //GET
        let mat = State.Doc.Materials.[materialIndex]
        if mat|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialTexture failed.  materialIndex:'%A'" materialIndex
        let texture = mat.GetTexture(DocObjects.TextureType.Bitmap)
        if notNull texture then texture.FileName else ""

    ///<summary>Modifies a material's texture bitmap filename.</summary>
    ///<param name="materialIndex">(int) Zero based material index.</param>
    ///<param name="filename">(string) The texture bitmap filename.</param>
    ///<returns>(unit) void, nothing.</returns>
    static member MaterialTexture(materialIndex:int, filename:string) : unit = //SET
        let mat = State.Doc.Materials.[materialIndex]
        if mat|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialTexture failed.  materialIndex:'%A' filename:'%A'" materialIndex filename
        if IO.File.Exists filename then
            let texture = new DocObjects.Texture()
            texture.FileName <- filename
            if not <| mat.SetTexture(texture,DocObjects.TextureType.Bitmap) then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialTexture failed.  materialIndex:'%A' filename:'%A'" materialIndex filename
            mat.CommitChanges() |> ignore
            State.Doc.Views.Redraw()
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialTexture failed.  materialIndex:'%A' filename:'%A'" materialIndex filename


    ///<summary>Returns a material's transparency value.</summary>
    ///<param name="materialIndex">(int) Zero based material index.</param>
    ///<returns>(float) The current material transparency value
    ///    0.0 being opaque and 1.0 being transparent.</returns>
    static member MaterialTransparency(materialIndex:int) : float = //GET
        let mat = State.Doc.Materials.[materialIndex]
        if mat|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialTransparency failed.  materialIndex:'%A'" materialIndex
        let rc = mat.Transparency
        rc

    ///<summary>Modifies a material's transparency value.</summary>
    ///<param name="materialIndex">(int) Zero based material index.</param>
    ///<param name="transparency">(float) The new transparency value. A material's transparency value ranges from 0.0 to 1.0, with
    ///    0.0 being opaque and 1.0 being transparent.</param>
    ///<returns>(unit) void, nothing.</returns>
    static member MaterialTransparency(materialIndex:int, transparency:float) : unit = //SET
        let mat = State.Doc.Materials.[materialIndex]
        if mat|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialTransparency failed.  materialIndex:'%A' transparency:'%A'" materialIndex transparency
        mat.Transparency <- transparency
        mat.CommitChanges() |> ignore
        State.Doc.Views.Redraw()



    ///<summary>Returns a material's transparency bitmap filename.</summary>
    ///<param name="materialIndex">(int) Zero based material index.</param>
    ///<returns>(string) The current transparency bitmap filename.
    /// Or an empty string if no Bump texture is present on the Material.</returns>
    static member MaterialTransparencyMap(materialIndex:int) : string = //GET
        let mat = State.Doc.Materials.[materialIndex]
        if mat|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialTransparencyMap failed.  materialIndex:'%A'" materialIndex
        let texture = mat.GetTexture(DocObjects.TextureType.Transparency)
        if notNull texture then texture.FileName else ""


    ///<summary>Modifies a material's transparency bitmap filename.</summary>
    ///<param name="materialIndex">(int) Zero based material index.</param>
    ///<param name="filename">(string) The transparency bitmap filename.</param>
    ///<returns>(unit) void, nothing.</returns>
    static member MaterialTransparencyMap(materialIndex:int, filename:string) : unit = //SET
        let mat = State.Doc.Materials.[materialIndex]
        if mat|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialTransparencyMap failed.  materialIndex:'%A' filename:'%A'" materialIndex filename
        if IO.File.Exists filename then
            let texture = new DocObjects.Texture()
            texture.FileName <- filename
            if not <| mat.SetTexture(texture,DocObjects.TextureType.Transparency)then RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialTransparencyMap failed.  materialIndex:'%A' filename:'%A'" materialIndex filename
            mat.CommitChanges() |> ignore
            State.Doc.Views.Redraw()
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.MaterialTransparencyMap failed.  materialIndex:'%A' filename:'%A'" materialIndex filename



    ///<summary>Resets a material to Rhino's default material.</summary>
    ///<param name="materialIndex">(int) Zero based material index</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member ResetMaterial(materialIndex:int) : bool =
        let mat = State.Doc.Materials.[materialIndex]
        if mat|> isNull  then false
        else
            let rc = State.Doc.Materials.ResetMaterial(materialIndex)
            State.Doc.Views.Redraw()
            rc



    //---End of header marker: don't change: {@$%^&*()*&^%$@}


    ///<summary>Add a Mesh object to the document.</summary>
    ///<param name="vertices">(Point3d seq) List of 3D points defining the vertices of the Mesh</param>
    ///<param name="faceVertices">(int IList seq) List containing lists of 3 or 4 numbers that define the
    ///    vertex indices for each face of the Mesh. If the third a fourth vertex
    ///    indices of a face are identical, a triangular face will be created</param>
    ///<param name="vertexNormals">(Vector3f seq) Optional, List of 3D vectors defining the vertex normals of
    ///    the Mesh. Note, for every vertex, there must be a corresponding vertex normal</param>
    ///<param name="textureCoordinates">(Point2f seq) Optional, List of 2D texture coordinates. For every
    ///    vertex, there must be a corresponding texture coordinate</param>
    ///<param name="vertexColors">(Drawing.Color seq) Optional, A list of color values. For every vertex,
    ///    there must be a corresponding vertex color.</param>
    ///<returns>(Guid) Identifier of the new object.</returns>
    static member AddMesh( vertices:Point3d seq, //TODO how to construct Ngon Mesh ???
                           faceVertices:seq<#IList<int>>, // works on  nested arrays !
                           [<OPT;DEF(null:Vector3f seq)>]vertexNormals:Vector3f seq,
                           [<OPT;DEF(null:Point2f seq)>]textureCoordinates:Point2f seq,
                           [<OPT;DEF(null:Drawing.Color seq)>]vertexColors:Drawing.Color seq) : Guid =
        let mesh = new Mesh()
        for pt in vertices do
            mesh.Vertices.Add(pt) |> ignore

        for face in faceVertices do
            let l = Seq.length(face)
            if l = 3 then
                mesh.Faces.AddFace(face.[0], face.[1], face.[2]) |> ignore
            elif l = 4 then
                mesh.Faces.AddFace(face.[0], face.[1], face.[2], face.[3]) |> ignore
            else
                RhinoScriptingException.Raise "RhinoScriptSyntax.AddMesh: Expected 3 or 4 indices for a face but got %d" l

        if notNull vertexNormals then
            let count = Seq.length(vertexNormals)
            let normals = Array.zeroCreate count
            for i, normal in Seq.indexed(vertexNormals) do
                normals.[i] <- normal
            mesh.Normals.SetNormals(normals)    |> ignore

        if notNull textureCoordinates then
            let count = Seq.length(textureCoordinates)
            let tcs = Array.zeroCreate count
            for i, tc in Seq.indexed(textureCoordinates) do
                tcs.[i] <-  tc
            mesh.TextureCoordinates.SetTextureCoordinates(tcs)  |> ignore

        if notNull vertexColors then
            let count = Seq.length(vertexColors)
            let colors = Array.zeroCreate count
            // for i, color in Seq.indexed(vertexColors) do
                //colors.[i] = RhinoScriptSyntax.CoerceColor(color)
            mesh.VertexColors.SetColors(colors)   |>   ignore

        let rc = State.Doc.Objects.AddMesh(mesh)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddMesh: Unable to add mesh to document. vertices:'%A' faceVertices:'%A' vertexNormals:'%A' textureCoordinates:'%A' vertexColors:'%A'" vertices faceVertices vertexNormals textureCoordinates vertexColors
        State.Doc.Views.Redraw()
        rc

    ///<summary>Add a Mesh object to the document.</summary>
    ///<param name="vertices">(Point3d seq) List of 3D points defining the vertices of the Mesh</param>
    ///<param name="faceVertices">(int*int*int*int seq) Tuple  of  4 integers that define the
    ///    vertex indices for each face of the Mesh. If the third a fourth vertex
    ///    indices of a face are identical, a triangular face will be created</param>
    ///<param name="vertexNormals">(Vector3f seq) Optional, List of 3D vectors defining the vertex normals of
    ///    the Mesh. Note, for every vertex, there must be a corresponding vertex normal</param>
    ///<param name="textureCoordinates">(Point2f seq) Optional, List of 2D texture coordinates. For every
    ///    vertex, there must be a corresponding texture coordinate</param>
    ///<param name="vertexColors">(Drawing.Color seq) Optional, A list of color values. For every vertex,
    ///    there must be a corresponding vertex color.</param>
    ///<returns>(Guid) Identifier of the new object.</returns>
    static member AddMesh( vertices:Point3d seq, //TODO how to construct Ngon Mesh ???
                           faceVertices:seq<int*int*int*int>,
                           [<OPT;DEF(null:Vector3f seq)>]vertexNormals:Vector3f seq,
                           [<OPT;DEF(null:Point2f seq)>]textureCoordinates:Point2f seq,
                           [<OPT;DEF(null:Drawing.Color seq)>]vertexColors:Drawing.Color seq) : Guid =
        let mesh = new Mesh()
        for pt in vertices do
            mesh.Vertices.Add(pt) |> ignore

        for face in faceVertices do
            let a,b,c,d = face
            if c = d then
                mesh.Faces.AddFace(a,b,c) |> ignore
            else
                mesh.Faces.AddFace(a,b,c,d) |> ignore

        if notNull vertexNormals then
            let count = Seq.length(vertexNormals)
            let normals = Array.zeroCreate count
            for i, normal in Seq.indexed(vertexNormals) do
                normals.[i] <- normal
            mesh.Normals.SetNormals(normals)    |> ignore

        if notNull textureCoordinates then
            let count = Seq.length(textureCoordinates)
            let tcs = Array.zeroCreate count
            for i, tc in Seq.indexed(textureCoordinates) do
                tcs.[i] <-  tc
            mesh.TextureCoordinates.SetTextureCoordinates(tcs)  |> ignore

        if notNull vertexColors then
            let count = Seq.length(vertexColors)
            let colors = Array.zeroCreate count
            // for i, color in Seq.indexed(vertexColors) do
                //colors.[i] = RhinoScriptSyntax.CoerceColor(color)
            mesh.VertexColors.SetColors(colors)   |>   ignore

        let rc = State.Doc.Objects.AddMesh(mesh)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddMesh: Unable to add mesh to document.  vertices:'%A' faceVertices:'%A' vertexNormals:'%A' textureCoordinates:'%A' vertexColors:'%A'" vertices faceVertices vertexNormals textureCoordinates vertexColors
        State.Doc.Views.Redraw()
        rc



    ///<summary>Creates a new Mesh with just one quad face .</summary>
    ///<param name="pointA">(Point3d) First corner point</param>
    ///<param name="pointB">(Point3d) Second  corner point</param>
    ///<param name="pointC">(Point3d) Third corner point</param>
    ///<param name="pointD">(Point3d) Fourth corner point</param>
    ///<returns>(Guid) The identifier of the new Mesh.</returns>
    static member AddMeshQuad(pointA:Point3d , pointB:Point3d , pointC: Point3d , pointD: Point3d) : Guid =
          let mesh = new Mesh()
          mesh.Vertices.Add(pointA) |> ignore
          mesh.Vertices.Add(pointB) |> ignore
          mesh.Vertices.Add(pointC) |> ignore
          mesh.Vertices.Add(pointD) |> ignore
          mesh.Faces.AddFace(0,1,2,3) |> ignore
          let rc = State.Doc.Objects.AddMesh(mesh)
          if rc = Guid.Empty then  RhinoScriptingException.Raise "RhinoScriptSyntax.AddMeshQuad failed.  points:'%A, %A, %A and %A" pointA pointB pointC pointD
          State.Doc.Views.Redraw()
          rc

    ///<summary>Creates a new Mesh with just one triangle face .</summary>
    ///<param name="pointA">(Point3d) First corner point</param>
    ///<param name="pointB">(Point3d) Second  corner point</param>
    ///<param name="pointC">(Point3d) Third corner point</param>
    ///<returns>(Guid) The identifier of the new Mesh.</returns>
    static member AddMeshTriangle(pointA:Point3d , pointB:Point3d , pointC: Point3d ) : Guid =
          let mesh = new Mesh()
          mesh.Vertices.Add(pointA) |> ignore
          mesh.Vertices.Add(pointB) |> ignore
          mesh.Vertices.Add(pointC) |> ignore
          mesh.Faces.AddFace(0,1,2) |> ignore
          let rc = State.Doc.Objects.AddMesh(mesh)
          if rc = Guid.Empty then  RhinoScriptingException.Raise "RhinoScriptSyntax.AddMeshTriangle failed.  points:'%A, %A and %A" pointA pointB pointC
          State.Doc.Views.Redraw()
          rc

    ///<summary>Creates a planar Mesh from a closed, planar Curve.</summary>
    ///<param name="objectId">(Guid) Identifier of a closed, planar Curve</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>false</c>
    ///    If True, delete the input Curve defined by objectId</param>
    ///<returns>(Guid) id of the new Mesh.</returns>
    static member AddPlanarMesh(objectId:Guid, [<OPT;DEF(false)>]deleteInput:bool) : Guid =
        let curve = RhinoScriptSyntax.CoerceCurve(objectId)
        let tolerance = State.Doc.ModelAbsoluteTolerance
        let mesh = Mesh.CreateFromPlanarBoundary(curve, MeshingParameters.Default, tolerance)
        if isNull mesh then RhinoScriptingException.Raise "RhinoScriptSyntax.AddPlanarMesh failed.  objectId:'%s' deleteInput:'%A'" (Nice.str objectId) deleteInput
        if deleteInput then
            let ob = RhinoScriptSyntax.CoerceGuid(objectId)
            if not<| State.Doc.Objects.Delete(ob, true) then RhinoScriptingException.Raise "RhinoScriptSyntax.AddPlanarMesh failed to delete input.  objectId:'%s' deleteInput:'%A'" (Nice.str objectId) deleteInput
        let rc = State.Doc.Objects.AddMesh(mesh)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddPlanarMesh: Unable to add mesh to document.  objectId:'%s' deleteInput:'%A'" (Nice.str objectId) deleteInput
        State.Doc.Views.Redraw()
        rc


    ///<summary>Calculates the intersection of a Curve object and a Mesh object.</summary>
    ///<param name="curveId">(Guid) Identifier of a Curve object</param>
    ///<param name="meshId">(Guid) Identifier or a Mesh object</param>
    ///<returns>(Point3d array * int array) two arrays as tuple:
    ///        [0] = point of intersection
    ///        [1] = Mesh face index where intersection lies.</returns>
    static member CurveMeshIntersection( curveId:Guid,
                                         meshId:Guid) : array<Point3d>*array<int> =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let mesh = RhinoScriptSyntax.CoerceMesh(meshId)
        let tolerance = State.Doc.ModelAbsoluteTolerance
        let polylinecurve = curve.ToPolyline(0 , 0 , 0.0 , 0.0 , 0.0, tolerance , 0.0 , 0.0 , true)
        let pts, faceids = Intersect.Intersection.MeshPolyline(mesh, polylinecurve)
        if isNull pts then RhinoScriptingException.Raise "RhinoScriptSyntax.CurveMeshIntersection failed. curveId:'%s' meshId:'%s'" (Nice.str curveId) (Nice.str meshId)
        pts, faceids


    ///<summary>Returns number of Meshes that could be created by calling SplitDisjointMesh.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(int) The number of Meshes that could be created.</returns>
    static member DisjointMeshCount(objectId:Guid) : int =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        mesh.DisjointMeshCount


    ///<summary>Creates Curves that duplicates a Mesh border.</summary>
    ///<param name="meshId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(Guid ResizeArray) list of Curve ids.</returns>
    static member DuplicateMeshBorder(meshId:Guid) : Guid ResizeArray =
        let mesh = RhinoScriptSyntax.CoerceMesh(meshId)
        let polylines = mesh.GetNakedEdges()
        let rc = ResizeArray()
        if notNull polylines then
            for polyline in polylines do
                let objectId = State.Doc.Objects.AddPolyline(polyline)
                if objectId <> Guid.Empty then rc.Add(objectId)
        if rc.Count <> 0 then State.Doc.Views.Redraw()
        rc


    ///<summary>Explodes a Mesh object, or Mesh objects int subMeshes. A subMesh is a
    ///    collection of Mesh faces that are contained within a closed loop of
    ///    unwelded Mesh edges. Unwelded Mesh edges are where the Mesh faces that
    ///    share the edge have unique Mesh vertices (not Mesh topology vertices)
    ///    at both ends of the edge.</summary>
    ///<param name="meshIds">(Guid seq) List of Mesh identifiers</param>
    ///<param name="delete">(bool) Optional, default value: <c>false</c>
    ///    Delete the input Meshes</param>
    ///<returns>(Guid ResizeArray) List of resulting objects after explode.</returns>
    static member ExplodeMeshes(meshIds:Guid seq, [<OPT;DEF(false)>]delete:bool) : Guid ResizeArray =
        //id = RhinoScriptSyntax.CoerceGuid(meshIds)
        let rc = ResizeArray()
        for meshid in meshIds do
            let mesh = RhinoScriptSyntax.CoerceMesh(meshid)
            if notNull mesh then
                let submeshes = mesh.ExplodeAtUnweldedEdges()
                if notNull submeshes then
                    for submesh in submeshes do
                        let objectId = State.Doc.Objects.AddMesh(submesh)
                        if objectId <> Guid.Empty then rc.Add(objectId)
                if delete then
                    State.Doc.Objects.Delete(meshid, true)|> ignore
        if rc.Count>0 then State.Doc.Views.Redraw()
        rc


    ///<summary>Verifies if an object is a Mesh.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True , otherwise False.</returns>
    static member IsMesh(objectId:Guid) : bool =
        RhinoScriptSyntax.TryCoerceMesh(objectId)
        |> Option.isSome


    ///<summary>Verifies a Mesh object is closed.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(bool) True , otherwise False.</returns>
    static member IsMeshClosed(objectId:Guid) : bool =
        match RhinoScriptSyntax.TryCoerceMesh(objectId) with
        | Some mesh -> mesh.IsClosed
        | None -> false


    ///<summary>Verifies a Mesh object is manifold. A Mesh for which every edge is shared
    ///    by at most two faces is called manifold. If a Mesh has at least one edge
    ///    that is shared by more than two faces, then that Mesh is called non-manifold.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(bool) True, otherwise False.</returns>
    static member IsMeshManifold(objectId:Guid) : bool =
        match RhinoScriptSyntax.TryCoerceMesh(objectId) with
        | Some mesh -> mesh.IsManifold(true)  |> t1
        | None -> false



    ///<summary>Verifies a point is on a Mesh.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<param name="point">(Point3d) Test point</param>
    ///<param name="tolerance">(float) Optional, Default Value <c>RhinoMath.SqrtEpsilon</c>
    ///    The testing tolerance</param>
    ///<returns>(bool) True , otherwise False.</returns>
    static member IsPointOnMesh(    objectId:Guid,
                                    point:Point3d,
                                    [<OPT;DEF(0.0)>]tolerance:float) : bool =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        //point = RhinoScriptSyntax.Coerce3dPoint(point)
        let maxDistance = Util.ifZero1 tolerance RhinoMath.SqrtEpsilon
        let pt = ref Point3d.Origin
        let face = mesh.ClosestPoint(point, pt, maxDistance)
        face>=0


    ///<summary>Joins two or or more Mesh objects together.</summary>
    ///<param name="meshes">(Mesh seq) Mesh objects</param>
    ///<returns>(Mesh) newly created Mesh.</returns>
    static member JoinMeshes(meshes:Mesh seq) : Mesh =
        let joinedMesh = new Mesh()
        joinedMesh.Append(meshes)
        joinedMesh

    ///<summary>Joins two or or more Mesh objects together.</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of two or more Mesh objects</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>false</c>
    ///    Delete input after joining</param>
    ///<returns>(Guid) identifier of newly created Mesh.</returns>
    static member JoinMeshes(objectIds:Guid seq, [<OPT;DEF(false)>]deleteInput:bool) : Guid =
        let meshes =  resizeArray { for objectId in objectIds do yield RhinoScriptSyntax.CoerceMesh(objectId) }
        let joinedMesh = new Mesh()
        joinedMesh.Append(meshes)
        let rc = State.Doc.Objects.AddMesh(joinedMesh)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.JoinMeshes: Failed to join Meshes %A" (Nice.str objectIds)
        if deleteInput then
            for objectId in objectIds do
                //guid = RhinoScriptSyntax.CoerceGuid(objectId)
                State.Doc.Objects.Delete(objectId, true) |> ignore
        State.Doc.Views.Redraw()
        rc


    ///<summary>Returns approximate area of one mesh object.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh objects</param>
    ///<returns>(float) total area of Mesh.</returns>
    static member MeshArea(objectId:Guid ) : float =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        let mp = AreaMassProperties.Compute(mesh)
        if notNull mp then
            mp.Area
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.MeshArea failed.  objectId:'%s'" (Nice.str objectId)



    ///<summary>Calculates the area centroid of a Mesh object.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(Point3d) representing the area centroid.</returns>
    static member MeshAreaCentroid(objectId:Guid) : Point3d =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        let mp = AreaMassProperties.Compute(mesh)
        if mp|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MeshAreaCentroid failed.  objectId:'%s'" (Nice.str objectId)
        mp.Centroid


    ///<summary>Performs boolean difference operation on two sets of input Meshes.</summary>
    ///<param name="input0">(Guid seq) Meshes to subtract from</param>
    ///<param name="input1">(Guid seq) Meshes to subtract with</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>true</c>
    ///    Delete the input Meshes</param>
    ///<returns>(Guid ResizeArray) identifiers of newly created Meshes.</returns>
    static member MeshBooleanDifference( input0:Guid seq,
                                         input1:Guid seq,
                                         [<OPT;DEF(true)>]deleteInput:bool) : Guid ResizeArray =
        let meshes0 =  resizeArray { for objectId in input0 do yield RhinoScriptSyntax.CoerceMesh(objectId) }
        let meshes1 =  resizeArray { for objectId in input1 do yield RhinoScriptSyntax.CoerceMesh(objectId) }
        if meshes0.Count = 0 || meshes1.Count = 0 then RhinoScriptingException.Raise "RhinoScriptSyntax.MeshBooleanDifference: No meshes to work with.  input0:'%A' input1:'%A' deleteInput:'%A'" input0 input1 deleteInput
        let newmeshes = Mesh.CreateBooleanDifference  (meshes0, meshes1)
        let rc = ResizeArray()
        for mesh in newmeshes do
            let objectId = State.Doc.Objects.AddMesh(mesh)
            if objectId <> Guid.Empty then rc.Add(objectId)
        if deleteInput then
            for objectId in Seq.append input0 input1 do
                //id = RhinoScriptSyntax.CoerceGuid(objectId)
                State.Doc.Objects.Delete(objectId, true) |> ignore
        State.Doc.Views.Redraw()
        rc


    ///<summary>Performs boolean intersection operation on two sets of input Meshes.</summary>
    ///<param name="input0">(Guid seq) Meshes to intersect</param>
    ///<param name="input1">(Guid seq) Meshes to intersect</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>true</c>
    ///    Delete the input Meshes</param>
    ///<returns>(Guid ResizeArray) identifiers of new Meshes.</returns>
    static member MeshBooleanIntersection( input0:Guid seq,
                                           input1:Guid seq,
                                           [<OPT;DEF(true)>]deleteInput:bool) : Guid ResizeArray =
        let meshes0 =  resizeArray { for objectId in input0 do yield RhinoScriptSyntax.CoerceMesh(objectId) }
        let meshes1 =  resizeArray { for objectId in input1 do yield RhinoScriptSyntax.CoerceMesh(objectId) }
        if meshes0.Count = 0 || meshes1.Count = 0 then RhinoScriptingException.Raise "RhinoScriptSyntax.MeshBooleanIntersection: No meshes to work with.  input0:'%A' input1:'%A' deleteInput:'%A'" input0 input1 deleteInput
        let newmeshes = Mesh.CreateBooleanIntersection  (meshes0, meshes1)
        let rc = ResizeArray()
        for mesh in newmeshes do
            let objectId = State.Doc.Objects.AddMesh(mesh)
            if objectId <> Guid.Empty then rc.Add(objectId)
        if deleteInput then
            for objectId in Seq.append input0 input1 do
                //id = RhinoScriptSyntax.CoerceGuid(objectId)
                State.Doc.Objects.Delete(objectId, true) |> ignore
        State.Doc.Views.Redraw()
        rc



    ///<summary>Performs boolean split operation on two sets of input Meshes.</summary>
    ///<param name="input0">(Guid seq) Meshes to split from</param>
    ///<param name="input1">(Guid seq) Meshes to split with</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>true</c>
    ///    Delete the input Meshes</param>
    ///<returns>(Guid ResizeArray) identifiers of new Meshes.</returns>
    static member MeshBooleanSplit( input0:Guid seq,
                                    input1:Guid seq,
                                    [<OPT;DEF(true)>]deleteInput:bool) : Guid ResizeArray =
        let meshes0 =  resizeArray { for objectId in input0 do yield RhinoScriptSyntax.CoerceMesh(objectId) }
        let meshes1 =  resizeArray { for objectId in input1 do yield RhinoScriptSyntax.CoerceMesh(objectId) }
        if meshes0.Count = 0 || meshes1.Count = 0 then RhinoScriptingException.Raise "RhinoScriptSyntax.MeshBooleanSplit: CreateBooleanSplit: No meshes to work with.  input0:'%A' input1:'%A' deleteInput:'%A'" input0 input1 deleteInput
        let newmeshes = Mesh.CreateBooleanSplit  (meshes0, meshes1)
        let rc = ResizeArray()
        for mesh in newmeshes do
            let objectId = State.Doc.Objects.AddMesh(mesh)
            if objectId <> Guid.Empty then rc.Add(objectId)
        if deleteInput then
            for objectId in Seq.append input0 input1 do
                State.Doc.Objects.Delete(objectId, true) |> ignore
        State.Doc.Views.Redraw()
        rc



    ///<summary>Performs boolean union operation on a set of input Meshes.</summary>
    ///<param name="meshIds">(Guid seq) Identifiers of Meshes</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>true</c>
    ///    Delete the input Meshes</param>
    ///<returns>(Guid ResizeArray) identifiers of new Meshes.</returns>
    static member MeshBooleanUnion(meshIds:Guid seq, [<OPT;DEF(true)>]deleteInput:bool) : Guid ResizeArray =
        if Seq.length(meshIds)<2 then RhinoScriptingException.Raise "RhinoScriptSyntax.MeshBooleanUnion: MeshIds must contain at least 2 meshes.  meshIds:'%A' deleteInput:'%A'" meshIds deleteInput
        let meshes =  resizeArray { for objectId in meshIds do yield RhinoScriptSyntax.CoerceMesh(objectId) }
        let newmeshes = Mesh.CreateBooleanUnion(meshes)
        let rc = ResizeArray()
        for mesh in newmeshes do
            let objectId = State.Doc.Objects.AddMesh(mesh)
            if objectId <> Guid.Empty then rc.Add(objectId)
        if rc.Count>0 && deleteInput then
            for objectId in meshIds do
                State.Doc.Objects.Delete(objectId, true) |> ignore
        State.Doc.Views.Redraw()
        rc


    ///<summary>Returns the point on a Mesh that is closest to a test point.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<param name="point">(Point3d) Point to test</param>
    ///<param name="maximumDistance">(float) Optional, Upper bound used for closest point calculation.
    ///    If you are only interested in finding a point Q on the Mesh when
    ///    point.DistanceTo(Q) is smaller than maximumDistance, then set maximumDistance to
    ///    that value</param>
    ///<returns>(Point3d * int) containing the results of the calculation where
    ///    [0] = the 3-D point on the Mesh
    ///    [1] = the index of the Mesh face on which the 3-D point lies.</returns>
    static member MeshClosestPoint( objectId:Guid,
                                    point:Point3d,
                                    [<OPT;DEF(0.0)>]maximumDistance:float) : Point3d * int =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        let pt = ref Point3d.Origin
        let face = mesh.ClosestPoint(point, pt, maximumDistance)
        if face<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.MeshClosestPoint failed.  objectId:'%s' point:'%A' maximumDistance:'%A'" (Nice.str objectId) point maximumDistance
        !pt, face


    ///<summary>Returns the center of each face of the Mesh object.</summary>
    ///<param name="meshId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(Point3d ResizeArray) points defining the center of each face.</returns>
    static member MeshFaceCenters(meshId:Guid) : Point3d ResizeArray =
        let mesh = RhinoScriptSyntax.CoerceMesh(meshId)
        resizeArray {for i = 0 to mesh.Faces.Count - 1 do mesh.Faces.GetFaceCenter(i) }


    ///<summary>Returns total face count of a Mesh object.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(int) The number of Mesh faces.</returns>
    static member MeshFaceCount(objectId:Guid) : int =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        mesh.Faces.Count


    ///<summary>Returns the face unit normal for each face of a Mesh object.</summary>
    ///<param name="meshId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(Vector3d ResizeArray) 3D vectors that define the face unit normals of the Mesh.</returns>
    static member MeshFaceNormals(meshId:Guid) : Vector3d ResizeArray =
        let mesh = RhinoScriptSyntax.CoerceMesh(meshId)
        if mesh.FaceNormals.Count <> mesh.Faces.Count then
            mesh.FaceNormals.ComputeFaceNormals() |> ignore
        let rc = ResizeArray()
        for i = 0 to mesh.FaceNormals.Count - 1 do
            let normal = mesh.FaceNormals.[i]
            rc.Add(Vector3d(normal))
        rc


    ///<summary>Returns face vertices of a Mesh.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<param name="faceType">(bool) Optional, default value: <c>true</c>
    ///    The face type to be returned.
    ///    True = both triangles and quads.
    ///    False = Quads are broken down into triangles</param>
    ///<returns>(Point3d ResizeArray) List of 3D points that define the face vertices of the Mesh.
    ///    If faceType is True, then faces are returned as both quads and triangles
    ///    (every four  3D points). For triangles, the third and fourth vertex will be identical.
    ///    If faceType is False, then faces are returned as only triangles
    ///    (very three 3D points). Quads will be converted to triangles.</returns>
    static member MeshFaces(objectId:Guid, [<OPT;DEF(true)>]faceType:bool) : Point3d ResizeArray =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        let rc = ResizeArray()
        for i = 0 to mesh.Faces.Count - 1 do
            let _, p0, p1, p2, p3 = mesh.Faces.GetFaceVertices(i)
            let p0 = Point3d(p0)
            let p1 = Point3d(p1)
            let p2 = Point3d(p2)
            let p3 = Point3d(p3)
            rc.Add( p0 )
            rc.Add( p1 )
            rc.Add( p2 )
            if faceType then
                rc.Add(p3)
            else
                if p2 <> p3 then
                    rc.Add( p2 )
                    rc.Add( p3 )
                    rc.Add( p0 )
        rc

    ///<summary>Returns vertices of each face in a Mesh as tuple of 4 points.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(Point3d ResizeArray) List of 3D points that define the face vertices of the Mesh.
    ///    the faces are returned as both quads and triangles. For triangles, the third and fourth vertex will be identical.</returns>
    static member MeshFacePoints(objectId:Guid) : (Point3d*Point3d*Point3d*Point3d) ResizeArray = // TODO mark functions not part of rhinopython
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        let rc = ResizeArray()
        for i = 0 to mesh.Faces.Count - 1 do
            let _, p0, p1, p2, p3 = mesh.Faces.GetFaceVertices(i)
            let p0 = Point3d(p0)
            let p1 = Point3d(p1)
            let p2 = Point3d(p2)
            let p3 = Point3d(p3)
            rc.Add( p0,p1,p2,p3 )
        rc



    ///<summary>Returns the vertex indices of all faces of a Ngon Mesh object.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object.</param>
    ///<returns>(int ResizeArray ResizeArray) containing a nested List that define the vertex indices for
    ///    each face of the Mesh. Ngons, quad and triangle faces are returned.</returns>
    static member MeshNgonFaceVertices(objectId:Guid) : ResizeArray<ResizeArray<int>> = //TODO add more ngon support functions like this ???
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        let rc = ResizeArray()
        for ng in mesh.GetNgonAndFacesEnumerable() do
            let uixs = ng.BoundaryVertexIndexList()
            let ixs= ResizeArray()
            for ix in uixs do
                ixs.Add(int(ix))
            rc.Add(ixs)
        rc


    ///<summary>Returns the vertex indices of all faces of a Mesh object, Does not suport Ngons yet.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<returns>((int*int*int*int) ResizeArray) containing tuples of 4 numbers that define the vertex indices for
    ///    each face of the Mesh. Both quad and triangle faces are returned. If the
    ///    third and fourth vertex indices are identical, the face is a triangle.</returns>
    static member MeshFaceVertices(objectId:Guid) : ResizeArray<int*int*int*int> =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        let rc = ResizeArray()
        for i = 0 to mesh.Faces.Count - 1 do
            let face = mesh.Faces.GetFace(i)
            rc.Add( (face.A, face.B, face.C, face.D)) //TODO add ngon support
        rc


    ///<summary>Verifies a Mesh object has face normals.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(bool) True , otherwise False.</returns>
    static member MeshHasFaceNormals(objectId:Guid) : bool =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        mesh.FaceNormals.Count>0


    ///<summary>Verifies a Mesh object has texture coordinates.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(bool) True , otherwise False.</returns>
    static member MeshHasTextureCoordinates(objectId:Guid) : bool =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        mesh.TextureCoordinates.Count>0


    ///<summary>Verifies a Mesh object has vertex colors.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(bool) True , otherwise False.</returns>
    static member MeshHasVertexColors(objectId:Guid) : bool =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        mesh.VertexColors.Count>0


    ///<summary>Verifies a Mesh object has vertex normals.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(bool) True , otherwise False.</returns>
    static member MeshHasVertexNormals(objectId:Guid) : bool =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        mesh.Normals.Count>0


    ///<summary>Calculates the intersections of a Mesh object with another Mesh object.</summary>
    ///<param name="mesh1">(Guid) Mesh1</param>
    ///<param name="mesh2">(Guid) Mesh2</param>
    ///<param name="tolerance">(float) Optional, default value: <c>ModelAbsoluteTolerance * MeshIntersectionsTolerancesCoefficient</c>
    ///    The intersection tolerance</param>
    ///<returns>(Polyline array) Array of points that define the vertices of the intersection Curves.</returns>
    static member MeshMeshIntersection( mesh1:Guid,
                                        mesh2:Guid,
                                        [<OPT;DEF(0.0)>]tolerance:float) : Polyline array =
        let mesh1 = RhinoScriptSyntax.CoerceMesh(mesh1)
        let mesh2 = RhinoScriptSyntax.CoerceMesh(mesh2)
        let tolerance = Util.ifZero1 tolerance (State.Doc.ModelAbsoluteTolerance*Intersect.Intersection.MeshIntersectionsTolerancesCoefficient) // see https://github.com/mcneel/rhinoscriptsyntax/pull/202
        Intersect.Intersection.MeshMeshAccurate(mesh1, mesh2, tolerance)


    ///<summary>Identifies the naked edge points of a Mesh object. This function shows
    ///    where Mesh vertices are not completely surrounded by faces. Joined
    ///    Meshes, such as are made by MeshBox, have naked Mesh edge points where
    ///    the sub-meshes are joined.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(bool array) Array of boolean values that represent whether or not a Mesh vertex is
    ///    naked or not. The number of elements in the list will be equal to
    ///    the value returned by MeshVertexCount. In which case, the list will
    ///    identify the naked status for each vertex returned by MeshVertices.</returns>
    static member MeshNakedEdgePoints(objectId:Guid) : bool array =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        mesh.GetNakedEdgePointStatus()



    ///<summary>Makes a new Mesh with vertices offset at a distance in the opposite
    ///    direction of the existing vertex normals.</summary>
    ///<param name="meshId">(Guid) Identifier of a Mesh object</param>
    ///<param name="distance">(float) The distance to offset</param>
    ///<returns>(Guid) identifier of the new Mesh object.</returns>
    static member MeshOffset(meshId:Guid, distance:float) : Guid =
        let mesh = RhinoScriptSyntax.CoerceMesh(meshId)
        let offsetmesh = mesh.Offset(distance)
        if offsetmesh|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MeshOffset failed.  meshId:'%s' distance:'%A'" (Nice.str meshId) distance
        let rc = State.Doc.Objects.AddMesh(offsetmesh)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.MeshOffset: Unable to add mesh to document.  meshId:'%s' distance:'%A'" (Nice.str meshId) distance
        State.Doc.Views.Redraw()
        rc


    ///<summary>Creates Polyline Curve outlines of Mesh objects.</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of Meshes to outline</param>
    ///<param name="view">(string) Optional, default value: <c>Top View</c>
    ///    View to use for outline direction</param>
    ///<returns>(Guid ResizeArray) Polyline Curve identifiers.</returns>
    static member MeshOutline(objectIds:Guid seq, [<OPT;DEF(null:string)>]view:string) : Guid ResizeArray =
        let  meshes =  resizeArray { for objectId in objectIds do yield RhinoScriptSyntax.CoerceMesh(objectId) }
        let rc = ResizeArray()
        if notNull view then
            let viewport = State.Doc.Views.Find(view, compareCase=false).MainViewport
            if isNull viewport then RhinoScriptingException.Raise "RhinoScriptSyntax.MeshOutline: did not find view named '%A'" view
            else
                for mesh in meshes do
                    let polylines = mesh.GetOutlines(viewport)
                    if notNull polylines then
                        for polyline in polylines do
                            let objectId = State.Doc.Objects.AddPolyline(polyline)
                            rc.Add(objectId)
        else
            for mesh in meshes do
                let polylines = mesh.GetOutlines(Plane.WorldXY)
                if notNull polylines then
                    for polyline in polylines do
                        let objectId = State.Doc.Objects.AddPolyline(polyline)
                        rc.Add(objectId)
        State.Doc.Views.Redraw()
        rc


    ///<summary>Returns the number of quad faces of a Mesh object.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(int) The number of quad Mesh faces.</returns>
    static member MeshQuadCount(objectId:Guid) : int =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        mesh.Faces.QuadCount


    ///<summary>Converts a Mesh object's quad faces to triangles.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member MeshQuadsToTriangles(objectId:Guid) : bool =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        let mutable rc = true
        if mesh.Faces.QuadCount>0 then
            rc <- mesh.Faces.ConvertQuadsToTriangles()
            if rc  then
                //id = RhinoScriptSyntax.CoerceGuid(objectId)
                State.Doc.Objects.Replace(objectId, mesh) |> ignore
                State.Doc.Views.Redraw()
        rc


    ///<summary>Duplicates each polygon in a Mesh with a NURBS Surface. The resulting
    ///    Surfaces are then joined into a Polysurface and added to the document.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<param name="trimmedTriangles">(bool) Optional, default value: <c>true</c>
    ///    If True, triangles in the Mesh will be
    ///    represented by a trimmed Plane</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>false</c>
    ///    Delete input object</param>
    ///<returns>(Guid ResizeArray) identifiers for the new breps.</returns>
    static member MeshToNurb( objectId:Guid,
                              [<OPT;DEF(true)>]trimmedTriangles:bool,
                              [<OPT;DEF(false)>]deleteInput:bool) : Guid ResizeArray =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        let pieces = mesh.SplitDisjointPieces()
        let breps =  resizeArray { for piece in pieces do yield Brep.CreateFromMesh(piece, trimmedTriangles) }
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let attr = rhobj.Attributes
        let ids =  resizeArray { for brep in breps do yield State.Doc.Objects.AddBrep(brep, attr) }
        if deleteInput then State.Doc.Objects.Delete(rhobj, quiet=true)|> ignore
        State.Doc.Views.Redraw()
        ids


    ///<summary>Returns number of triangular faces of a Mesh.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(int) The number of triangular Mesh faces.</returns>
    static member MeshTriangleCount(objectId:Guid) : int =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        mesh.Faces.TriangleCount


    ///<summary>Returns vertex colors of a Mesh.</summary>
    ///<param name="meshId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(Drawing.Color ResizeArray) The current vertex colors.</returns>
    static member MeshVertexColors(meshId:Guid) : Drawing.Color ResizeArray= //GET
        let mesh = RhinoScriptSyntax.CoerceMesh(meshId)
        resizeArray { for i = 0 to mesh.VertexColors.Count - 1 do mesh.VertexColors.[i] }


    ///<summary>Modifies vertex colors of a Mesh.</summary>
    ///<param name="meshId">(Guid) Identifier of a Mesh object</param>
    ///<param name="colors">(Drawing.Color seq), optional) A list of color values. Note, for each vertex, there must
    ///    be a corresponding vertex color. If the value is null or empty list , then any
    ///    existing vertex colors will be removed from the Mesh</param>
    ///<returns>(unit) void, nothing.</returns>
    static member MeshVertexColors(meshId:Guid, colors:Drawing.Color seq) : unit = //SET
        let mesh = RhinoScriptSyntax.CoerceMesh(meshId)
        if colors|> isNull || Seq.isEmpty colors   then
            mesh.VertexColors.Clear()
        else
            let colorcount = Seq.length(colors)
            if colorcount <> mesh.Vertices.Count then
                RhinoScriptingException.Raise "RhinoScriptSyntax.MeshVertexColors: Length of colors must match vertex count.  meshId:'%s' colors:'%A'" (Nice.str meshId) colors
            mesh.VertexColors.Clear()
            for c in colors do mesh.VertexColors.Add(c) |> ignore
        State.Doc.Objects.Replace(meshId, mesh) |> ignore
        State.Doc.Views.Redraw()



    ///<summary>Returns the vertex count of a Mesh.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(int) The number of Mesh vertices.</returns>
    static member MeshVertexCount(objectId:Guid) : int =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        mesh.Vertices.Count


    ///<summary>Returns the Mesh faces that share a specified Mesh vertex.</summary>
    ///<param name="meshId">(Guid) Identifier of a Mesh object</param>
    ///<param name="vertexIndex">(int) Index of the Mesh vertex to find faces for</param>
    ///<returns>(int array) face indices.</returns>
    static member MeshVertexFaces(meshId:Guid, vertexIndex:int) : int array =
        let mesh = RhinoScriptSyntax.CoerceMesh(meshId)
        mesh.Vertices.GetVertexFaces(vertexIndex)


    ///<summary>Returns the vertex unit normal for each vertex of a Mesh.</summary>
    ///<param name="meshId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(Vector3d ResizeArray) List of vertex normals, (empty list if no normals exist).</returns>.ToNiceString
    static member MeshVertexNormals(meshId:Guid) : Vector3d ResizeArray =
        let mesh = RhinoScriptSyntax.CoerceMesh(meshId)
        let count = mesh.Normals.Count
        if count<1 then resizeArray {()}
        else resizeArray { for i = 0 to count - 1 do Vector3d(mesh.Normals.[i])}


    ///<summary>Returns the vertices of a Mesh.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(Point3d ResizeArray) vertex points in the Mesh.</returns>
    static member MeshVertices(objectId:Guid) : Point3d ResizeArray =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        let count = mesh.Vertices.Count
        let rc = ResizeArray()
        for i = 0 to count - 1 do
            let vertex = mesh.Vertices.[i]
            rc.Add(Point3d(vertex))
        rc


    ///<summary>Returns the approximate volume of one or more closed Meshes.</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of one or more Mesh objects</param>
    ///<returns>(float) total volume of all Meshes.</returns>
    static member MeshVolume(objectIds:Guid seq) : float =
        let mutable totalVolume  = 0.0
        for objectId in objectIds do
            // TODO add check for mesh being closed
            let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
            let mp = VolumeMassProperties.Compute(mesh)
            if notNull mp then
                totalVolume <- totalVolume + mp.Volume
            else
                RhinoScriptingException.Raise "RhinoScriptSyntax.MeshVolume failed on objectId:'%s'" (Nice.str objectId)
        totalVolume


    ///<summary>Returns the approximate volume of one or more closed Meshes.</summary>
    ///<param name="meshes">(Geometry.Mesh seq)  Mesh Geometries</param>
    ///<returns>(float) total volume of all Meshes.</returns>
    static member MeshVolume(meshes:Mesh seq) : float =
        let mutable totalVolume  = 0.0
        for mesh in meshes do
            // TODO add check for mesh being closed
            let mp = VolumeMassProperties.Compute(mesh)
            if notNull mp then
                totalVolume <- totalVolume + mp.Volume
            else
                RhinoScriptingException.Raise "RhinoScriptSyntax.MeshVolume failed on mesh:'%s' of %d meshes" (Nice.str mesh) (Seq.length meshes)
        totalVolume


    ///<summary>Calculates the volume centroid of a Mesh.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(Point3d) Point3d representing the volume centroid.</returns>
    static member MeshVolumeCentroid(objectId:Guid) : Point3d =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        let mp = VolumeMassProperties.Compute(mesh)
        if notNull mp then mp.Centroid
        else RhinoScriptingException.Raise "RhinoScriptSyntax.MeshVolumeCentroid failed.  objectId:'%s'" (Nice.str objectId)

    ///<summary>Calculates the volume centroid of a Mesh.</summary>
    ///<param name="mesh">(Geometry.Mesh seq) Mesh Geometry</param>
    ///<returns>(Point3d) Point3d representing the volume centroid.</returns>
    static member MeshVolumeCentroid(mesh:Mesh) : Point3d =
        let mp = VolumeMassProperties.Compute(mesh)
        if notNull mp then mp.Centroid
        else RhinoScriptingException.Raise "RhinoScriptSyntax.MeshVolumeCentroid failed.  mesh:'%s'" (Nice.str mesh)


    ///<summary>Pulls a Curve to a Mesh. The function makes a Polyline approximation of
    ///    the input Curve and gets the closest point on the Mesh for each point on
    ///    the polyline. Then it "connects the points" to create a Polyline on the Mesh.</summary>
    ///<param name="meshId">(Guid) Identifier of Mesh that pulls</param>
    ///<param name="curveId">(Guid) Identifier of Curve to pull</param>
    ///<returns>(Guid) identifier new Curve.</returns>
    static member PullCurveToMesh(meshId:Guid, curveId:Guid) : Guid =
        let mesh = RhinoScriptSyntax.CoerceMesh(meshId)
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let tol = State.Doc.ModelAbsoluteTolerance
        let polyline = curve.PullToMesh(mesh, tol)
        if isNull polyline then RhinoScriptingException.Raise "RhinoScriptSyntax.PullCurveToMesh failed.  meshId:'%s' curveId:'%s'" (Nice.str meshId)  (Nice.str curveId)
        let rc = State.Doc.Objects.AddCurve(polyline)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.PullCurveToMesh: Unable to add polyline to document.  meshId:'%s' curveId:'%s'" (Nice.str meshId) (Nice.str curveId)
        State.Doc.Views.Redraw()
        rc


    ///<summary>Splits up a Mesh into its unconnected pieces.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>false</c>
    ///    Delete the input object</param>
    ///<returns>(Guid ResizeArray) identifiers for the new Meshes.</returns>
    static member SplitDisjointMesh(objectId:Guid, [<OPT;DEF(false)>]deleteInput:bool) : Guid ResizeArray =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        let pieces = mesh.SplitDisjointPieces()
        let rc =  resizeArray { for piece in pieces do yield State.Doc.Objects.AddMesh(piece) }
        if rc.Count <> 0 && deleteInput then
            //id = RhinoScriptSyntax.CoerceGuid(objectId)
            State.Doc.Objects.Delete(objectId, true) |> ignore
        State.Doc.Views.Redraw()
        rc


    ///<summary>Fixes inconsistencies in the directions of faces of a Mesh.</summary>
    ///<param name="objectId">(Guid) Identifier of a Mesh object</param>
    ///<returns>(int) The number of faces that were modified.</returns>
    static member UnifyMeshNormals(objectId:Guid) : int =
        let mesh = RhinoScriptSyntax.CoerceMesh(objectId)
        let rc = mesh.UnifyNormals()
        if rc>0 then
            //id = RhinoScriptSyntax.CoerceGuid(objectId)
            State.Doc.Objects.Replace(objectId, mesh)|> ignore
            State.Doc.Views.Redraw()
        rc



    //---End of header marker: don't change: {@$%^&*()*&^%$@}


    ///<summary>Moves, scales, or rotates a list of objects given a 4x4 transformation
    ///    matrix. The matrix acts on the left. To transform Geometry objects instead of DocObjects or Guids use their .Transform(xForm) member.</summary>
    ///<param name="objectIds">(Guid seq) List of object identifiers</param>
    ///<param name="matrix">(Transform) The transformation matrix (4x4 array of numbers)</param>
    ///<param name="copy">(bool) Optional, default value: <c>false</c>
    ///    Copy the objects</param>
    ///<returns>(Guid ResizeArray) ids identifying the newly transformed objects.</returns>
    static member TransformObjects( objectIds:Guid seq,
                                    matrix:Transform,
                                    [<OPT;DEF(false)>]copy:bool) : Guid ResizeArray =   //PLURAL
        // this is also called by Copy, Scale, Mirror, Move, and Rotate functions defined below
        let rc = ResizeArray()
        for objId in objectIds do
            let objectId = State.Doc.Objects.Transform(objId, matrix, not copy)
            if objectId = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.TransformObjects: Cannot apply transform to object '%s' from objectId:'%s' matrix:'%A' copy:'%A'" (Nice.str objId) (Nice.str objectId) matrix copy
            rc.Add objectId
        State.Doc.Views.Redraw()
        rc

    ///<summary>Moves, scales, or rotates an object given a 4x4 transformation matrix.
    ///    The matrix acts on the left. To transform Geometry objects instead of DocObjects or Guids use their .Transform(xForm) member.</summary>
    ///<param name="objectId">(Guid) The identifier of the object</param>
    ///<param name="matrix">(Transform) The transformation matrix (4x4 array of numbers)</param>
    ///<param name="copy">(bool) Optional, default value: <c>false</c>
    ///    Copy the object</param>
    ///<returns>(Guid) The identifier of the transformed object.</returns>
    static member TransformObject(  objectId:Guid,
                                    matrix:Transform,
                                    [<OPT;DEF(false)>]copy:bool) : Guid =
        let res = State.Doc.Objects.Transform(objectId, matrix, not copy)
        if res = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.TransformObject: Cannot apply transform to objectId:'%s' matrix:'%A' copy:'%A'"  (Nice.str objectId) matrix copy
        res


    ///<summary>Copies object from one location to another, or in-place.</summary>
    ///<param name="objectId">(Guid) Object to copy</param>
    ///<param name="translation">(Vector3d) Optional, additional Translation vector to apply</param>
    ///<returns>(Guid) objectId for the copy.</returns>
    static member CopyObject(objectId:Guid, [<OPT;DEF(Vector3d())>]translation:Vector3d) : Guid =
        let translation =
            if not translation.IsZero then
                Transform.Translation(translation)
            else
                Transform.Identity
        let res = State.Doc.Objects.Transform(objectId, translation, deleteOriginal=false)
        if res = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.CopyObject failed.  objectId:'%s' translation:'%A'" (Nice.str objectId) translation
        res



    ///<summary>Copies one or more objects from one location to another, or in-place.</summary>
    ///<param name="objectIds">(Guid seq) List of objects to copy</param>
    ///<param name="translation">(Vector3d) Optional, Vector3d representing translation vector to apply to copied set</param>
    ///<returns>(Guid ResizeArray) identifiers for the copies.</returns>
    static member CopyObjects(objectIds:Guid seq, [<OPT;DEF(Vector3d())>]translation:Vector3d) : Guid ResizeArray = //PLURAL
        let translation =
            if not translation.IsZero then
                Transform.Translation(translation)
            else
                Transform.Identity
        let rc = ResizeArray()
        for objectId in objectIds do
            let res = State.Doc.Objects.Transform(objectId, translation, deleteOriginal=false)
            if res = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.CopyObjects failed.  objectId:'%s' translation:'%A'" (Nice.str objectId) translation
            rc.Add res
        rc


    ///<summary>Deletes a single object from the document.</summary>
    ///<param name="objectId">(Guid) Identifier of object to delete</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DeleteObject(objectId:Guid) : unit =
        if not <| State.Doc.Objects.Delete(objectId, quiet=true)  then RhinoScriptingException.Raise "RhinoScriptSyntax.DeleteObject failed on %s" (Nice.str objectId)
        State.Doc.Views.Redraw()



    ///<summary>Deletes one or more objects from the document, Fails if not all objects can be deleted.</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of objects to delete</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DeleteObjects(objectIds:Guid seq) : unit = //PLURAL
        let k = State.Doc.Objects.Delete(objectIds, quiet=true)
        let l = Seq.length objectIds
        if k <> l then RhinoScriptingException.Raise "RhinoScriptSyntax.DeleteObjects failed on %d out of %s" (l-k) (Nice.str objectIds)
        State.Doc.Views.Redraw()


    ///<summary>Causes the selection state of one or more objects to change momentarily
    ///    so the object appears to flash on the screen.</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of objects to flash</param>
    ///<param name="style">(bool) Optional, default value: <c>true</c>
    ///    If True, flash between object color and selection color.
    ///    If False, flash between visible and invisible</param>
    ///<returns>(unit).</returns>
    static member FlashObject(objectIds:Guid seq, [<OPT;DEF(true)>]style:bool) : unit =
        let rhobjs = resizeArray { for objectId in objectIds do yield RhinoScriptSyntax.CoerceRhinoObject(objectId) }
        if rhobjs.Count>0 then
            State.Doc.Views.FlashObjects(rhobjs, style)


    ///<summary>Hides a single object.</summary>
    ///<param name="objectId">(Guid) Id of object to hide</param>
    ///<returns>(bool) True of False indicating success or failure.</returns>
    static member HideObject(objectId:Guid) : bool =
        State.Doc.Objects.Hide(objectId, ignoreLayerMode=false)


    ///<summary>Hides one or more objects.</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of objects to hide</param>
    ///<returns>(int) Number of objects hidden.</returns>
    static member HideObjects(objectIds:Guid seq) : int = //PLURAL
        let mutable rc = 0
        for objectId in objectIds do
            if State.Doc.Objects.Hide(objectId, ignoreLayerMode=false) then rc <- rc + 1
        if  rc>0 then State.Doc.Views.Redraw()
        rc


    ///<summary>Checks if an object is in on a page layout space. (as opposed to model space).</summary>
    ///<param name="objectId">(Guid) Id of an object to test</param>
    ///<returns>(bool) True if the object is in page layout space, False if the object is in model space.</returns>
    static member IsLayoutObject(objectId:Guid) : bool =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        rhobj.Attributes.Space = DocObjects.ActiveSpace.PageSpace


    ///<summary>Verifies the existence of an object in the State.Doc.Objects table. Fails on empty Guid.</summary>
    ///<param name="objectId">(Guid) An object to test</param>
    ///<returns>(bool) True if the object exists, False if the object does not exist.</returns>
    static member IsObject(objectId:Guid) : bool =
        RhinoScriptSyntax.TryCoerceRhinoObject(objectId) <> None


    ///<summary>Checks if an object is hidden. Hidden objects are not visible, cannot
    ///    be snapped to, and cannot be selected.</summary>
    ///<param name="objectId">(Guid) The identifier of an object to test</param>
    ///<returns>(bool) True if the object is hidden, False if the object is not hidden.</returns>
    static member IsObjectHidden(objectId:Guid) : bool =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        rhobj.IsHidden


    ///<summary>Verifies an object's bounding box is inside of another bounding box.</summary>
    ///<param name="objectId">(Guid) Identifier of an object to be tested</param>
    ///<param name="box">(Geometry.BoundingBox) Bounding box to test for containment</param>
    ///<param name="testMode">(bool) Optional, default value: <c>true</c>
    ///    If True, the object's bounding box must be contained by box
    ///    If False, the object's bounding box must be contained by or intersect box</param>
    ///<returns>(bool) True if object is inside box, False is object is not inside box.</returns>
    static member IsObjectInBox( objectId:Guid,
                                 box:BoundingBox,
                                 [<OPT;DEF(true)>]testMode:bool) : bool =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let objbox = rhobj.Geometry.GetBoundingBox(true)
        if testMode then
            box.Contains(objbox)
        else
            let union = BoundingBox.Intersection(box, objbox)
            union.IsValid


    ///<summary>Checks if an object is a member of a group.</summary>
    ///<param name="objectId">(Guid) The identifier of an object</param>
    ///<param name="groupName">(string) Optional, The name of a group. If omitted, the function checks if the object is a member of any group</param>
    ///<returns>(bool) True if the object is a member of the specified group. If a groupName
    ///    was not specified, the object is a member of some group.
    ///    False if the object  is not a member of the specified group.
    ///    If a groupName was not specified, the object is not a member of any group.</returns>
    static member IsObjectInGroup(objectId:Guid, [<OPT;DEF(null:string)>]groupName:string) : bool =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let count = rhobj.GroupCount
        if count<1 then false
        else
          if isNull groupName then true
          else
            let index = State.Doc.Groups.Find(groupName)
            if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.IsObjectInGroup: '%s' group does not exist" groupName
            let groupids = rhobj.GetGroupList()
            groupids |> Seq.exists ((=) index )



    ///<summary>Checks if an object is locked. Locked objects are visible, and can
    ///    be snapped to, but cannot be selected.</summary>
    ///<param name="objectId">(Guid) The identifier of an object to be tested</param>
    ///<returns>(bool) True if the object is locked, False if the object is not locked.</returns>
    static member IsObjectLocked(objectId:Guid) : bool =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        rhobj.IsLocked


    ///<summary>Checks if an object is normal. Normal objects are visible, can be
    ///    snapped to, and can be selected.</summary>
    ///<param name="objectId">(Guid) The identifier of an object to be tested</param>
    ///<returns>(bool) True if the object is normal, False if the object is not normal.</returns>
    static member IsObjectNormal(objectId:Guid) : bool =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        rhobj.IsNormal


    ///<summary>Checks if an object is a reference object. Reference objects are
    ///    objects that are not part of the current document.</summary>
    ///<param name="objectId">(Guid) The identifier of an object to test</param>
    ///<returns>(bool) True if the object is a reference object, False if the object is not a reference object.</returns>
    static member IsObjectReference(objectId:Guid) : bool =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        rhobj.IsReference


    ///<summary>Checks if an object can be selected.</summary>
    ///<param name="objectId">(Guid) The identifier of an object to test</param>
    ///<returns>(bool) True or False.</returns>
    static member IsObjectSelectable(objectId:Guid) : bool =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        rhobj.IsSelectable( ignoreSelectionState=true,
                            ignoreGripsState    =false ,
                            ignoreLayerLocking  =false ,
                            ignoreLayerVisibility=false )


    ///<summary>Checks if an object is currently selected.</summary>
    ///<param name="objectId">(Guid) The identifier of an object to test</param>
    ///<returns>(int)
    ///    0, the object is not selected
    ///    1, the object is selected
    ///    2, the object is entirely persistently selected
    ///    3, one or more proper sub-objects are selected.</returns>
    static member IsObjectSelected(objectId:Guid) : int =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        rhobj.IsSelected(false)


    ///<summary>Determines if an object is closed or solid.</summary>
    ///<param name="objectId">(Guid) The identifier of an object to test</param>
    ///<returns>(bool) True if the object is solid, or a Mesh is closed, False otherwise.</returns>
    static member IsObjectSolid(objectId:Guid) : bool =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        // rhobj.IsSolid //TODO  'rhobj.IsSolid'  could be used from RhCommon 7.5 onwards see https://github.com/mcneel/rhinoscriptsyntax/pull/197
        // and https://github.com/mcneel/rhinoscriptsyntax/commit/aaa0906fa43003db093c1e6f58bf12c813eddbeb
        let geom = rhobj.Geometry
        match geom with
        | :? Mesh      as m -> m.IsClosed
        | :? Extrusion as s -> s.IsSolid
        | :? Surface   as s -> s.IsSolid
        | :? Brep      as s -> s.IsSolid
        | :? SubD      as s -> s.IsSolid // only for Rh7 and higher
        | _                 ->
            RhinoScriptingException.Raise "RhinoScriptSyntax.IsObjectSolid only Mesh, Extrusion, Surface, Brep or SubD can be tested for solidity but not %s" (Nice.str objectId)



    ///<summary>Verifies an object's geometry is valid and without error.</summary>
    ///<param name="objectId">(Guid) The identifier of an object to test</param>
    ///<returns>(bool) True if the object is valid.</returns>
    static member IsObjectValid(objectId:Guid) : bool =
        match RhinoScriptSyntax.TryCoerceRhinoObject(objectId) with
        |None -> false
        |Some rhobj ->  rhobj.IsValid


    ///<summary>Verifies an object is visible in a view.</summary>
    ///<param name="objectId">(Guid) The identifier of an object to test</param>
    ///<param name="view">(string) Optional, default value: <c>ActiveView.MainViewport</c> The title of the view. If omitted, the current active view is used</param>
    ///<returns>(bool) True if the object is visible in the specified view, otherwise False.</returns>
    static member IsVisibleInView(objectId:Guid, [<OPT;DEF(null:string)>]view:string) : bool =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let viewport = if notNull view then (RhinoScriptSyntax.CoerceView(view)).MainViewport else State.Doc.Views.ActiveView.MainViewport
        let bbox = rhobj.Geometry.GetBoundingBox(true)
        rhobj.Visible && viewport.IsVisible(bbox)


    ///<summary>Locks a single object. Locked objects are visible, and they can be
    ///    snapped to. But, they cannot be selected.</summary>
    ///<param name="objectId">(Guid) The identifier of an object</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member LockObject(objectId:Guid) : bool =
        State.Doc.Objects.Lock(objectId, ignoreLayerMode=false)


    ///<summary>Locks multiple objects. Locked objects are visible, and they can be
    ///    snapped to. But, they cannot be selected.</summary>
    ///<param name="objectIds">(Guid seq) List of Strings or Guids. The identifiers of objects</param>
    ///<returns>(int) number of objects locked.</returns>
    static member LockObjects(objectIds:Guid seq) : int = //PLURAL
        let mutable rc = 0
        for objectId in objectIds do
            if State.Doc.Objects.Lock(objectId, ignoreLayerMode=false) then rc <- rc +   1
        if 0<> rc then State.Doc.Views.Redraw()
        rc


    ///<summary>Matches, or copies the attributes of a source object to a target object.</summary>
    ///<param name="targetIds">(Guid seq) Identifiers of objects to copy attributes to</param>
    ///<param name="sourceId">(Guid) Optional, Identifier of object to copy attributes from. If None,
    ///    then the default attributes are copied to the targetIds</param>
    ///<returns>(int) number of objects modified.</returns>
    static member MatchObjectAttributes(targetIds:Guid seq, [<OPT;DEF(Guid())>]sourceId:Guid) : int =
        let sourceAttr =
            if Guid.Empty <> sourceId then
                let source = RhinoScriptSyntax.CoerceRhinoObject(sourceId)
                source.Attributes.Duplicate()
            else
                new DocObjects.ObjectAttributes()
        let mutable rc = 0
        for objectId in targetIds do
            if State.Doc.Objects.ModifyAttributes(objectId, sourceAttr, quiet=true) then
                rc <- rc +  1
        if 0 <> rc then State.Doc.Views.Redraw()
        rc


    ///<summary>Mirrors a single object on World XY Plane.</summary>
    ///<param name="objectId">(Guid) The identifier of an object to mirror</param>
    ///<param name="startPoint">(Point3d) Start of the mirror Plane</param>
    ///<param name="endPoint">(Point3d) End of the mirror Plane</param>
    ///<param name="copy">(bool) Optional, default value: <c>false</c>
    ///    Copy the object</param>
    ///<returns>(Guid) Identifier of the mirrored object.</returns>
    static member MirrorObject( objectId:Guid,
                                startPoint:Point3d,
                                endPoint:Point3d,
                                [<OPT;DEF(false)>]copy:bool) : Guid =
        let vec = endPoint-startPoint
        if vec.IsTiny() then RhinoScriptingException.Raise "RhinoScriptSyntax.MirrorObject Start and  end points are too close to each other.  objectId:'%s' startPoint:'%A' endPoint:'%A' copy:'%A'" (Nice.str objectId) startPoint endPoint copy
        let normal = Plane.WorldXY.Normal
        let xv = Vector3d.CrossProduct(vec, normal)
        xv.Unitize() |> ignore
        let xf = Transform.Mirror(startPoint, vec)
        let res = State.Doc.Objects.Transform(objectId, xf, not copy)
        if res = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.MirrorObject Cannot apply MirrorObject transform to objectId:'%s' startPoint:'%A' endPoint:'%A' copy:'%A'" (Nice.str objectId) startPoint endPoint copy
        res


    ///<summary>Mirrors a list of objects on World XY Plane.</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of objects to mirror</param>
    ///<param name="startPoint">(Point3d) Start of the mirror Plane</param>
    ///<param name="endPoint">(Point3d) End of the mirror Plane</param>
    ///<param name="copy">(bool) Optional, default value: <c>false</c>
    ///    Copy the objects</param>
    ///<returns>(Guid ResizeArray) List of identifiers of the mirrored objects.</returns>
    static member MirrorObjects(  objectIds:Guid seq,
                                 startPoint:Point3d,
                                 endPoint:Point3d,
                                 [<OPT;DEF(false)>]copy:bool) : Guid ResizeArray = //PLURAL
        let vec = endPoint-startPoint
        if vec.IsTiny() then RhinoScriptingException.Raise "RhinoScriptSyntax.MirrorObjects Start and  end points are too close to each other.  objectId:'%s' startPoint:'%A' endPoint:'%A' copy:'%A'" (Nice.str objectIds) startPoint endPoint copy
        let normal = Plane.WorldXY.Normal
        let xv = Vector3d.CrossProduct(vec, normal)
        xv.Unitize() |> ignore
        let xf = Transform.Mirror(startPoint, vec)
        let rc = ResizeArray()
        for objectId in objectIds do
            let objectId = State.Doc.Objects.Transform(objectId, xf, not copy)
            if objectId = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.MirrorObjects Cannot apply MirrorObjects to objectId:'%s' startPoint:'%A' endPoint:'%A' copy:'%A'" (Nice.str objectId) startPoint endPoint copy
            rc.Add objectId
        rc



    ///<summary>Moves a single object.</summary>
    ///<param name="objectId">(Guid) The identifier of an object to move</param>
    ///<param name="translation">(Vector3d) Vector3d</param>
    ///<returns>(unit) void, nothing.</returns>
    static member MoveObject(objectId:Guid, translation:Vector3d) : unit = //TODO or return unit ??
        let xf = Transform.Translation(translation)
        let res = State.Doc.Objects.Transform(objectId, xf, deleteOriginal=true)
        if res = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.MoveObject Cannot apply move to from objectId:'%s' translation:'%A'" (Nice.str objectId) translation
        //if objectId <> res

    ///<summary>Moves one or more objects.</summary>
    ///<param name="objectIds">(Guid seq) The identifiers objects to move</param>
    ///<param name="translation">(Vector3d)Vector3d</param>
    ///<returns>(unit) void, nothing.</returns>
    static member MoveObjects(objectIds:Guid seq, translation:Vector3d) : unit =  //PLURAL
        let xf = Transform.Translation(translation)
        //let rc = ResizeArray()
        for objectId in objectIds do
            let res = State.Doc.Objects.Transform(objectId, xf, deleteOriginal=true)
            if res = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.MoveObjects Cannot apply MoveObjects Transform to objectId:'%s'  translation:'%A'" (Nice.str objectId) translation
            //rc.Add objectId
        //rc


    ///<summary>Returns the color of an object. Object colors are represented
    /// as RGB colors. An RGB color specifies the relative intensity of red, green,
    /// and blue to cause a specific color to be displayed.</summary>
    ///<param name="objectId">(Guid)Id of object</param>
    ///<returns>(Drawing.Color) The current color value.</returns>
    static member ObjectColor(objectId:Guid) : Drawing.Color = //GET
        let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        rhinoObject.Attributes.DrawColor(State.Doc)

    ///<summary>Modifies the color of an object. Object colors are represented
    /// as RGB colors. An RGB color specifies the relative intensity of red, green,
    /// and blue to cause a specific color to be displayed.</summary>
    ///<param name="objectId">(Guid)Id of object</param>
    ///<param name="color">(Drawing.Color) The new color value</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectColor(objectId:Guid, color:Drawing.Color) : unit = //SET
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let attr = rhobj.Attributes
        attr.ObjectColor <- color
        attr.ColorSource <- DocObjects.ObjectColorSource.ColorFromObject
        if not <| State.Doc.Objects.ModifyAttributes( rhobj, attr, quiet=true) then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectColor setting failed for %A; %A" (Nice.str objectId) color
        State.Doc.Views.Redraw()

    ///<summary>Modifies the color of multiple objects. Object colors are represented
    /// as RGB colors. An RGB color specifies the relative intensity of red, green,
    /// and blue to cause a specific color to be displayed.</summary>
    ///<param name="objectIds">(Guid seq)Ids of objects</param>
    ///<param name="color">(Drawing.Color) The new color value</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectColor(objectIds:Guid seq, color:Drawing.Color) : unit = //MULTISET
        for objectId in objectIds do
            let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            let attr = rhobj.Attributes
            attr.ObjectColor <- color
            attr.ColorSource <- DocObjects.ObjectColorSource.ColorFromObject
            if not <| State.Doc.Objects.ModifyAttributes( rhobj, attr, quiet=true) then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectColor setting failed for %A; %A" (Nice.str objectId) color
        State.Doc.Views.Redraw()




    ///<summary>Returns the color source of an object.</summary>
    ///<param name="objectId">(Guid) Single identifier</param>
    ///<returns>(int) The current color source
    ///    0 = color from layer
    ///    1 = color from object
    ///    2 = color from material
    ///    3 = color from parent.</returns>
    static member ObjectColorSource(objectId:Guid) : int = //GET
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        int(rhobj.Attributes.ColorSource)

    ///<summary>Modifies the color source of an object.</summary>
    ///<param name="objectId">(Guid) Single identifier</param>
    ///<param name="source">(int) New color source
    ///    0 = color from layer
    ///    1 = color from object
    ///    2 = color from material
    ///    3 = color from parent</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectColorSource(objectId:Guid, source:int) : unit = //SET
        let source : DocObjects.ObjectColorSource = LanguagePrimitives.EnumOfValue source
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        rhobj.Attributes.ColorSource <- source
        rhobj.CommitChanges() |> ignore
        State.Doc.Views.Redraw()

    ///<summary>Modifies the color source of multiple objects.</summary>
    ///<param name="objectIds">(Guid seq) Multiple identifiers</param>
    ///<param name="source">(int) New color source
    ///    0 = color from layer
    ///    1 = color from object
    ///    2 = color from material
    ///    3 = color from parent</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectColorSource(objectIds:Guid seq, source:int) : unit = //MULTISET
        let source : DocObjects.ObjectColorSource = LanguagePrimitives.EnumOfValue source
        for objectId in objectIds do
            let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            rhobj.Attributes.ColorSource <- source
            rhobj.CommitChanges() |> ignore
        State.Doc.Views.Redraw()





    ///<summary>Returns a description of the object type (e.g. Line, Surface, Text,...).</summary>
    ///<param name="objectId">(Guid) Identifier of an object</param>
    ///<returns>(string) A short text description of the object.</returns>
    static member ObjectDescription(objectId:Guid) : string =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        rhobj.ShortDescription(false)



    ///<summary>Returns the count for each object type in a List of objects.</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of objects</param>
    ///<returns>(string) A short text description of the object.</returns>
    static member ObjectDescription(objectIds:Guid seq) : string =
        let count =  objectIds|> Seq.countBy (fun id ->
                        /// TODO could be optimized by using Object-type integer instead of string
                        let o = RhinoScriptSyntax.CoerceRhinoObject(id)
                        o.ShortDescription(true) + if o.IsDeleted then " (deleted !)" else ""
                        )
        let typesk = Seq.length count
        let mutable tx = ""
        if typesk = 0 then
            tx <- "zero objects"
        elif typesk = 1  then
            for typ, k in count  do
                tx <- sprintf " %d: %s" k typ
        else
            tx <- sprintf "%d objects of following types:" (Seq.length objectIds)
            for typ, k  in count |> Seq.sortBy snd do
                tx <- sprintf "%s%s    %d: %s" tx Environment.NewLine  k typ
        tx



    ///<summary>Returns the short layer of an object.
    ///    Without Parent Layers.</summary>
    ///<param name="objectId">(Guid) The identifier of the object</param>
    ///<returns>(string) The object's current layer.</returns>
    static member ObjectLayerShort(objectId:Guid) : string = //GET
        let obj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let index = obj.Attributes.LayerIndex
        State.Doc.Layers.[index].Name


    //static member ObjectLayer()// all 3 overloads moved to  top of file Scripting_Layer.fs

    ///<summary>Returns the layout or model space of an object.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<returns>(string) The object's current page layout view, Empty String if it is in Model Space.</returns>
    static member ObjectLayout(objectId:Guid) : string = //GET
        // this fixes bug in rhinoscriptsyntax, see https://github.com/mcneel/rhinoscriptsyntax/pull/203
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if rhobj.Attributes.Space = DocObjects.ActiveSpace.PageSpace then
            let pageid = rhobj.Attributes.ViewportId
            let pageview = State.Doc.Views.Find(pageid)
            pageview.MainViewport.Name
        else
            ""


    ///<summary>Changes the layout or model space of an object.</summary>
    ///<param name="objectId">(Guid) Identifier of the object</param>
    ///<param name="layout">(string) To change, or move, an object from model space to page
    ///    layout space, or from one page layout to another, then specify the
    ///    title of an existing page layout view. To move an object
    ///    from page layout space to model space, just specify an empty string.</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectLayout(objectId:Guid, layout:string) : unit = //SET
        // this fixes bug in rhinoscriptsyntax, see https://github.com/mcneel/rhinoscriptsyntax/pull/203
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let view=
            if rhobj.Attributes.Space = DocObjects.ActiveSpace.PageSpace then
                let pageid = rhobj.Attributes.ViewportId
                let pageview = State.Doc.Views.Find(pageid)
                pageview.MainViewport.Name
            else
                ""

        if view<>layout then
            if layout="" then //move to model space
                rhobj.Attributes.Space <- DocObjects.ActiveSpace.ModelSpace
                rhobj.Attributes.ViewportId <- Guid.Empty
            else
                match State.Doc.Views.Find(layout, compareCase=false) with
                | null -> RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectLayout: Setting it failed, layout not found for '%s' and '%A'"  layout objectId
                | :? Display.RhinoPageView as layout ->
                    rhobj.Attributes.ViewportId <- layout.MainViewport.Id
                    rhobj.Attributes.Space <- DocObjects.ActiveSpace.PageSpace
                | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectLayout: Setting it failed, layout is not a Page view for '%s' and '%A'"  layout objectId

            rhobj.CommitChanges() |> ignore
            State.Doc.Views.Redraw()

    ///<summary>Changes the layout or model space of an objects.</summary>
    ///<param name="objectIds">(Guid seq) Identifier of the objects</param>
    ///<param name="layout">(string) To change, or move, an objects from model space to page
    ///    layout space, or from one page layout to another, then specify the
    ///    title of an existing page layout view. To move an objects
    ///    from page layout space to model space, just specify an empty string.</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectLayout(objectIds:Guid seq, layout:string) : unit = //MULTISET
        let lay =
            if layout<>"" then
                match State.Doc.Views.Find(layout, compareCase=false) with
                | null -> RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectLayout: Setting it failed, layout not found for '%s' and '%A'"  layout objectIds
                | :? Display.RhinoPageView as layout -> Some layout
                | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectLayout: Setting it failed, layout is not a Page view for '%s' and '%A'"  layout objectIds
            else
                None

        for objectId in objectIds do
            let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            let view=
                if rhobj.Attributes.Space = DocObjects.ActiveSpace.PageSpace then
                    let pageid = rhobj.Attributes.ViewportId
                    let pageview = State.Doc.Views.Find(pageid)
                    pageview.MainViewport.Name
                else
                    ""

            if view<>layout then
                if layout="" then //move to model space
                    rhobj.Attributes.Space <- DocObjects.ActiveSpace.ModelSpace
                    rhobj.Attributes.ViewportId <- Guid.Empty
                else
                    rhobj.Attributes.ViewportId <- lay.Value.MainViewport.Id
                    rhobj.Attributes.Space <- DocObjects.ActiveSpace.PageSpace

                rhobj.CommitChanges() |> ignore
        State.Doc.Views.Redraw()


    ///<summary>Returns the linetype of an object.</summary>
    ///<param name="objectId">(Guid) Identifier of object</param>
    ///<returns>(string) The object's current linetype.</returns>
    static member ObjectLinetype(objectId:Guid) : string = //GET
        let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let oldIndex = State.Doc.Linetypes.LinetypeIndexForObject(rhinoObject)
        State.Doc.Linetypes.[oldIndex].Name

    ///<summary>Modifies the linetype of an object.</summary>
    ///<param name="objectId">(Guid) Identifier of object</param>
    ///<param name="linetype">(string) Name of an existing linetype</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectLinetype(objectId:Guid, linetype:string) : unit = //SET
        let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let newIndex = State.Doc.Linetypes.Find(linetype)
        if newIndex <0 then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectLinetype: Setting it failed for '%A' and '%A'"  linetype objectId
        rhinoObject.Attributes.LinetypeSource <- DocObjects.ObjectLinetypeSource.LinetypeFromObject
        rhinoObject.Attributes.LinetypeIndex <- newIndex
        rhinoObject.CommitChanges() |> ignore
        State.Doc.Views.Redraw()

    ///<summary>Modifies the linetype of multiple object.</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of objects</param>
    ///<param name="linetype">(string) Name of an existing linetype</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectLinetype(objectIds:Guid seq, linetype:string) : unit = //MULTISET
        let newIndex = State.Doc.Linetypes.Find(linetype)
        if newIndex <0 then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectLinetype: Setting it failed for '%A' and '%A'"  linetype objectIds
        for objectId in objectIds do
            let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            rhinoObject.Attributes.LinetypeSource <- DocObjects.ObjectLinetypeSource.LinetypeFromObject
            rhinoObject.Attributes.LinetypeIndex <- newIndex
            rhinoObject.CommitChanges() |> ignore
        State.Doc.Views.Redraw()


    ///<summary>Returns the linetype source of an object.</summary>
    ///<param name="objectId">(Guid) Identifier of object</param>
    ///<returns>(int) The object's current linetype source
    ///      0 = By Layer
    ///      1 = By Object
    ///      3 = By Parent.</returns>
    static member ObjectLinetypeSource(objectId:Guid) : int = //GET
        let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let oldSource = rhinoObject.Attributes.LinetypeSource
        int(oldSource)

    ///<summary>Modifies the linetype source of an object.</summary>
    ///<param name="objectId">(Guid) Identifier of object</param>
    ///<param name="source">(int) New linetype source.
    ///    If objectId is a list of identifiers, this parameter is required
    ///      0 = By Layer
    ///      1 = By Object
    ///      3 = By Parent</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectLinetypeSource(objectId:Guid, source:int) : unit = //SET
        let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if source <0 || source >3 || source = 2 then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectLinetypeSource: Setting it failed for '%A' and '%A'"  source objectId
        let source : DocObjects.ObjectLinetypeSource = LanguagePrimitives.EnumOfValue source
        rhinoObject.Attributes.LinetypeSource <- source
        rhinoObject.CommitChanges() |> ignore
        State.Doc.Views.Redraw()

    ///<summary>Modifies the linetype source of multiple objects.</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of objects</param>
    ///<param name="source">(int) New linetype source.
    ///    If objectId is a list of identifiers, this parameter is required
    ///      0 = By Layer
    ///      1 = By Object
    ///      3 = By Parent</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectLinetypeSource(objectIds:Guid seq, source:int) : unit = //MULTISET
        if source <0 || source >3 || source = 2 then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectLinetypeSource: Setting it failed for '%A' and '%A'"  source objectIds
        let source : DocObjects.ObjectLinetypeSource = LanguagePrimitives.EnumOfValue source
        for objectId in objectIds do
            let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            rhinoObject.Attributes.LinetypeSource <- source
            rhinoObject.CommitChanges() |> ignore
        State.Doc.Views.Redraw()


    ///<summary>Returns the material index of an object. Rendering materials are stored in
    /// Rhino's rendering material table. The table is conceptually an array. Render
    /// materials associated with objects and layers are specified by zero based
    /// indices into this array.</summary>
    ///<param name="objectId">(Guid) Identifier of an object</param>
    ///<returns>(int) If the return value of ObjectMaterialSource is "material by object", then
    ///    the return value of this function is the index of the object's rendering
    ///    material. A material index of -1 indicates no material has been assigned,
    ///    and that Rhino's internal default material has been assigned to the object.</returns>
    static member ObjectMaterialIndex(objectId:Guid) : int = //GET
        let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        rhinoObject.Attributes.MaterialIndex

    ///<summary>Changes the material index of an object. Rendering materials are stored in
    /// Rhino's rendering material table. The table is conceptually an array. Render
    /// materials associated with objects and layers are specified by zero based
    /// indices into this array.</summary>
    ///<param name="objectId">(Guid) Identifier of an object</param>
    ///<param name="materialIndex">(int) The new material index</param>
    static member ObjectMaterialIndex(objectId:Guid, materialIndex:int) : unit = //SET
        let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if 0 <= materialIndex && materialIndex < State.Doc.Materials.Count then
            RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectMaterialIndex: Setting it failed for '%A' and '%A'"  materialIndex objectId
        let attrs = rhinoObject.Attributes
        attrs.MaterialIndex <- materialIndex
        if not <| State.Doc.Objects.ModifyAttributes(rhinoObject, attrs, quiet=true) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectMaterialIndex: Setting it failed for '%A' and '%A'"  materialIndex objectId

    ///<summary>Changes the material index multiple objects. Rendering materials are stored in
    /// Rhino's rendering material table. The table is conceptually an array. Render
    /// materials associated with objects and layers are specified by zero based
    /// indices into this array.</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of an objects</param>
    ///<param name="materialIndex">(int) The new material index</param>
    static member ObjectMaterialIndex(objectIds:Guid seq, materialIndex:int) : unit = //MULTISET
        if 0 <= materialIndex && materialIndex < State.Doc.Materials.Count then
            RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectMaterialIndex: Setting it failed for '%A' and '%A'"  materialIndex objectIds
        for objectId in objectIds do
            let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            let attrs = rhinoObject.Attributes
            attrs.MaterialIndex <- materialIndex
            if not <| State.Doc.Objects.ModifyAttributes(rhinoObject, attrs, quiet=true) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectMaterialIndex: Setting it failed for '%A' and '%A'"  materialIndex objectId

    ///<summary>Returns the rendering material source of an object.</summary>
    ///<param name="objectId">(Guid) One or more object identifiers</param>
    ///<returns>(int) The current rendering material source
    ///    0 = Material from layer
    ///    1 = Material from object
    ///    3 = Material from parent.</returns>
    static member ObjectMaterialSource(objectId:Guid) : int = //GET
        let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        int(rhinoObject.Attributes.MaterialSource)


    ///<summary>Modifies the rendering material source of an object.</summary>
    ///<param name="objectId">(Guid) One or more object identifiers</param>
    ///<param name="source">(int) The new rendering material source.
    ///    0 = Material from layer
    ///    1 = Material from object
    ///    3 = Material from parent</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectMaterialSource(objectId:Guid, source:int) : unit = //SET
        let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if source <0 || source >3 || source = 2 then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectMaterialSource: Setting it failed for '%A' and '%A'"  source objectId
        let source :DocObjects.ObjectMaterialSource  = LanguagePrimitives.EnumOfValue  source
        rhinoObject.Attributes.MaterialSource <- source
        rhinoObject.CommitChanges() |> ignore
        State.Doc.Views.Redraw()

    ///<summary>Modifies the rendering material source of multiple objects.</summary>
    ///<param name="objectIds">(Guid seq) One or more objects identifiers</param>
    ///<param name="source">(int) The new rendering material source.
    ///    0 = Material from layer
    ///    1 = Material from objects
    ///    3 = Material from parent</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectMaterialSource(objectIds:Guid seq, source:int) : unit = //MULTISET
        if source <0 || source >3 || source = 2 then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectMaterialSource: Setting it failed for '%A' and '%A'"  source objectIds
        let source :DocObjects.ObjectMaterialSource  = LanguagePrimitives.EnumOfValue  source
        for objectId in objectIds do
            let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            rhinoObject.Attributes.MaterialSource <- source
            rhinoObject.CommitChanges() |> ignore
        State.Doc.Views.Redraw()


    ///<summary>Checks if a string is a good string for use in Rhino Object Names or User Dictionary key as and values.
    /// A good string may not include line returns, tabs, and leading or trailing whitespace.
    /// Confusing characters that look like ASCII but are some other Unicode are also not allowed. </summary>
    ///<param name="name">(string) The string to check.</param>
    ///<param name="allowEmpty">(bool) Optional, default value: <c>false</c> , set to true to make empty strings pass. </param>
    ///<param name="limitToAscii">(bool) Optional, default value: <c>false</c> , set to true to only allow chars between Unicode points 32 till 126 (ASCII) </param>
    ///<returns>(bool) true if the string is a valid name.</returns>
    static member IsGoodStringId    ( name:string
                                    , [<OPT;DEF(false)>]allowEmpty:bool
                                    , [<OPT;DEF(false)>]limitToAscii:bool
                                    ) : bool =
        if limitToAscii then
            Util.isASCIIStringId( name, allowEmpty)
        else
            Util.isGoodStringId( name, allowEmpty)



    ///<summary>Returns the name of an object or "" if none given.</summary>
    ///<param name="objectId">(Guid)Id of object</param>
    ///<returns>(string) The current object name, or empty string if no name given .</returns>
    static member ObjectName(objectId:Guid) : string = //GET
        let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let n = rhinoObject.Attributes.Name
        if isNull n then ""
        else n

    ///<summary>Modifies the name of an object.</summary>
    ///<param name="objectId">(Guid)Id of object</param>
    ///<param name="name">(string) The new object name. Or empty string</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectName(objectId:Guid, name:string) : unit = //SET
        let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if RhinoScriptSyntax.IsGoodStringId( name, allowEmpty=true) then
            rhinoObject.Attributes.Name <- name
            rhinoObject.CommitChanges() |> ignore
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectName: Setting it string '%s' cannot be used as Name. see RhinoScriptSyntax.IsGoodStringId. You can use RhinoCommon to bypass some of these restrictions." name

    ///<summary>Modifies the name of multiple objects.</summary>
    ///<param name="objectIds">(Guid seq)Id of objects</param>
    ///<param name="name">(string) The new objects name. Or empty string</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectName(objectIds:Guid seq, name:string) : unit = //MULTISET
        if RhinoScriptSyntax.IsGoodStringId( name, allowEmpty=true) then
            for objectId in objectIds do
                let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
                rhinoObject.Attributes.Name <- name
                rhinoObject.CommitChanges() |> ignore
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectName: Setting it string '%s' cannot be used as Name. see RhinoScriptSyntax.IsGoodStringId. You can use RhinoCommon to bypass some of these restrictions." name



    ///<summary>Returns the print color of an object.</summary>
    ///<param name="objectId">(Guid) Identifier of object</param>
    ///<returns>(Drawing.Color) The object's current print color.</returns>
    static member ObjectPrintColor(objectId:Guid) : Drawing.Color = //GET
        let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        rhinoObject.Attributes.PlotColor



    ///<summary>Modifies the print color of an object.</summary>
    ///<param name="objectId">(Guid) Identifier of object</param>
    ///<param name="color">(Drawing.Color) New print color.</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectPrintColor(objectId:Guid, color:Drawing.Color) : unit = //SET
        let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        rhinoObject.Attributes.PlotColorSource <- DocObjects.ObjectPlotColorSource.PlotColorFromObject
        rhinoObject.Attributes.PlotColor <- color
        rhinoObject.CommitChanges() |> ignore
        State.Doc.Views.Redraw()

    ///<summary>Modifies the print color of multiple objects.</summary>
    ///<param name="objectIds">(Guid seq) Identifier of objects</param>
    ///<param name="color">(Drawing.Color) New print color.</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectPrintColor(objectIds:Guid seq, color:Drawing.Color) : unit = //MULTISET
        for objectId in objectIds do
            let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            rhinoObject.Attributes.PlotColorSource <- DocObjects.ObjectPlotColorSource.PlotColorFromObject
            rhinoObject.Attributes.PlotColor <- color
            rhinoObject.CommitChanges() |> ignore
        State.Doc.Views.Redraw()

    ///<summary>Returns the print color source of an object.</summary>
    ///<param name="objectId">(Guid) Identifier of object</param>
    ///<returns>(int) The object's current print color source
    ///    0 = print color by layer
    ///    1 = print color by object
    ///    3 = print color by parent.</returns>
    static member ObjectPrintColorSource(objectId:Guid) : int = //GET
            let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            int(rhinoObject.Attributes.PlotColorSource)


    ///<summary>Modifies the print color source of an object.</summary>
    ///<param name="objectId">(Guid) Identifier of object</param>
    ///<param name="source">(int) New print color source
    ///    0 = print color by layer
    ///    1 = print color by object
    ///    3 = print color by parent</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectPrintColorSource(objectId:Guid, source:int) : unit = //SET
        if source <0 || source >3 || source = 2 then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectPrintColorSource: Setting it failed for '%A' and '%A'"  source objectId
        let source : DocObjects.ObjectPlotColorSource = LanguagePrimitives.EnumOfValue source
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        rhobj.Attributes.PlotColorSource <- source
        rhobj.CommitChanges() |> ignore
        State.Doc.Views.Redraw()

    ///<summary>Modifies the print color source of multiple objects.</summary>
    ///<param name="objectIds">(Guid seq) Identifier of objects</param>
    ///<param name="source">(int) New print color source
    ///    0 = print color by layer
    ///    1 = print color by objects
    ///    3 = print color by parent</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectPrintColorSource(objectIds:Guid seq, source:int) : unit = //MULTISET
        if source <0 || source >3 || source = 2 then RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectPrintColorSource: Setting it failed for '%A' and '%A'"  source objectIds
        let source : DocObjects.ObjectPlotColorSource = LanguagePrimitives.EnumOfValue source
        for objectId in objectIds do
            let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            rhobj.Attributes.PlotColorSource <- source
            rhobj.CommitChanges() |> ignore
        State.Doc.Views.Redraw()

    ///<summary>Returns the print width of an object.</summary>
    ///<param name="objectId">(Guid) Identifier of object</param>
    ///<returns>(float) The object's current print width.</returns>
    static member ObjectPrintWidth(objectId:Guid) : float = //GET
            let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            rhinoObject.Attributes.PlotWeight


    ///<summary>Modifies the print width of an object.</summary>
    ///<param name="objectId">(Guid) Identifier of object</param>
    ///<param name="width">(float) New print width value in millimeters, where width = 0.0 means use
    ///    the default width, and width smaller than 0.0 (e.g. -1.0)means do-not-print (visible for screen display,
    ///    but does not show on print)</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectPrintWidth(objectId:Guid, width:float) : unit = //SET
        let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        rhinoObject.Attributes.PlotWeightSource <- DocObjects.ObjectPlotWeightSource.PlotWeightFromObject
        rhinoObject.Attributes.PlotWeight <- width
        rhinoObject.CommitChanges() |> ignore
        State.Doc.Views.Redraw()

    ///<summary>Modifies the print width of multiple objects.</summary>
    ///<param name="objectIds">(Guid seq) Identifier of objects</param>
    ///<param name="width">(float) New print width value in millimeters, where width = 0.0 means use
    ///    the default width, and width smaller than 0.0 (e.g. -1.0)means do-not-print (visible for screen display,
    ///    but does not show on print)</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectPrintWidth(objectIds:Guid seq, width:float) : unit = //MULTISET
        for objectId in objectIds do
            let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            rhinoObject.Attributes.PlotWeightSource <- DocObjects.ObjectPlotWeightSource.PlotWeightFromObject
            rhinoObject.Attributes.PlotWeight <- width
            rhinoObject.CommitChanges() |> ignore
        State.Doc.Views.Redraw()


    ///<summary>Returns the print width source of an object.</summary>
    ///<param name="objectId">(Guid) Identifier of object</param>
    ///<returns>(int) The object's current print width source
    ///    0 = print width by layer
    ///    1 = print width by object
    ///    3 = print width by parent.</returns>
    static member ObjectPrintWidthSource(objectId:Guid) : int = //GET
            let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            int(rhinoObject.Attributes.PlotWeightSource)


    ///<summary>Modifies the print width source of an object.</summary>
    ///<param name="objectId">(Guid) Identifier of object</param>
    ///<param name="source">(int) New print width source
    ///    0 = print width by layer
    ///    1 = print width by object
    ///    3 = print width by parent</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectPrintWidthSource(objectId:Guid, source:int) : unit = //SET
        let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        rhinoObject.Attributes.PlotWeightSource <- LanguagePrimitives.EnumOfValue source
        rhinoObject.CommitChanges() |> ignore
        State.Doc.Views.Redraw()

    ///<summary>Modifies the print width source of multiple objects.</summary>
    ///<param name="objectIds">(Guid seq) Identifier of objects</param>
    ///<param name="source">(int) New print width source
    ///    0 = print width by layer
    ///    1 = print width by objects
    ///    3 = print width by parent</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ObjectPrintWidthSource(objectIds:Guid seq, source:int) : unit = //MULTISET
        for objectId in objectIds do
            let rhinoObject = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            rhinoObject.Attributes.PlotWeightSource <- LanguagePrimitives.EnumOfValue source
            rhinoObject.CommitChanges() |> ignore
        State.Doc.Views.Redraw()


    ///<summary>Returns the object type.</summary>
    ///<param name="objectId">(Guid) Identifier of an object</param>
    ///<returns>(int) The object type .
    ///    The valid object types are as follows:
    ///    Value   Description
    ///      0           Unknown object
    ///      1           Point
    ///      2           Point cloud
    ///      4           Curve
    ///      8           Surface or single-face brep
    ///      16          Polysurface or multiple-face
    ///      32          Mesh
    ///      256         Light
    ///      512         Annotation
    ///      4096        Instance or block reference
    ///      8192        Text dot object
    ///      16384       Grip object
    ///      32768       Detail
    ///      65536       Hatch
    ///      131072      Morph control
    ///      262144      SubD
    ///      134217728   Cage
    ///      268435456   Phantom
    ///      536870912   Clipping Plane
    ///      1073741824  Extrusion.</returns>
    static member ObjectType(objectId:Guid) : int =
        let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let geom = rhobj.Geometry
        match geom with
        | :? Brep as b ->
            if b.Faces.Count = 1 then 8 //surface //TODO extrusion too?
            else int(geom.ObjectType)
        |_ -> int(geom.ObjectType)


    ///<summary>Orients a single object based on input points.
    /// If two 3-D points are specified, then this method will
    /// function similar to Rhino's Orient command.
    /// If more than two 3-D points are specified,
    /// then the function will orient similar to Rhino's Orient3Pt command.
    /// </summary>
    ///<param name="objectId">(Guid) Identifier of object</param>
    ///<param name="referencePts">(IList of Point3d) list of 3D reference points.</param>
    ///<param name="targetPts">(IList of Point3d) list of 3D target points.</param>
    ///<param name="flags">(int) The orient flags values can be added together to specify multiple options.
    ///    Value   Description
    ///    1       Copy object.  The default is not to copy the object.
    ///    2       Scale object.  The default is not to scale the object.  Note, the scale option only applies if both reference and target contain only two 3-D points.
    ///    3       Scale and copy.
    ///</param>
    ///<returns>(Guid) The identifier of the oriented object. The original or the copied object. Depending on given flags</returns>
    static member OrientObject( objectId:Guid,  referencePts:IList<Point3d>,  targetPts:IList<Point3d>,   [<OPT;DEF(0)>]flags:int) : Guid =
        if referencePts.Count <> targetPts.Count then
            RhinoScriptingException.Raise "RhinoScriptSyntax.OrientObject referencePts.Count <> targetPts.Count: %d <> %d " referencePts.Count targetPts.Count
        if referencePts.Count < 2 then
            RhinoScriptingException.Raise "RhinoScriptSyntax.OrientObject referencePts.Count < 2: %d  " referencePts.Count
        if targetPts.Count < 2 then
            RhinoScriptingException.Raise "RhinoScriptSyntax.OrientObject targetPts.Count < 2 : %d"  targetPts.Count

        let copy  = (flags &&& 1) = 1
        let scale = (flags &&& 2) = 2
        let xform =
            if referencePts.Count > 2 then
                //Orient3Pt
                let fromPlane = Rhino.Geometry.Plane(referencePts.[0], referencePts.[1], referencePts.[2])
                let toPlane = Rhino.Geometry.Plane(targetPts.[0], targetPts.[1], targetPts.[2])
                if not fromPlane.IsValid || not toPlane.IsValid then
                    RhinoScriptingException.Raise "RhinoScriptSyntax.OrientObject unable to create valid planes from point lists %A and %A " referencePts targetPts
                Rhino.Geometry.Transform.PlaneToPlane(fromPlane, toPlane)
            else
                //Orient2Pt
                let xformMove = Rhino.Geometry.Transform.Translation( targetPts.[0]-referencePts.[0] )
                let v0 = referencePts.[1] - referencePts.[0]
                let v1 = targetPts.[1] - targetPts.[0]
                let xformScale =
                    if scale then
                        let len0 = v0.Length
                        let len1 = v1.Length
                        if len0 < 0.000001 || len1 < 0.000001 then RhinoScriptingException.Raise "RhinoScriptSyntax.OrientObject vector lengths too short"
                        let scaleF = len1 / len0
                        if abs(1.0-scaleF) >= 0.000001 then
                            let plane = Rhino.Geometry.Plane(referencePts.[0], v0)
                            Rhino.Geometry.Transform.Scale(plane, scaleF, scaleF, scaleF)
                        else
                            Rhino.Geometry.Transform.Identity
                    else
                        Rhino.Geometry.Transform.Identity
                v0.Unitize()  |> ignore
                v1.Unitize()  |> ignore
                let xformRotate = Rhino.Geometry.Transform.Rotation(v0, v1, referencePts.[0])
                xformMove * xformScale * xformRotate

        let rc = RhinoScriptSyntax.Ot.Transform(objectId, xform, not copy)
        if rc=System.Guid.Empty then
            RhinoScriptingException.Raise "RhinoScriptSyntax.OrientObject failed"
        RhinoScriptSyntax.Doc.Views.Redraw()
        rc


    ///<summary>Rotates a single object.</summary>
    ///<param name="objectId">(Guid) The identifier of an object to rotate</param>
    ///<param name="centerPoint">(Point3d) The center of rotation</param>
    ///<param name="rotationAngle">(float) In degrees</param>
    ///<param name="axis">(Vector3d) Optional, default value: <c>Vector3d.ZAxis</c>
    ///    Axis of rotation, If omitted, the Vector3d.ZAxis is used as the rotation axis</param>
    ///<param name="copy">(bool) Optional, default value: <c>false</c>. Copy the object</param>
    ///<returns>(Guid) Identifier of the rotated object.</returns>
    static member RotateObject( objectId:Guid,
                                centerPoint:Point3d,
                                rotationAngle:float,
                                [<OPT;DEF(Vector3d())>]axis:Vector3d,
                                [<OPT;DEF(false)>]copy:bool) : Guid =
        let axis = if axis.IsZero then Vector3d.ZAxis else axis
        let rotationAngle = RhinoMath.ToRadians(rotationAngle)
        let xf = Transform.Rotation(rotationAngle, axis, centerPoint)
        let res = State.Doc.Objects.Transform(objectId, xf, not copy)
        if res = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.RotateObject failed.  objectId:'%s' centerPoint:'%A' rotationAngle:'%A' axis:'%A' copy:'%A'" (Nice.str objectId) centerPoint rotationAngle axis copy
        res


    ///<summary>Rotates multiple objects.</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of objects to rotate</param>
    ///<param name="centerPoint">(Point3d) The center of rotation</param>
    ///<param name="rotationAngle">(float) In degrees</param>
    ///<param name="axis">(Vector3d) Optional, default value: <c>Vector3d.ZAxis</c>
    ///    Axis of rotation, If omitted, the Vector3d.ZAxis is used as the rotation axis</param>
    ///<param name="copy">(bool) Optional, default value: <c>false</c>. Copy the object</param>
    ///<returns>(Guid ResizeArray) identifiers of the rotated objects.</returns>
    static member RotateObjects( objectIds:Guid seq,
                                 centerPoint:Point3d,
                                 rotationAngle:float,
                                 [<OPT;DEF(Vector3d())>]axis:Vector3d,
                                 [<OPT;DEF(false)>]copy:bool) : Guid ResizeArray = //PLURAL
        let axis = if axis.IsZero then Vector3d.ZAxis else axis
        let rotationAngle = RhinoMath.ToRadians(rotationAngle)
        let xf = Transform.Rotation(rotationAngle, axis, centerPoint)
        let rc = ResizeArray()
        for objectId in objectIds do
            let res = State.Doc.Objects.Transform(objectId, xf, not copy)
            if res = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.RotateObjects failed.  objectId:'%s' centerPoint:'%A' rotationAngle:'%A' axis:'%A' copy:'%A'" (Nice.str objectId) centerPoint rotationAngle axis copy
            rc.Add res
        rc


    ///<summary>Scales a single object. Can be used to perform a uniform or non-uniform
    ///    scale transformation. Scaling is based on the WorldXY Plane.</summary>
    ///<param name="objectId">(Guid) The identifier of an object</param>
    ///<param name="origin">(Point3d) The origin of the scale transformation</param>
    ///<param name="scale">(float*float*float) Three numbers that identify the X, Y, and Z axis scale factors to apply</param>
    ///<param name="copy">(bool) Optional, default value: <c>false</c>.Copy the object</param>
    ///<returns>(Guid) Identifier of the scaled object.</returns>
    static member ScaleObject( objectId:Guid,
                               origin:Point3d,
                               scale:float*float*float,
                               [<OPT;DEF(false)>]copy:bool) : Guid =
        let mutable plane = Plane.WorldXY
        plane.Origin <- origin
        let x, y, z = scale
        let xf = Transform.Scale(plane, x, y, z)
        let res = State.Doc.Objects.Transform(objectId, xf, not copy)
        if res = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.ScaleObject failed.  objectId:'%s' origin:'%A' scale:'%A' copy:'%A'" (Nice.str objectId) origin scale  copy
        res

    ///<summary>Scales a single object. Uniform scale transformation. Scaling is based on the WorldXY Plane.</summary>
    ///<param name="objectId">(Guid) The identifier of an object</param>
    ///<param name="origin">(Point3d) The origin of the scale transformation</param>
    ///<param name="scale">(float) One numbers that identify the X, Y, and Z axis scale factors to apply</param>
    ///<param name="copy">(bool) Optional, default value: <c>false</c>. Copy the object</param>
    ///<returns>(Guid) Identifier of the scaled object.</returns>
    static member ScaleObject( objectId:Guid,
                               origin:Point3d,
                               scale:float,
                               [<OPT;DEF(false)>]copy:bool) : Guid = //ALT
        let mutable plane = Plane.WorldXY
        plane.Origin <- origin
        let xf = Transform.Scale(plane, scale, scale, scale)
        let res = State.Doc.Objects.Transform(objectId, xf, not copy)
        if res = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.ScaleObject failed.  objectId:'%s' origin:'%A' scale:'%A' copy:'%A'" (Nice.str objectId) origin scale  copy
        res

    ///<summary>Scales one or more objects. Can be used to perform a uniform or non-
    ///    uniform scale transformation. Scaling is based on the WorldXY Plane.</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of objects to scale</param>
    ///<param name="origin">(Point3d) The origin of the scale transformation</param>
    ///<param name="scale">(float*float*float) Three numbers that identify the X, Y, and Z axis scale factors to apply</param>
    ///<param name="copy">(bool) Optional, default value: <c>false</c>. Copy the objects</param>
    ///<returns>(Guid ResizeArray) identifiers of the scaled objects.</returns>
    static member ScaleObjects( objectIds:Guid seq,
                                origin:Point3d,
                                scale:float*float*float,
                                [<OPT;DEF(false)>]copy:bool) : Guid ResizeArray =  //PLURAL
        let mutable plane = Plane.WorldXY
        plane.Origin <- origin
        let x, y, z = scale
        let xf = Transform.Scale(plane, x, y, z)
        let rc = ResizeArray()
        for objectId in objectIds do
            let res = State.Doc.Objects.Transform(objectId, xf, not copy)
            if res = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.ScaleObjects failed.  objectId:'%s' origin:'%s' scale:'%A' copy:'%b'" (Nice.str objectId) origin.ToNiceString scale  copy
            rc.Add res
        rc

    ///<summary>Scales one or more objects. Uniform scale transformation. Scaling is based on the WorldXY Plane.</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of objects to scale</param>
    ///<param name="origin">(Point3d) The origin of the scale transformation</param>
    ///<param name="scale">(float) One numbers that identify the X, Y, and Z axis scale factors to apply</param>
    ///<param name="copy">(bool) Optional, default value: <c>false</c>
    ///    Copy the objects</param>
    ///<returns>(Guid ResizeArray) identifiers of the scaled objects.</returns>
    static member ScaleObjects( objectIds:Guid seq,
                                origin:Point3d,
                                scale:float,
                                [<OPT;DEF(false)>]copy:bool) : Guid ResizeArray =  //PLURAL ALT
        let mutable plane = Plane.WorldXY
        plane.Origin <- origin
        let xf = Transform.Scale(plane, scale, scale, scale)
        let rc = ResizeArray()
        for objectId in objectIds do
            let res = State.Doc.Objects.Transform(objectId, xf, not copy)
            if res = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.ScaleObjects failed.  objectId:'%s' origin:'%A' scale:'%A' copy:'%A'" (Nice.str objectId) origin scale  copy
            rc.Add res
        rc



    ///<summary>Selects a single object.
    /// Throws an exception if object can't be selected for some reason
    ///  e.g. when locked , hidden, or on invisible layer .</summary>
    ///<param name="objectId">(Guid) The identifier of the object to select</param>
    ///<param name="forceVisible">(bool) Optional, default value: <c>false</c> whether to make objects that a hidden or layers that are off visible and unlocked </param>
    ///<param name="ignoreErrors">(bool) Optional, default value: <c>false</c> whether to ignore errors when object can be set visible </param>
    ///<returns>(unit) void, nothing.</returns>
    static member SelectObject( objectId:Guid,
                                [<OPT;DEF(false)>]forceVisible:bool,
                                [<OPT;DEF(false)>]ignoreErrors:bool) : unit =
        RhinoSync.DoSync (fun () ->
            let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            if 0 = rhobj.Select(true) then
                if not ignoreErrors then
                    let mutable redo = false
                    let lay = State.Doc.Layers.[rhobj.Attributes.LayerIndex]
                    if rhobj.IsHidden then
                        if forceVisible then redo <- true ; State.Doc.Objects.Show(rhobj, ignoreLayerMode=true) |> ignore
                        else RhinoScriptingException.Raise "RhinoScriptSyntax.SelectObject failed on hidden object %s" (Nice.str objectId)
                    elif rhobj.IsLocked then
                        if forceVisible then redo <- true ; State.Doc.Objects.Unlock(rhobj, ignoreLayerMode=true) |> ignore
                        else RhinoScriptingException.Raise "RhinoScriptSyntax.SelectObject failed on locked object %s" (Nice.str objectId)
                    elif not lay.IsVisible then
                        if forceVisible then redo <- true ; UtilLayer.visibleSetTrue(lay, true)
                        else RhinoScriptingException.Raise "RhinoScriptSyntax.SelectObject failed on invisible layer %s for object %s" lay.FullPath (Nice.str objectId)
                    elif not lay.IsLocked then
                        if forceVisible then redo <- true ; UtilLayer.lockedSetFalse(lay, true)
                        else RhinoScriptingException.Raise "RhinoScriptSyntax.SelectObject failed on locked layer %s for object %s" lay.FullPath (Nice.str objectId)
                    else
                        RhinoScriptingException.Raise "RhinoScriptSyntax.SelectObject failed on object %s" (Nice.str objectId)
                    if redo then
                        if 0 = rhobj.Select(true) then
                            RhinoScriptingException.Raise "RhinoScriptSyntax.SelectObject failed despite forceVisible being set to true on object %s" (Nice.str objectId)
            State.Doc.Views.Redraw()
            )

    ///<summary>Selects one or more objects
    /// Throws an exception if object can't be selected for some reason
    ///  e.g. when locked , hidden, or on invisible layer .</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of the objects to select</param>
    ///<param name="forceVisible">(bool) Optional, default value: <c>false</c> whether to make objects that a hidden or layers that are off visible and unlocked </param>
    ///<param name="ignoreErrors">(bool) Optional, default value: <c>false</c> whether to ignore errors when object can be set visible </param>
    ///<returns>(unit) void, nothing.</returns>
    static member SelectObjects( objectIds:Guid seq,
                                [<OPT;DEF(false)>]forceVisible:bool,
                                [<OPT;DEF(false)>]ignoreErrors:bool) : unit =  //PLURAL
        RhinoSync.DoSync (fun () ->
            for objectId in objectIds do
                let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
                if 0 = rhobj.Select(true) then
                    if not ignoreErrors then
                        let mutable redo = false
                        let lay = State.Doc.Layers.[rhobj.Attributes.LayerIndex]
                        if rhobj.IsHidden then
                            if forceVisible then redo <- true ; State.Doc.Objects.Show(rhobj, ignoreLayerMode=true) |> ignore
                            else RhinoScriptingException.Raise "RhinoScriptSyntax.SelectObjects failed on hidden object %s out of %d objects" (Nice.str objectId) (Seq.length objectIds)
                        elif rhobj.IsLocked then
                            if forceVisible then redo <- true ; State.Doc.Objects.Unlock(rhobj, ignoreLayerMode=true) |> ignore
                            else RhinoScriptingException.Raise "RhinoScriptSyntax.SelectObjects failed on locked object %s out of %d objects" (Nice.str objectId) (Seq.length objectIds)
                        elif not lay.IsVisible then
                            if forceVisible then redo <- true ; UtilLayer.visibleSetTrue(lay, true)
                            else RhinoScriptingException.Raise "RhinoScriptSyntax.SelectObjects failed on invisible layer %s for object %s out of %d objects" lay.FullPath (Nice.str objectId) (Seq.length objectIds)
                        elif not lay.IsLocked then
                            if forceVisible then redo <- true ; UtilLayer.lockedSetFalse(lay, true)
                            else RhinoScriptingException.Raise "RhinoScriptSyntax.SelectObjects failed on locked layer %s for object %s out of %d objects" lay.FullPath (Nice.str objectId) (Seq.length objectIds)
                        else
                            RhinoScriptingException.Raise "RhinoScriptSyntax.SelectObjects failed on object %s out of %d objects" (Nice.str objectId) (Seq.length objectIds)
                        if redo then
                            if 0 = rhobj.Select(true) then
                                RhinoScriptingException.Raise "RhinoScriptSyntax.SelectObjects failed despite forceVisible being set to true on object %s out of %d objects" (Nice.str objectId) (Seq.length objectIds)
            State.Doc.Views.Redraw()
            )


    ///<summary>Perform a shear transformation on a single object.</summary>
    ///<param name="objectId">(Guid) The identifier of an object</param>
    ///<param name="origin">(Point3d) Origin point of the shear transformation</param>
    ///<param name="referencePoint">(Point3d) Reference point of the shear transformation</param>
    ///<param name="angleDegrees">(float) The shear angle in degrees</param>
    ///<param name="copy">(bool) Optional, default value: <c>false</c>
    ///    Copy the objects</param>
    ///<returns>(Guid) Identifier of the sheared object.</returns>
    static member ShearObject( objectId:Guid,
                               origin:Point3d,
                               referencePoint:Point3d,
                               angleDegrees:float,
                               [<OPT;DEF(false)>]copy:bool) : Guid =
       if (origin-referencePoint).IsTiny() then RhinoScriptingException.Raise "RhinoScriptSyntax.ShearObject failed because (origin-referencePoint).IsTiny() : %s and %s" origin.ToNiceString referencePoint.ToNiceString
       let plane = State.Doc.Views.ActiveView.MainViewport.ConstructionPlane()
       let mutable frame = Plane(plane)
       frame.Origin <- origin
       frame.ZAxis <- plane.Normal
       let yAxis = referencePoint-origin
       yAxis.Unitize() |> ignore
       frame.YAxis <- yAxis
       let xAxis = Vector3d.CrossProduct(frame.ZAxis, frame.YAxis)
       xAxis.Unitize() |> ignore
       frame.XAxis <- xAxis
       let worldPlane = Plane.WorldXY
       let cob = Transform.ChangeBasis(worldPlane, frame)
       let mutable shear2d = Transform.Identity
       shear2d.[0, 1] <- tan(toRadians(angleDegrees))
       let cobinv = Transform.ChangeBasis(frame, worldPlane)
       let xf = cobinv * shear2d * cob
       let res = State.Doc.Objects.Transform(objectId, xf, not copy)
       if res = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.ShearObject failed for %s, origin %s, ref point  %s and angle in Deg  %f" (Nice.str objectId) origin.ToNiceString referencePoint.ToNiceString angleDegrees
       res


    ///<summary>Shears one or more objects.</summary>
    ///<param name="objectIds">(Guid seq) The identifiers objects to shear</param>
    ///<param name="origin">(Point3d) Origin point of the shear transformation</param>
    ///<param name="referencePoint">(Point3d) Reference point of the shear transformation</param>
    ///<param name="angleDegrees">(float) The shear angle in degrees</param>
    ///<param name="copy">(bool) Optional, default value: <c>false</c>
    ///    Copy the objects</param>
    ///<returns>(Guid ResizeArray) identifiers of the sheared objects.</returns>
    static member ShearObjects( objectIds:Guid seq,
                                origin:Point3d,
                                referencePoint:Point3d,
                                angleDegrees:float,
                                [<OPT;DEF(false)>]copy:bool) : Guid ResizeArray = //PLURAL
        if (origin-referencePoint).IsTiny() then RhinoScriptingException.Raise "RhinoScriptSyntax.ShearObjects failed because (origin-referencePoint).IsTiny() : %s and %s" origin.ToNiceString referencePoint.ToNiceString
        let plane = State.Doc.Views.ActiveView.MainViewport.ConstructionPlane()
        let mutable frame = Plane(plane)
        frame.Origin <- origin
        frame.ZAxis <- plane.Normal
        let yAxis = referencePoint-origin
        yAxis.Unitize() |> ignore
        frame.YAxis <- yAxis
        let xAxis = Vector3d.CrossProduct(frame.ZAxis, frame.YAxis)
        xAxis.Unitize() |> ignore
        frame.XAxis <- xAxis
        let worldPlane = Plane.WorldXY
        let cob = Transform.ChangeBasis(worldPlane, frame)
        let mutable shear2d = Transform.Identity
        shear2d.[0, 1] <- tan(toRadians(angleDegrees))
        let cobinv = Transform.ChangeBasis(frame, worldPlane)
        let xf = cobinv * shear2d * cob
        resizeArray {
            for ob in objectIds do
                let res = State.Doc.Objects.Transform(ob, xf, not copy)
                if res = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.ShearObjects failed for %s, origin %s, ref point  %s and angle in Deg  %f" (Nice.str ob) origin.ToNiceString referencePoint.ToNiceString angleDegrees
                res  }


    ///<summary>Shows a previously hidden object. Hidden objects are not visible, cannot
    ///    be snapped to and cannot be selected.</summary>
    ///<param name="objectId">(Guid) Representing id of object to show</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ShowObject(objectId:Guid) : unit =
        if not <| State.Doc.Objects.Show(objectId, ignoreLayerMode=false) then RhinoScriptingException.Raise "RhinoScriptSyntax.ShowObject failed on %s" (Nice.str objectId)
        State.Doc.Views.Redraw()


    ///<summary>Shows one or more objects. Hidden objects are not visible, cannot be
    ///    snapped to and cannot be selected.</summary>
    ///<param name="objectIds">(Guid seq) Ids of objects to show.</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ShowObjects(objectIds:Guid seq) : unit = //PLURAL
        for objectId in objectIds do
            if not <| State.Doc.Objects.Show(objectId, ignoreLayerMode=false) then RhinoScriptingException.Raise "RhinoScriptSyntax.ShowObjects failed on %s" (Nice.str objectId)
        State.Doc.Views.Redraw()


    ///<summary>Unlocks an object. Locked objects are visible, and can be snapped to,
    ///    but they cannot be selected.</summary>
    ///<param name="objectId">(Guid) The identifier of an object</param>
    ///<returns>(unit) void, nothing.</returns>
    static member UnlockObject(objectId:Guid) : unit =
        if not <| State.Doc.Objects.Unlock(objectId, ignoreLayerMode=false) then RhinoScriptingException.Raise "RhinoScriptSyntax.UnlockObject failed on %s" (Nice.str objectId)
        State.Doc.Views.Redraw()

    ///<summary>Unlocks one or more objects. Locked objects are visible, and can be
    ///    snapped to, but they cannot be selected.</summary>
    ///<param name="objectIds">(Guid seq) The identifiers of objects</param>
    ///<returns>(unit) void, nothing.</returns>
    static member UnlockObjects(objectIds:Guid seq) : unit =  //PLURAL
        for objectId in objectIds do
            if not <| State.Doc.Objects.Unlock(objectId, ignoreLayerMode=false) then RhinoScriptingException.Raise "RhinoScriptSyntax.UnlockObjects failed on %s" (Nice.str objectId)
        State.Doc.Views.Redraw()


    ///<summary>Unselects a single selected object.</summary>
    ///<param name="objectId">(Guid) Id of object to unselect.</param>
    ///<returns>(unit) void, nothing.</returns>
    static member UnselectObject(objectId:Guid) : unit =
        let obj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if 0 <> obj.Select(false) then RhinoScriptingException.Raise "RhinoScriptSyntax.UnselectObject failed on %s" (Nice.str objectId)
        State.Doc.Views.Redraw()


    ///<summary>Unselects multiple selected objects.</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of the objects to unselect.</param>
    ///<returns>(unit) void, nothing.</returns>
    static member UnselectObjects(objectIds:Guid seq) : unit = //PLURAL
        for objectId in objectIds do
            let obj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            if 0 <> obj.Select(false) then RhinoScriptingException.Raise "RhinoScriptSyntax.UnselectObjects failed on %s" (Nice.str objectId)
        State.Doc.Views.Redraw()

    //---End of header marker: don't change: {@$%^&*()*&^%$@}


    ///<summary>Returns the distance from a 3D point to a Plane.</summary>
    ///<param name="plane">(Plane) The Plane</param>
    ///<param name="point">(Point3d) List of 3 numbers or Point3d</param>
    ///<returns>(float) The distance.</returns>
    static member DistanceToPlane(plane:Plane, point:Point3d) : float =
        //plane = RhinoScriptSyntax.CoercePlane(plane)
        //point = RhinoScriptSyntax.Coerce3dPoint(point)
        plane.DistanceTo(point)


    ///<summary>Evaluates a Plane at a U, V parameter.</summary>
    ///<param name="plane">(Plane) The Plane to evaluate</param>
    ///<param name="u">(float) U parameter to evaluate</param>
    ///<param name="v">(float) V parameter to evaluate</param>
    ///<returns>(Point3d) Point3d.</returns>
    static member EvaluatePlane(plane:Plane, u:float , v: float) : Point3d =
        //plane = RhinoScriptSyntax.CoercePlane(plane)
        plane.PointAt(u, v)


    ///<summary>Calculates the intersection of three Planes.</summary>
    ///<param name="plane1">(Plane) The 1st Plane to intersect</param>
    ///<param name="plane2">(Plane) The 2nd Plane to intersect</param>
    ///<param name="plane3">(Plane) The 3rd Plane to intersect</param>
    ///<returns>(Point3d) The intersection point between the 3 Planes.</returns>
    static member IntersectPlanes( plane1:Plane,
                                   plane2:Plane,
                                   plane3:Plane) : Point3d =
        //plane1 = RhinoScriptSyntax.CoercePlane(plane1)
        //plane2 = RhinoScriptSyntax.CoercePlane(plane2)
        //plane3 = RhinoScriptSyntax.CoercePlane(plane3)
        let rc, point = Intersect.Intersection.PlanePlanePlane(plane1, plane2, plane3)
        if rc then point
        else RhinoScriptingException.Raise "RhinoScriptSyntax.IntersectPlanes failed, are they parallel? %A; %A; %A" plane1 plane2 plane3


    ///<summary>Moves the origin of a Plane.</summary>
    ///<param name="plane">(Plane) Plane </param>
    ///<param name="origin">(Point3d) Point3d or list of three numbers</param>
    ///<returns>(Plane) moved Plane.</returns>
    static member MovePlane(plane:Plane, origin:Point3d) : Plane =
        //plane = RhinoScriptSyntax.CoercePlane(plane)
        //origin = RhinoScriptSyntax.Coerce3dPoint(origin)
        let mutable rc = Plane(plane)
        rc.Origin <- origin
        rc

    ///<summary>Flip this Plane by swapping out the X and Y axes and inverting the Z axis.</summary>
    ///<param name="plane">(Plane) Plane </param>
    ///<returns>(Plane) moved Plane.</returns>
    static member FlipPlane(plane:Plane) : Plane =
        let pl = Plane(plane)
        pl.Flip()
        pl


    ///<summary>Returns the point on a Plane that is closest to a test point.</summary>
    ///<param name="plane">(Plane) The Plane</param>
    ///<param name="point">(Point3d) The 3-D point to test</param>
    ///<returns>(Point3d) The 3-D point.</returns>
    static member PlaneClosestPoint( plane:Plane, point:Point3d) : Point3d =
        plane.ClosestPoint(point)


    ///<summary>Returns the point on a Plane that is closest to a test point.</summary>
    ///<param name="plane">(Plane) The Plane</param>
    ///<param name="point">(Point3d) The 3-D point to test</param>
    ///<returns>(float*float) The u and v parameter on the Plane of the closest point.</returns>
    static member PlaneClosestParameter( plane:Plane, point:Point3d) : float*float =
        let rc, s, t = plane.ClosestParameter(point)
        if rc then s, t
        else RhinoScriptingException.Raise "RhinoScriptSyntax.PlaneClosestParameter failed for %A; %A" plane point


    ///<summary>Intersect an infinite Plane and a Curve object.</summary>
    ///<param name="plane">(Plane) The Plane to intersect</param>
    ///<param name="curve">(Guid) The identifier of the Curve object</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c>
    ///    The intersection tolerance.</param>
    ///<returns>(ResizeArray of int * Point3d * Point3d * Point3d * Point3d * float * float * float * float* float * float)
    ///A list of intersection information tuple . The list will contain one or more of the following tuple:
    ///    Element Type        Description
    ///    [0]       Number      The intersection event type, either Point (1) or Overlap (2).
    ///    [1]       Point3d     If the event type is Point (1), then the intersection point on the Curve.
    ///      If the event type is Overlap (2), then intersection start point on the Curve.
    ///    [2]       Point3d     If the event type is Point (1), then the intersection point on the Curve.
    ///      If the event type is Overlap (2), then intersection end point on the Curve.
    ///    [3]       Point3d     If the event type is Point (1), then the intersection point on the Plane.
    ///      If the event type is Overlap (2), then intersection start point on the Plane.
    ///    [4]       Point3d     If the event type is Point (1), then the intersection point on the Plane.
    ///      If the event type is Overlap (2), then intersection end point on the Plane.
    ///    [5]       Number      If the event type is Point (1), then the Curve parameter.
    ///      If the event type is Overlap (2), then the start value of the Curve parameter range.
    ///    [6]       Number      If the event type is Point (1), then the Curve parameter.
    ///      If the event type is Overlap (2), then the end value of the Curve parameter range.
    ///    [7]       Number      If the event type is Point (1), then the U Plane parameter.
    ///      If the event type is Overlap (2), then the U Plane parameter for Curve at (n, 5).
    ///    [8]       Number      If the event type is Point (1), then the V Plane parameter.
    ///      If the event type is Overlap (2), then the V Plane parameter for Curve at (n, 5).
    ///    [9]       Number      If the event type is Point (1), then the U Plane parameter.
    ///      If the event type is Overlap (2), then the U Plane parameter for Curve at (n, 6).
    ///    [10]      Number      If the event type is Point (1), then the V Plane parameter.
    ///      If the event type is Overlap (2), then the V Plane parameter for Curve at (n, 6).</returns>
    static member PlaneCurveIntersection( plane:Plane,
                                          curve:Guid,
                                          [<OPT;DEF(0.0)>]tolerance:float) : ResizeArray<int * Point3d * Point3d * Point3d * Point3d * float * float * float * float* float * float > =
        let curve = RhinoScriptSyntax.CoerceCurve(curve)
        let  tolerance = if tolerance = 0.0 then  State.Doc.ModelAbsoluteTolerance else tolerance
        let intersections = Intersect.Intersection.CurvePlane(curve, plane, tolerance)
        if notNull intersections then
            let rc = ResizeArray()
            for intersection in intersections do
                let mutable a = 1
                if intersection.IsOverlap then a <- 2
                let b = intersection.PointA
                let c = intersection.PointA2
                let d = intersection.PointB
                let e = intersection.PointB2
                let f = intersection.ParameterA
                let g = intersection.ParameterB
                let h = intersection.OverlapA.[0]
                let i = intersection.OverlapA.[1]
                let j = intersection.OverlapB.[0]
                let k = intersection.OverlapB.[1]
                rc.Add( (a, b, c, d, e, f, g, h, i, j, k))
            rc
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.PlaneCurveIntersection failed on %A; %A tolerance %A" plane curve tolerance


    ///<summary>Returns the equation of a Plane as a tuple of four numbers. The standard
    ///    equation of a Plane with a non-zero vector is Ax + By + Cz + D = 0.</summary>
    ///<param name="plane">(Plane) The Plane to deconstruct</param>
    ///<returns>(float * float * float * float) containing four numbers that represent the coefficients of the equation  (A, B, C, D).</returns>
    static member PlaneEquation(plane:Plane) : float * float * float * float =
        //plane = RhinoScriptSyntax.CoercePlane(plane)
        let rc = plane.GetPlaneEquation()
        rc.[0], rc.[1], rc.[2], rc.[3]


    ///<summary>Returns a Plane that was fit through an array of 3D points.</summary>
    ///<param name="points">(Point3d seq) An array of 3D points</param>
    ///<returns>(Plane) The Plane.</returns>
    static member PlaneFitFromPoints(points:Point3d seq) : Plane =
        //points = RhinoScriptSyntax.Coerce3dPointlist(points)
        let rc, plane = Plane.FitPlaneToPoints(points)
        if rc = PlaneFitResult.Success then plane
        else RhinoScriptingException.Raise "RhinoScriptSyntax.PlaneFitFromPoints failed for %A" points


    ///<summary>Construct a Plane from a point, and two vectors in the Plane.</summary>
    ///<param name="origin">(Point3d) A 3D point identifying the origin of the Plane</param>
    ///<param name="xAxis">(Vector3d) A non-zero 3D vector in the Plane that determines the X axis
    ///    direction</param>
    ///<param name="yAxis">(Vector3d) A non-zero 3D vector not parallel to xAxis that is used
    ///    to determine the Y axis direction. Note, yAxis does not
    ///    have to be perpendicular to xAxis</param>
    ///<returns>(Plane) The Plane.</returns>
    static member PlaneFromFrame( origin:Point3d,
                                  xAxis:Vector3d,
                                  yAxis:Vector3d) : Plane =
        //origin = RhinoScriptSyntax.Coerce3dPoint(origin)
        //xAxis = RhinoScriptSyntax.Coerce3dvector(xAxis)
        //yAxis = RhinoScriptSyntax.Coerce3dvector(yAxis)
        Plane(origin, xAxis, yAxis)


    ///<summary>Creates a Plane from an origin point and a normal direction vector.</summary>
    ///<param name="origin">(Point3d) A 3D point identifying the origin of the Plane</param>
    ///<param name="normal">(Vector3d) A 3D vector identifying the normal direction of the Plane</param>
    ///<param name="xAxis">(Vector3d) Optional, vector defining the Plane's x-axis</param>
    ///<returns>(Plane) The Plane.</returns>
    static member PlaneFromNormal( origin:Point3d,
                                   normal:Vector3d,
                                   [<OPT;DEF(Vector3d())>]xAxis:Vector3d) : Plane =
        //origin = RhinoScriptSyntax.Coerce3dPoint(origin)
        //normal = RhinoScriptSyntax.Coerce3dvector(normal)
        let mutable rc = Plane(origin, normal)
        if not xAxis.IsZero then
            //x axis = RhinoScriptSyntax.Coerce3dvector(x axis)
            let xAxis = Vector3d(xAxis)//prevent original x axis parameter from being unitized too
            xAxis.Unitize() |> ignore
            let yAxis = Vector3d.CrossProduct(rc.Normal, xAxis)
            rc <- Plane(origin, xAxis, yAxis)
        rc


    ///<summary>Creates a Plane from three non-collinear points.</summary>
    ///<param name="origin">(Point3d) Origin point of the Plane</param>
    ///<param name="x">(Point3d) X point on the Plane's x  axis</param>
    ///<param name="y">(Point3d) Y point on the Plane's y axis</param>
    ///<returns>(Plane) The Plane.</returns>
    static member PlaneFromPoints( origin:Point3d,
                                   x:Point3d,
                                   y:Point3d) : Plane =
        //origin = RhinoScriptSyntax.Coerce3dPoint(origin)
        //x = RhinoScriptSyntax.Coerce3dPoint(x)
        //y = RhinoScriptSyntax.Coerce3dPoint(y)
        let plane = Plane(origin, x, y)
        if plane.IsValid then plane
        else RhinoScriptingException.Raise "RhinoScriptSyntax.PlaneFromPoints failed for %A; %A; %A" origin x y


    ///<summary>Calculates the intersection of two Planes.</summary>
    ///<param name="plane1">(Plane) The 1st Plane to intersect</param>
    ///<param name="plane2">(Plane) The 2nd Plane to intersect</param>
    ///<returns>(Line) a line with two 3d points identifying the starting/ending points of the intersection.</returns>
    static member PlanePlaneIntersection(plane1:Plane, plane2:Plane) : Line =
        //plane1 = RhinoScriptSyntax.CoercePlane(plane1)
        //plane2 = RhinoScriptSyntax.CoercePlane(plane2)
        let rc, line = Intersect.Intersection.PlanePlane(plane1, plane2)
        if rc then line
        else RhinoScriptingException.Raise "RhinoScriptSyntax.PlanePlaneIntersection failed for %A; %A" plane1 plane2


    ///<summary>Calculates the intersection of a Plane and a sphere.</summary>
    ///<param name="plane">(Plane) The Plane to intersect</param>
    ///<param name="spherePlane">(Plane) Equatorial Plane of the sphere. origin of the Plane is
    ///    the center of the sphere</param>
    ///<param name="sphereRadius">(float) Radius of the sphere</param>
    ///<returns>(int * Plane * float) of intersection results
    ///    Element  Type      Description
    ///    [0]      number     The type of intersection, where 0 = point and 1 = circle.
    ///    [1]      Plane      If a point intersection, the a Point3d identifying the 3-D intersection location is Plane.Origin
    ///                        If a circle intersection, then the circle's Plane. The origin of the Plane will be the center point of the circle
    ///    [2]      number     If a circle intersection, then the radius of the circle.</returns>
    static member PlaneSphereIntersection( plane:Plane,
                                           spherePlane:Plane,
                                           sphereRadius:float) : int * Plane * float =
        //plane = RhinoScriptSyntax.CoercePlane(plane)
        //spherePlane = RhinoScriptSyntax.CoercePlane(spherePlane)
        let sphere = Sphere(spherePlane, sphereRadius)
        let rc, circle = Intersect.Intersection.PlaneSphere(plane, sphere)
        if rc = Intersect.PlaneSphereIntersection.Point then
            0, circle.Plane, circle.Radius //was just circle.Center
        elif rc = Intersect.PlaneSphereIntersection.Circle then
            1, circle.Plane, circle.Radius
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.PlaneSphereIntersection failed for %A; %A, %A" plane spherePlane sphereRadius


    ///<summary>Transforms a Plane.</summary>
    ///<param name="plane">(Plane) Plane to transform</param>
    ///<param name="xForm">(Transform) Transformation to apply</param>
    ///<returns>(Plane) The resulting Plane.</returns>
    static member PlaneTransform(plane:Plane, xForm:Transform) : Plane =
        //plane = RhinoScriptSyntax.CoercePlane(plane)
        //xForm = RhinoScriptSyntax.CoercexForm(xForm)
        let rc = Plane(plane)
        if rc.Transform(xForm) then rc
        else RhinoScriptingException.Raise "RhinoScriptSyntax.PlaneTransform failed for %A; %A" plane xForm


    ///<summary>Rotates a Plane.</summary>
    ///<param name="plane">(Plane) Plane to rotate</param>
    ///<param name="angleDegrees">(float) Rotation angle in degrees</param>
    ///<param name="axis">(Vector3d) Axis of rotation or list of three numbers</param>
    ///<returns>(Plane) rotated Plane.</returns>
    static member RotatePlane( plane:Plane,
                               angleDegrees:float,
                               axis:Vector3d) : Plane =
        //plane = RhinoScriptSyntax.CoercePlane(plane)
        //axis = RhinoScriptSyntax.Coerce3dvector(axis)
        let angleradians = toRadians(angleDegrees)
        let rc = Plane(plane)
        if rc.Rotate(angleradians, axis) then rc
        else RhinoScriptingException.Raise "RhinoScriptSyntax.RotatePlane failed for %A; %A; %A" plane angleDegrees axis


    ///<summary>Returns Rhino's world XY Plane.</summary>
    ///<returns>(Plane) Rhino's world XY Plane.</returns>
    static member WorldXYPlane() : Plane =
        Plane.WorldXY


    ///<summary>Returns Rhino's world YZ Plane.</summary>
    ///<returns>(Plane) Rhino's world YZ Plane.</returns>
    static member WorldYZPlane() : Plane =
        Plane.WorldYZ


    ///<summary>Returns Rhino's world ZX Plane.</summary>
    ///<returns>(Plane) Rhino's world ZX Plane.</returns>
    static member WorldZXPlane() : Plane =
        Plane.WorldZX





    //---End of header marker: don't change: {@$%^&*()*&^%$@}


    ///<summary>Compares two vectors to see if they are parallel within one degree or custom tolerance.</summary>
    ///<param name="vector1">(Vector3d) Vector1 of the vectors to compare</param>
    ///<param name="vector2">(Vector3d) Vector2 of the vectors to compare</param>
    ///<param name="toleranceDegree">(float) Optional, default value: <c>1.0</c>
    ///    Angle Tolerance in degree</param>
    ///<returns>(int) The value represents
    ///     -1 = the vectors are anti-parallel
    ///      0 = the vectors are not parallel
    ///      1 = the vectors are parallel.</returns>
    static member IsVectorParallelTo(   vector1:Vector3d,
                                        vector2:Vector3d,
                                        [<OPT;DEF(0.0)>]toleranceDegree:float) : int =
        if toleranceDegree = 0.0 then vector1.IsParallelTo(vector2)
        else vector1.IsParallelTo(vector2, toRadians(toleranceDegree))


    ///<summary>Compares two vectors to see if they are perpendicular.</summary>
    ///<param name="vector1">(Vector3d) Vector1 of the vectors to compare</param>
    ///<param name="vector2">(Vector3d) Vector2 of the vectors to compare</param>
    ///<param name="toleranceDegree">(float) Optional, default value: <c>1.0</c>
    ///    Angle Tolerance in degree</param>
    ///<returns>(bool) True if vectors are perpendicular, otherwise False.</returns>
    static member IsVectorPerpendicularTo(  vector1:Vector3d,
                                            vector2:Vector3d,
                                            [<OPT;DEF(0.0)>]toleranceDegree:float) : bool =
        if toleranceDegree = 0.0 then vector1.IsPerpendicularTo(vector2)
        else vector1.IsPerpendicularTo(vector2, toRadians(toleranceDegree))



    ///<summary>Checks if a vector is very short. The X, Y, Z elements are smaller than 1.0e-12.</summary>
    ///<param name="vector">(Vector3d) The vector to check</param>
    ///<returns>(bool) True if the vector is tiny, otherwise False.</returns>
    static member IsVectorTiny(vector:Vector3d) : bool =
        vector.IsTiny( 1.0e-12 )


    ///<summary>Checks if a vector is zero. The X, Y, Z elements are equal to 0.0.</summary>
    ///<param name="vector">(Vector3d) The vector to check</param>
    ///<returns>(bool) True if the vector is zero, otherwise False.</returns>
    static member IsVectorZero(vector:Vector3d) : bool =
        vector.IsZero


    ///<summary>Adds a 3D point or a 3D vector to a 3D point.</summary>
    ///<param name="point1">(Point3d) Point1 of the points to add</param>
    ///<param name="point2">(Point3d) Point2 of the points to add</param>
    ///<returns>(Point3d) The resulting 3D point.</returns>
    static member PointAdd(point1:Point3d, point2:Point3d) : Point3d =
        point1 + point2


    ///<summary>Finds the point in a list of 3D points that is closest to a test point.</summary>
    ///<param name="points">(Point3d IList) List of points</param>
    ///<param name="testPoint">(Point3d) The point to compare against</param>
    ///<returns>(int) index of the element in the point list that is closest to the test point.</returns>
    static member PointArrayClosestPoint(points:Point3d IList, testPoint:Point3d) : int =
        let index = Rhino.Collections.Point3dList.ClosestIndexInList(points, testPoint)
        if index>=0 then index
        else RhinoScriptingException.Raise "RhinoScriptSyntax.PointArrayClosestPoint failed on %A, %A" points testPoint


    ///<summary>Transforms a list of 3D points.</summary>
    ///<param name="points">(Point3d seq) List of 3D points</param>
    ///<param name="xForm">(Transform) Transformation to apply</param>
    ///<returns>(Point3d ResizeArray) transformed points.</returns>
    static member PointArrayTransform(points:Point3d seq, xForm:Transform) : Point3d ResizeArray =
        resizeArray {
            for point in points do
                let p = Point3d(point) //copy first !
                p.Transform(xForm)
                p
            }

    ///<summary>Finds the object that is closest to a test point.</summary>
    ///<param name="point">(Point3d) Point to test</param>
    ///<param name="objectIds">(Guid seq) Identifiers of one or more objects</param>
    ///<returns>(Guid * Point3d * float) Tuple of 3 values
    ///      [0] Guid, closest  objectId
    ///      [1] the point on object
    ///      [2] the distance.</returns>
    static member PointClosestObject(point:Point3d, objectIds:Guid seq) : Guid * Point3d * float =
        let mutable closest = Unchecked.defaultof<Guid*Point3d*float>
        let mutable distance = Double.MaxValue
        for objectId in objectIds do
            let geom = RhinoScriptSyntax.CoerceGeometry(objectId)
            match geom with
            | :?  Point as pointgeometry ->
                distance <- point.DistanceTo( pointgeometry.Location )
                if distance < t3 closest then
                    closest  <-  objectId, pointgeometry.Location, distance

            | :?  TextDot as dot ->
                distance <- point.DistanceTo(dot.Point)
                if distance < t3 closest then
                    closest  <-  objectId, dot.Point, distance

            | :?  PointCloud as pointcloud ->
                let index = pointcloud.ClosestPoint(point)
                if index>=0 then
                    distance <- point.DistanceTo( pointcloud.[index].Location )
                    if distance < t3 closest then
                        closest  <-  objectId, pointcloud.[index].Location, distance

            | :?  Curve as curve ->
                let rc, t = curve.ClosestPoint(point)
                if rc then
                    distance <- point.DistanceTo( curve.PointAt(t))
                    if distance < t3 closest then
                        closest  <-  objectId, curve.PointAt(t), distance

            | :?  Surface as srf ->
                let ok, u, v = srf.ClosestPoint(point)
                if ok then
                    let srfclosest = srf.PointAt(u, v)
                    distance <- point.DistanceTo( srfclosest )
                    if distance < t3 closest then
                        closest  <-  objectId, srfclosest, distance

            | :?  Brep as brep ->
                let brepclosest = brep.ClosestPoint(point)
                distance <- point.DistanceTo( brepclosest )
                if distance < t3 closest then
                    closest  <-  objectId, brepclosest, distance

            | :?  Mesh as mesh ->
                let meshclosest = mesh.ClosestPoint(point)
                distance <- point.DistanceTo( meshclosest )
                if distance < t3 closest then
                    closest  <-  objectId, meshclosest, distance

            | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.PointClosestObject: non supported object type %A %A  Point, PointCloud, Curve, Brep or Mesh" (RhinoScriptSyntax.ObjectDescription(objectId)) objectId

        if t1 closest <> Guid.Empty then closest
        else RhinoScriptingException.Raise "RhinoScriptSyntax.PointClosestObject failed on %A and %A" point objectIds


    ///<summary>Compares two 3D points.</summary>
    ///<param name="point1">(Point3d) Point1 of the points to compare</param>
    ///<param name="point2">(Point3d) Point2 of the points to compare</param>
    ///<param name="tolerance">(float) Optional, default value: <c>RhinoMath.ZeroTolerance</c>
    ///    Tolerance to use for comparison.</param>
    ///<returns>(bool) True or False.</returns>
    static member PointCompare( point1:Point3d,
                                point2:Point3d,
                                [<OPT;DEF(0.0)>]tolerance:float) : bool =
        let tolerance = Util.ifZero2 RhinoMath.ZeroTolerance  tolerance
        let vector = point2-point1
        vector.IsTiny(tolerance)


    ///<summary>Divides a 3D point by a value.</summary>
    ///<param name="point">(Point3d) The point to divide</param>
    ///<param name="divide">(float) A non-zero value to divide</param>
    ///<returns>(Point3d) resulting point.</returns>
    static member PointDivide(point:Point3d, divide:float) : Point3d =
        if divide < RhinoMath.ZeroTolerance && divide > -RhinoMath.ZeroTolerance then
            RhinoScriptingException.Raise "RhinoScriptSyntax.PointDivide: Cannot divide by Zero or almost Zero %f" divide
        else
            point/divide


    ///<summary>Checks if a list of 3D points are coplanar.</summary>
    ///<param name="points">(Point3d seq) 3D points to test</param>
    ///<param name="tolerance">(float) Optional, default value: <c>1.0e-12</c> = RhinoMath.ZeroTolerance
    ///    Tolerance to use when verifying</param>
    ///<returns>(bool) True or False.</returns>
    static member PointsAreCoplanar(points:Point3d seq, [<OPT;DEF(0.0)>]tolerance:float) : bool =
        let tolerance = Util.ifZero1 tolerance RhinoMath.ZeroTolerance
        Point3d.ArePointsCoplanar(points, tolerance)


    ///<summary>Scales a 3D point by a value.</summary>
    ///<param name="point">(Point3d) The point to divide</param>
    ///<param name="scale">(float) Scale factor to apply</param>
    ///<returns>(Point3d) resulting point.</returns>
    static member PointScale(point:Point3d, scale:float) : Point3d =
        point*scale


    ///<summary>Subtracts a 3D point or a 3D vector from a 3D point.</summary>
    ///<param name="point1">(Point3d) Point1 of the points to subtract</param>
    ///<param name="point2">(Point3d) Point2 of the points to subtract</param>
    ///<returns>(Point3d) The resulting 3D point.</returns>
    static member PointSubtract(point1:Point3d, point2:Point3d) : Point3d =
        let v = point1-point2
        Point3d(v)


    ///<summary>Transforms a 3D point.</summary>
    ///<param name="point">(Point3d) The point to transform</param>
    ///<param name="xForm">(Transform) A valid 4x4 transformation matrix</param>
    ///<returns>(Point3d) transformed Point.</returns>
    static member PointTransform(point:Point3d, xForm:Transform) : Point3d =
        let p = Point3d(point) //copy first !
        p.Transform(xForm)
        p



    ///<summary>Projects one or more points onto one or more Meshes.</summary>
    ///<param name="points">(Point3d seq) One or more 3D points</param>
    ///<param name="meshIds">(Guid seq) Identifiers of one or more Meshes</param>
    ///<param name="direction">(Vector3d) Direction vector to project the points</param>
    ///<returns>(Point3d array) projected points.</returns>
    static member ProjectPointToMesh( points:Point3d seq,
                                      meshIds:Guid seq,
                                      direction:Vector3d) : Point3d array =
        let meshes =  resizeArray { for objectId in meshIds do yield RhinoScriptSyntax.CoerceMesh(objectId) }
        let tolerance = State.Doc.ModelAbsoluteTolerance
        Intersect.Intersection.ProjectPointsToMeshes(meshes, points, direction, tolerance)



    ///<summary>Projects one or more points onto one or more Surfaces or Polysurfaces.</summary>
    ///<param name="points">(Point3d seq) One or more 3D points</param>
    ///<param name="surfaceIds">(Guid seq) Identifiers of one or more Surfaces/polysurfaces</param>
    ///<param name="direction">(Vector3d) Direction vector to project the points</param>
    ///<returns>(Point3d array) projected points.</returns>
    static member ProjectPointToSurface( points:Point3d seq,
                                         surfaceIds:Guid seq,
                                         direction:Vector3d) : Point3d array =
        let breps =  resizeArray { for objectId in surfaceIds do yield RhinoScriptSyntax.CoerceBrep(objectId) }
        let tolerance = State.Doc.ModelAbsoluteTolerance
        Intersect.Intersection.ProjectPointsToBreps(breps, points, direction, tolerance)


    ///<summary>Pulls an array of points to a Surface or Mesh object. For more
    ///    information, see the Rhino help file Pull command.</summary>
    ///<param name="objectId">(Guid) The identifier of the Surface or Mesh object that pulls</param>
    ///<param name="points">(Point3d seq) List of 3D points</param>
    ///<returns>(Point3d array) 3D points pulled onto Surface or Mesh.</returns>
    static member PullPoints(objectId:Guid, points:Point3d seq) : Point3d array =
        match RhinoScriptSyntax.CoerceGeometry(objectId) with
        | :? Mesh as mesh->
            let points = mesh.PullPointsToMesh(points)
            points
        | :? Brep as brep->
            if brep.Faces.Count = 1 then
                let tolerance = State.Doc.ModelAbsoluteTolerance
                brep.Faces.[0].PullPointsToFace(points, tolerance)
            else
                RhinoScriptingException.Raise "RhinoScriptSyntax.PullPoints only works on surface and single sided breps not %d sided ones" brep.Faces.Count
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.PullPoints does not support %A" (RhinoScriptSyntax.ObjectDescription(objectId))


    ///<summary>Adds two 3D vectors.</summary>
    ///<param name="vector1">(Vector3d) Vector1 of the vectors to add</param>
    ///<param name="vector2">(Vector3d) Vector2 of the vectors to add</param>
    ///<returns>(Vector3d) The resulting 3D vector.</returns>
    static member VectorAdd(vector1:Vector3d, vector2:Vector3d) : Vector3d =
        vector1 + vector2


    ///<summary>Returns the angle, in degrees, between two 3-D vectors.</summary>
    ///<param name="vector1">(Vector3d) The first 3-D vector</param>
    ///<param name="vector2">(Vector3d) The second 3-D vector</param>
    ///<returns>(float) The angle in degrees.</returns>
    static member VectorAngle(vector1:Vector3d, vector2:Vector3d) : float =
        let vector1 = Vector3d(vector1.X, vector1.Y, vector1.Z)
        let vector2 = Vector3d(vector2.X, vector2.Y, vector2.Z)
        if not <| vector1.Unitize() || not <| vector2.Unitize() then
            RhinoScriptingException.Raise "RhinoScriptSyntax.VectorAngle: Unable to unitize vector.  vector1:'%A' vector2:'%A'" vector1 vector2
        let mutable dot = vector1 * vector2
        dot <- RhinoScriptSyntax.Clamp(-1.0 , 1.0 , dot)
        let radians = Math.Acos(dot)
        toDegrees(radians)


    ///<summary>Compares two 3D vectors.</summary>
    ///<param name="vector1">(Vector3d) Vector1 of the two vectors to compare</param>
    ///<param name="vector2">(Vector3d) Vector2 of the two vectors to compare</param>
    ///<returns>(int) result of comparing the vectors.
    ///    -1 if vector1 is less than vector2
    ///    0 if vector1 is equal to vector2
    ///    1 if vector1 is greater than vector2.</returns>
    static member VectorCompare(vector1:Vector3d, vector2:Vector3d) : int =
        vector1.CompareTo(vector2)


    ///<summary>Creates a vector from two 3D points.</summary>
    ///<param name="fromPoint">(Point3d) Start point of vector</param>
    ///<param name="toPoint">(Point3d) End point vector</param>
    ///<returns>(Vector3d) The resulting vector.</returns>
    static member VectorCreate( fromPoint:Point3d, toPoint:Point3d) : Vector3d =
        toPoint-fromPoint


    ///<summary>Calculates the cross product of two 3D vectors.</summary>
    ///<param name="vector1">(Vector3d) Vector1 of the vectors to perform cross product on</param>
    ///<param name="vector2">(Vector3d) Vector2 of the vectors to perform cross product on</param>
    ///<returns>(Vector3d) The resulting cross product direction.</returns>
    static member VectorCrossProduct(vector1:Vector3d, vector2:Vector3d) : Vector3d =
        Vector3d.CrossProduct( vector1, vector2 )


    ///<summary>Divides a 3D vector by a value.</summary>
    ///<param name="vector">(Vector3d) The vector to divide</param>
    ///<param name="divide">(float) A non-zero value to divide</param>
    ///<returns>(Vector3d) resulting vector.</returns>
    static member VectorDivide(vector:Vector3d, divide:float) : Vector3d =
        if divide < RhinoMath.ZeroTolerance && divide > -RhinoMath.ZeroTolerance then
            RhinoScriptingException.Raise "RhinoScriptSyntax.VectorDivide: Cannot divide by Zero or almost Zero %f" divide
        else
            vector/divide


    ///<summary>Calculates the dot product of two 3D vectors.</summary>
    ///<param name="vector1">(Vector3d) Vector1 of the vectors to perform the dot product on</param>
    ///<param name="vector2">(Vector3d) Vector2 of the vectors to perform the dot product on</param>
    ///<returns>(float) The resulting dot product.</returns>
    static member VectorDotProduct(vector1:Vector3d, vector2:Vector3d) : float =
        vector1*vector2


    ///<summary>Returns the length of a 3D vector.</summary>
    ///<param name="vector">(Vector3d) The 3-D vector</param>
    ///<returns>(float) The length of the vector.</returns>
    static member VectorLength(vector:Vector3d) : float =
        vector.Length


    ///<summary>Multiplies two 3D vectors, same as Dot Product.</summary>
    ///<param name="vector1">(Vector3d) Vector1 of the vectors to multiply</param>
    ///<param name="vector2">(Vector3d) Vector2 of the vectors to multiply</param>
    ///<returns>(float) The resulting inner (dot) product.</returns>
    static member VectorMultiply(vector1:Vector3d, vector2:Vector3d) : float =
        vector1* vector2


    ///<summary>Reverses the direction of a 3D vector.</summary>
    ///<param name="vector">(Vector3d) The vector to reverse</param>
    ///<returns>(Vector3d) reversed vector.</returns>
    static member VectorReverse(vector:Vector3d) : Vector3d =
        Vector3d(-vector.X, -vector.Y, -vector.Z)



    ///<summary>Rotates a 3D vector.</summary>
    ///<param name="vector">(Vector3d) The vector to rotate</param>
    ///<param name="angleDegrees">(float) Rotation angle</param>
    ///<param name="axis">(Vector3d) Axis of rotation</param>
    ///<returns>(Vector3d) rotated vector.</returns>
    static member VectorRotate( vector:Vector3d,
                                angleDegrees:float,
                                axis:Vector3d) : Vector3d =
        let angleradians = RhinoMath.ToRadians(angleDegrees)
        let rc = Vector3d(vector.X, vector.Y, vector.Z)
        if rc.Rotate(angleradians, axis) then rc
        else RhinoScriptingException.Raise "RhinoScriptSyntax.VectorRotate failed on %A, %A, %A" vector angleDegrees axis


    ///<summary>Scales a 3-D vector.</summary>
    ///<param name="vector">(Vector3d) The vector to scale</param>
    ///<param name="scale">(float) Scale factor to apply</param>
    ///<returns>(Vector3d) resulting vector.</returns>
    static member VectorScale(vector:Vector3d, scale:float) : Vector3d =
        vector*scale


    ///<summary>Subtracts two 3D vectors.</summary>
    ///<param name="vector1">(Vector3d) The vector to subtract from</param>
    ///<param name="vector2">(Vector3d) The vector to subtract</param>
    ///<returns>(Vector3d) The resulting 3D vector.</returns>
    static member VectorSubtract(vector1:Vector3d, vector2:Vector3d) : Vector3d =
        vector1-vector2


    ///<summary>Transforms a 3D vector.</summary>
    ///<param name="vector">(Vector3d) The vector to transform</param>
    ///<param name="xForm">(Transform) A valid 4x4 transformation matrix</param>
    ///<returns>(Vector3d) transformed vector.</returns>
    static member VectorTransform(vector:Vector3d, xForm:Transform) : Vector3d =
        let v = Vector3d(vector)
        v.Transform(xForm)
        v


    ///<summary>Unitizes, or normalizes a 3D vector. Note, zero vectors cannot be unitized.</summary>
    ///<param name="vector">(Vector3d) The vector to unitize</param>
    ///<returns>(Vector3d) unitized vector.</returns>
    static member inline VectorUnitize(vector:Vector3d) : Vector3d =
        let le = sqrt (vector.X * vector.X + vector.Y * vector.Y + vector.Z * vector.Z)
        if Double.IsInfinity le || le < RhinoMath.ZeroTolerance then RhinoScriptingException.Raise "RhinoScriptSyntax.VectorUnitize failed on zero length or very short Vector %s" vector.ToNiceString
        let f = 1. / le
        Vector3d(vector.X*f, vector.Y*f, vector.Z*f)


    ///<summary>Returns either a world axis-aligned or a construction Plane axis-aligned
    ///    bounding box of an array of 3-D point locations.</summary>
    ///<param name="points">(Point3d seq) A list of 3-D points</param>
    ///<param name="plane">(Plane) Optional, default value: <c>Plane.WorldXY</c>
    ///    Plane to which the bounding box should be aligned,
    ///    If omitted, a world axis-aligned bounding box
    ///    will be calculated</param>
    ///<returns>(Box) A Rhino.Geometry.Box.</returns>
    static member PointArrayBoundingBox( points:Point3d seq, [<OPT;DEF(Plane())>]plane:Plane) : Box = // TODO verify this works the same way as python !!
        if plane.IsValid then
            Box(plane, points)
        else
            Box(BoundingBox(points))



    //---End of header marker: don't change: {@$%^&*()*&^%$@}

    // moved to Rhino.RhinoScriptSyntax.Fsharp project:
    // static member ShownObjects(
    // static member GetObjectsAndRemember(
    // static member GetObjectAndRemember(

    ///<summary>Returns identifiers of all objects in the document.</summary>
    ///<param name="select">(bool) Optional, default value: <c>false</c> Select the objects</param>
    ///<param name="includeLights">(bool) Optional, default value: <c>false</c> Include light objects</param>
    ///<param name="includeGrips">(bool) Optional, default value: <c>false</c> Include grips objects</param>
    ///<param name="includeReferences">(bool) Optional, default value: <c>false</c> Include reference objects such as work session objects</param>
    ///<returns>(Guid ResizeArray) Identifiers for all the objects in the document.</returns>
    static member AllObjects(  [<OPT;DEF(false)>]select:bool,
                               [<OPT;DEF(false)>]includeLights:bool,
                               [<OPT;DEF(false)>]includeGrips:bool,
                               [<OPT;DEF(false)>]includeReferences:bool) : Guid ResizeArray =
            let it = DocObjects.ObjectEnumeratorSettings()
            it.IncludeLights <- includeLights
            it.IncludeGrips <- includeGrips
            it.NormalObjects <- true
            it.LockedObjects <- true
            it.HiddenObjects <- true
            it.ReferenceObjects <- includeReferences
            let es = State.Doc.Objects.GetObjectList(it)
            let objectIds = ResizeArray()
            for ob in es do
                objectIds.Add ob.Id
                if select then ob.Select(true) |> ignore   // TODO needs sync ? apparently not needed!
            if objectIds.Count > 0 && select then State.Doc.Views.Redraw()
            objectIds


    ///<summary>Returns identifier of the first object in the document. The first
    ///    object is the last object created by the user.</summary>
    ///<param name="select">(bool) Optional, default value: <c>false</c> Select the object. If omitted, the object is not selected</param>
    ///<param name="includeLights">(bool) Optional, default value: <c>false</c> Include light objects. If omitted, light objects are not returned</param>
    ///<param name="includeGrips">(bool) Optional, default value: <c>false</c> Include grips objects. If omitted, grips objects are not returned</param>
    ///<returns>(Guid) The identifier of the object.</returns>
    static member FirstObject(      [<OPT;DEF(false)>]select:bool,
                                    [<OPT;DEF(false)>]includeLights:bool,
                                    [<OPT;DEF(false)>]includeGrips:bool) : Guid =
            let it = DocObjects.ObjectEnumeratorSettings()
            it.IncludeLights <- includeLights
            it.IncludeGrips <- includeGrips
            let e = State.Doc.Objects.GetObjectList(it).GetEnumerator()
            if not <| e.MoveNext() then RhinoScriptingException.Raise "RhinoScriptSyntax.FirstObject not found"
            let object = e.Current
            if isNull object then RhinoScriptingException.Raise "RhinoScriptSyntax.FirstObject not found(null)"
            if select then object.Select(true) |> ignore // TODO needs sync ? apparently not needed!
            object.Id




    ///<summary>Prompts user to pick or select a single Curve object.</summary>
    ///<param name="message">(string) Optional, A prompt or message</param>
    ///<param name="preselect">(bool) Optional, default value: <c>true</c> Allow for the selection of pre-selected objects</param>
    ///<param name="select">(bool) Optional, default value: <c>false</c> Select the picked objects. If False, objects that are picked are not selected</param>
    ///<returns>(Guid * bool * int * Point3d * float * string) Tuple containing the following information
    ///    [0]  guid     identifier of the Curve object
    ///    [1]  bool     True if the Curve was preselected, otherwise False
    ///    [2]  Enum     DocObjects.SelectionMethod
    ///    [3]  point    selection point
    ///    [4]  number   the Curve parameter of the selection point
    ///    [5]  str      name of the view selection was made.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetCurveObject(   [<OPT;DEF(null:string)>]message:string,
                                    [<OPT;DEF(true)>]preselect:bool,
                                    [<OPT;DEF(false)>]select:bool) : Guid * bool * DocObjects.SelectionMethod * Point3d * float * string =
        let get () =  // TODO Add check if already hidden, then don't even hide and show
            if not <| preselect then
                State.Doc.Objects.UnselectAll() |> ignore
                State.Doc.Views.Redraw()
            let go = new Input.Custom.GetObject()
            if notNull message then go.SetCommandPrompt(message)
            go.GeometryFilter <- DocObjects.ObjectType.Curve
            go.SubObjectSelect <- false
            go.GroupSelect <- false
            go.AcceptNothing(true)
            let res = go.Get()
            if res <> Input.GetResult.Object then
                RhinoUserInteractionException.Raise "No Object was selected in RhinoScriptSyntax.GetCurveObject(message=%A), Interaction result: %A" message res
            else
                let objref = go.Object(0)
                let objectId = objref.ObjectId
                let presel = go.ObjectsWerePreselected
                let selmethod = objref.SelectionMethod()
                let point = objref.SelectionPoint()
                let _, curveparameter = objref.CurveParameter() // _ = curve
                let viewname = go.View().ActiveViewport.Name
                let obj = go.Object(0).Object()
                go.Dispose()
                if not <| select && not <| preselect then
                    State.Doc.Objects.UnselectAll()|> ignore
                    State.Doc.Views.Redraw()
                obj.Select(select)  |> ignore
                (objectId, presel, selmethod, point, curveparameter, viewname)
        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Prompts user to pick, or select, a single object.
    /// Raises a RhinoUserInteractionException if no object was selected. For example when Esc key was pressed.</summary>
    ///<param name="message">(string) Optional, A prompt or message</param>
    ///<param name="filter">(int) Optional, The type(s) of geometry (points, Curves, Surfaces, Meshes,...)
    ///    that can be selected. Object types can be added together to filter
    ///    several different kinds of geometry. use the RhinoScriptSyntax.Filter enum to get values, they can be joined with '+'</param>
    ///<param name="preselect">(bool) Optional, default value: <c>true</c>
    ///    Allow for the selection of pre-selected objects</param>
    ///<param name="select">(bool) Optional, default value: <c>false</c>
    ///    Select the picked objects. If False, the objects that are
    ///    picked are not selected</param>
    ///<param name="customFilter">(Input.Custom.GetObjectGeometryFilter) Optional, A custom filter function</param>
    ///<param name="subObjects">(bool) Optional, default value: <c>false</c>
    ///    If True, sub-objects can be selected. When this is the
    ///    case, for tracking  of the sub-object go via the Object Ref</param>
    ///<returns>(Guid) Identifier of the picked object.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetObject(        [<OPT;DEF(null:string)>]message:string,
                                    [<OPT;DEF(0)>]filter:int,
                                    [<OPT;DEF(true)>]preselect:bool,
                                    [<OPT;DEF(false)>]select:bool,
                                    [<OPT;DEF(null:Input.Custom.GetObjectGeometryFilter)>]customFilter:Input.Custom.GetObjectGeometryFilter,
                                    [<OPT;DEF(false)>]subObjects:bool) : Guid =
        let get () =
            if not  preselect then
                State.Doc.Objects.UnselectAll() |> ignore
                State.Doc.Views.Redraw()
            use go = new Input.Custom.GetObject()
            if notNull customFilter then go.SetCustomGeometryFilter(customFilter)
            if notNull message then go.SetCommandPrompt(message)
            if filter>0 then go.GeometryFilter <- ObjectFilterEnum.GetFilterEnum(filter)
            go.SubObjectSelect <- subObjects
            go.GroupSelect <- false
            go.AcceptNothing(true)
            let res = go.Get()
            if res <> Input.GetResult.Object then
                RhinoUserInteractionException.Raise "No Object was selected in RhinoScriptSyntax.GetObject(message=%A), Interaction result: %A" message res
            else
                let objref = go.Object(0)
                let obj = objref.Object()
                //let presel = go.ObjectsWerePreselected
                go.Dispose()
                //if not <| select && not <| preselect then State.Doc.Objects.UnselectAll() |> ignore  State.Doc.Views.Redraw()
                if select then
                    obj.Select(select)  |> ignore
                else
                    State.Doc.Objects.UnselectAll() |> ignore
                State.Doc.Views.Redraw()
                obj.Id
        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Prompts user to pick, or select a single object.
    /// Raises a RhinoUserInteractionException if no object was selected. For example when Esc key was pressed.</summary>
    ///<param name="message">(string) Optional, A prompt or message</param>
    ///<param name="filter">(int) Optional, default value: <c>0</c>
    ///    The type(s) of geometry (points, Curves, Surfaces, Meshes,...)
    ///    that can be selected. Object types can be added together to filter
    ///    several different kinds of geometry. use the filter class to get values</param>
    ///<param name="preselect">(bool) Optional, default value: <c>true</c>
    ///    Allow for the selection of pre-selected objects</param>
    ///<param name="select">(bool) Optional, default value: <c>false</c>
    ///    Select the picked objects. If False, the objects that are
    ///    picked are not selected</param>
    ///<param name="objects">(Guid seq) Optional, List of object identifiers specifying objects that are
    ///    allowed to be selected</param>
    ///<returns>(Guid * bool * float * Point3d * string) Tuple containing the following information
    ///    [0] identifier of the object
    ///    [1] True if the object was preselected, otherwise False
    ///    [2] selection method Enum DocObjects.SelectionMethod
    ///         (0) selected by non-mouse method (SelAll, etc.).
    ///         (1) selected by mouse click on the object.
    ///         (2) selected by being inside of a mouse window.
    ///         (3) selected by intersecting a mouse crossing window.
    ///    [3] selection point
    ///    [4] name of the view selection was made.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetObjectEx(      [<OPT;DEF(null:string)>]message:string,
                                    [<OPT;DEF(0)>]filter:int,
                                    [<OPT;DEF(true)>]preselect:bool,
                                    [<OPT;DEF(false)>]select:bool,
                                    [<OPT;DEF(null:Guid seq)>]objects:Guid seq) : Guid * bool * DocObjects.SelectionMethod * Point3d * string =
        let get () =
            if not <| preselect then
                State.Doc.Objects.UnselectAll() |> ignore
                State.Doc.Views.Redraw()
            use go = new Input.Custom.GetObject()
            if notNull objects then
                let s = System.Collections.Generic.HashSet(objects)
                go.SetCustomGeometryFilter(fun rhinoObject _ _ -> s.Contains(rhinoObject.Id))
            if notNull message then
                go.SetCommandPrompt(message)
            if filter>0 then
                go.GeometryFilter <- ObjectFilterEnum.GetFilterEnum(filter)
            go.SubObjectSelect <- false
            go.GroupSelect <- false
            go.AcceptNothing(true)
            let res = go.Get()
            if res <> Input.GetResult.Object then

                RhinoUserInteractionException.Raise "No Object was selected in RhinoScriptSyntax.GetObjectEx(message=%A), Interaction result: %A" message res
            else
                let objref = go.Object(0)
                let objectId = objref.ObjectId
                let presel = go.ObjectsWerePreselected
                let selmethod = objref.SelectionMethod()
                let point = objref.SelectionPoint()
                let viewname = go.View().ActiveViewport.Name
                let obj = go.Object(0).Object()
                go.Dispose()
                if not <| select && not <| presel then
                    State.Doc.Objects.UnselectAll() |> ignore
                    State.Doc.Views.Redraw()
                obj.Select(select) |> ignore
                (objectId, presel, selmethod, point, viewname)
        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Prompts user to pick or select one or more objects.
    /// Raises a RhinoUserInteractionException if no object was selected. For example when Esc key was pressed.</summary>
    ///<param name="message">(string) Optional, default value: <c>"Select objects"</c>
    ///    A prompt or message</param>
    ///<param name="filter">(int) Optional, The type(s) of geometry (points, Curves, Surfaces, Meshes,...)
    ///    that can be selected. Object types can be added together to filter
    ///    several different kinds of geometry. use the RhinoScriptSyntax.Filter enum to get values, they can be joined with '+'</param>
    ///<param name="group">(bool) Optional, default value: <c>true</c>
    ///    Honor object grouping. If omitted and the user picks a group,
    ///    the entire group will be picked (True). Note, if filter is set to a
    ///    value other than 0 (All objects), then group selection will be disabled</param>
    ///<param name="preselect">(bool) Optional, default value: <c>true</c>
    ///    Allow for the selection of pre-selected objects</param>
    ///<param name="select">(bool) Optional, default value: <c>false</c>
    ///    Select the picked objects. If False, the objects that are
    ///    picked are not selected</param>
    ///<param name="objectsToSelectFrom">(Guid seq) Optional, List of objects that are allowed to be selected. If set customFilter will be ignored</param>
    ///<param name="minimumCount">(int) Optional, default value: <c>1</c>
    ///    Minimum count of objects allowed to be selected</param>
    ///<param name="maximumCount">(int) Optional, default value: <c>0</c>
    ///    Maximum count of objects allowed to be selected</param>
    ///<param name="printCount">(bool) Optional, default value: <c>true</c> Print object count to command window.</param>
    ///<param name="customFilter">(Input.Custom.GetObjectGeometryFilter) Optional, Will be ignored if 'objects' are set. Calls a custom function in the script and passes
    ///    the Rhino Object, Geometry, and component index and returns true or false indicating if the object can be selected</param>
    ///<returns>(Guid ResizeArray) List of identifiers of the picked objects.
    ///A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetObjects(       [<OPT;DEF("Select objects")>]message:string,
                                    [<OPT;DEF(0)>]filter:int,
                                    [<OPT;DEF(true)>]group:bool,
                                    [<OPT;DEF(true)>]preselect:bool,
                                    [<OPT;DEF(false)>]select:bool,
                                    [<OPT;DEF(null:Guid seq)>]objectsToSelectFrom:Guid seq,
                                    [<OPT;DEF(1)>]minimumCount:int,
                                    [<OPT;DEF(0)>]maximumCount:int,
                                    [<OPT;DEF(true)>]printCount:bool,
                                    [<OPT;DEF(null:Input.Custom.GetObjectGeometryFilter)>]customFilter:Input.Custom.GetObjectGeometryFilter)  : ResizeArray<Guid> =
        let get () =
            if not <| preselect then
                State.Doc.Objects.UnselectAll() |> ignore
                State.Doc.Views.Redraw()
            use go = new Input.Custom.GetObject()
            if notNull objectsToSelectFrom then
                let s = System.Collections.Generic.HashSet(objectsToSelectFrom)
                go.SetCustomGeometryFilter(fun rhinoObject _ _ -> s.Contains(rhinoObject.Id))
            elif notNull customFilter then
                go.SetCustomGeometryFilter(customFilter)
            go.SetCommandPrompt(message )
            let geometryFilter = ObjectFilterEnum.GetFilterEnum(filter)
            if filter>0 then go.GeometryFilter <- geometryFilter
            go.SubObjectSelect <- false
            go.GroupSelect <- group
            go.AcceptNothing(true)
            let res = go.GetMultiple(minimumCount, maximumCount)
            if res <> Input.GetResult.Object then
                RhinoUserInteractionException.Raise "No Object was selected in RhinoScriptSyntax.GetObjects(message=%A), Interaction result: %A" message res
            else
                if not <| select && not <| go.ObjectsWerePreselected then
                    State.Doc.Objects.UnselectAll() |> ignore
                    State.Doc.Views.Redraw()
                let rc = ResizeArray()
                let count = go.ObjectCount
                for i = 0 to count - 1 do
                    let objref = go.Object(i)
                    rc.Add(objref.ObjectId)
                    let obj = objref.Object()
                    if select && notNull obj then obj.Select(select) |> ignore
                if printCount then InternalToNiceStringSetup.printfnBlue "RhinoScriptSyntax.GetObjects(...) returned %s" (RhinoScriptSyntax.ObjectDescription(rc))
                rc
        RhinoSync.DoSyncRedrawHideEditor get



    ///<summary>Prompts user to pick, or select one or more objects.
    /// Raises a RhinoUserInteractionException if no object was selected. For example when Esc key was pressed.</summary>
    ///<param name="message">(string) Optional, default value: <c>"Select objects"</c>
    ///    A prompt or message</param>
    ///<param name="filter">(int) Optional, default value: <c>0</c>
    ///    The type(s) of geometry (points, Curves, Surfaces, Meshes,...)
    ///    that can be selected. Object types can be added together to filter
    ///    several different kinds of geometry. use the filter class to get values</param>
    ///<param name="group">(bool) Optional, default value: <c>true</c>
    ///    Honor object grouping. If omitted and the user picks a group,
    ///    the entire group will be picked (True). Note, if filter is set to a
    ///    value other than 0 (All objects), then group selection will be disabled</param>
    ///<param name="preselect">(bool) Optional, default value: <c>true</c>
    ///    Allow for the selection of pre-selected objects</param>
    ///<param name="select">(bool) Optional, default value: <c>false</c>
    ///    Select the picked objects. If False, the objects that are
    ///    picked are not selected</param>
    ///<param name="printCount">(bool) Optional, default value: <c>true</c> Print object count to command window</param>
    ///<param name="objectsToSelectFrom">(Guid seq) Optional, List of object identifiers specifying objects that are
    ///    allowed to be selected</param>
    ///<returns>((Guid*bool*int*Point3d*string) ResizeArray) List containing the following information
    ///    [n][0]  identifier of the object
    ///    [n][1]  True if the object was preselected, otherwise False
    ///    [n][2]  selection method (DocObjects.SelectionMethod)
    ///    [n][3]  selection point
    ///    [n][4]  name of the view selection was made.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetObjectsEx(     [<OPT;DEF("Select objects")>]message:string,
                                    [<OPT;DEF(0)>]filter:int,
                                    [<OPT;DEF(true)>]group:bool,
                                    [<OPT;DEF(true)>]preselect:bool,
                                    [<OPT;DEF(false)>]select:bool,
                                    [<OPT;DEF(true)>]printCount:bool,
                                    [<OPT;DEF(null:Guid seq)>]objectsToSelectFrom:Guid seq) : (Guid*bool*DocObjects.SelectionMethod*Point3d*string) ResizeArray =
        let get () =
            if not <| preselect then
                State.Doc.Objects.UnselectAll() |> ignore
                State.Doc.Views.Redraw()
            use go = new Input.Custom.GetObject()
            if notNull objectsToSelectFrom then
                let s = System.Collections.Generic.HashSet(objectsToSelectFrom)
                go.SetCustomGeometryFilter(fun rhinoObject _ _ -> s.Contains(rhinoObject.Id))
            go.SetCommandPrompt(message)
            let geometryfilter = ObjectFilterEnum.GetFilterEnum(filter)
            if filter>0 then go.GeometryFilter <- geometryfilter
            go.SubObjectSelect <- false
            go.GroupSelect <- group
            go.AcceptNothing(true)
            let res = go.GetMultiple(1, 0)
            if res <> Input.GetResult.Object then
                RhinoUserInteractionException.Raise "No Object was selected in RhinoScriptSyntax.GetObjectsEx(message=%A), Interaction result: %A" message res
            else
                if not <| select && not <| go.ObjectsWerePreselected then
                    State.Doc.Objects.UnselectAll() |> ignore
                    State.Doc.Views.Redraw()
                let rc = ResizeArray()
                let count = go.ObjectCount
                for i = 0 to count - 1 do
                    let objref = go.Object(i)
                    let objectId = objref.ObjectId
                    let presel = go.ObjectsWerePreselected
                    let selmethod = objref.SelectionMethod()
                    let point = objref.SelectionPoint()
                    let viewname = go.View().ActiveViewport.Name
                    rc.Add( (objectId, presel, selmethod, point, viewname))
                    let obj = objref.Object()
                    if select && notNull obj then obj.Select(select) |> ignore
                if printCount then
                    rc
                    |> ResizeArray.map ( fun (id, _, _, _, _) -> id )
                    |> RhinoScriptSyntax.ObjectDescription
                    |> InternalToNiceStringSetup.printfnBlue "RhinoScriptSyntax.GetObjectsEx(...) returned %s"
                rc
        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Prompts the user to select one or more point objects.</summary>
    ///<param name="message">(string) Optional, default value: <c>"Select Point Objects"</c>
    ///    A prompt message</param>
    ///<param name="preselect">(bool) Optional, default value: <c>true</c>
    ///    Allow for the selection of pre-selected objects. If omitted, pre-selected objects are not accepted</param>
    ///<returns>(Point3d ResizeArray) List of 3d points.</returns>
    static member GetPointCoordinates(  [<OPT;DEF("Select Point Objects")>] message:string,
                                        [<OPT;DEF(false)>]                  preselect:bool) : Point3d ResizeArray =
        let ids =  RhinoScriptSyntax.GetObjects(message, RhinoScriptSyntax.Filter.Point, preselect = preselect)
        let rc = ResizeArray<Point3d>()
        for objectId in ids do
            let pt = RhinoScriptSyntax.Coerce3dPoint(objectId)
            rc.Add(pt)
        rc




    ///<summary>Prompts the user to select a single Surface.
    /// Raises a RhinoUserInteractionException if no object was selected. For example when Esc key was pressed.</summary>
    ///<param name="message">(string) Optional, default value: <c>"Select Surface"</c>
    ///    Prompt displayed</param>
    ///<param name="preselect">(bool) Optional, default value: <c>true</c>
    ///    Allow for preselected objects</param>
    ///<param name="select">(bool) Optional, default value: <c>false</c>
    ///    Select the picked object</param>
    ///<returns>((Guid * bool * DocObjects.SelectionMethod * Point3d * (float * float) * string))
    ///    [0]  identifier of the Surface
    ///    [1]  True if the Surface was preselected, otherwise False
    ///    [2]  selection method ( DocObjects.SelectionMethod )
    ///    [3]  selection point
    ///    [4]  u, v Surface parameter of the selection point
    ///    [5]  name of the view in which the selection was made.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetSurfaceObject( [<OPT;DEF("Select surface")>]message:string, // TODO add selection method return value.  see help
                                    [<OPT;DEF(true)>]preselect:bool,
                                    [<OPT;DEF(false)>]select:bool) : Guid * bool * DocObjects.SelectionMethod * Point3d * (float * float) * string =
        let get () =
            if not <| preselect then
                State.Doc.Objects.UnselectAll() |> ignore
                State.Doc.Views.Redraw()
            use go = new Input.Custom.GetObject()
            go.SetCommandPrompt(message)
            go.GeometryFilter <- DocObjects.ObjectType.Surface
            go.SubObjectSelect <- false
            go.GroupSelect <- false
            go.AcceptNothing(true)
            let res = go.Get()
            if res <> Input.GetResult.Object then
                RhinoUserInteractionException.Raise "No Object was selected in RhinoScriptSyntax.GetSurfaceObject(message=%A), Interaction result: %A" message res
            else
                let objref = go.Object(0)
                let rhobj = objref.Object()
                rhobj.Select(select) |> ignore
                State.Doc.Views.Redraw()
                let objectId = rhobj.Id
                let prePicked = go.ObjectsWerePreselected
                let selmethod = objref.SelectionMethod()
                let mutable point = objref.SelectionPoint()
                let _, u, v = objref.SurfaceParameter()
                let mutable uv = (u, v)
                if not <| point.IsValid then
                    point <- Point3d.Unset
                    uv <- RhinoMath.UnsetValue, RhinoMath.UnsetValue
                let view = go.View()
                let name = view.ActiveViewport.Name
                go.Dispose()
                if not <| select && not <| prePicked then
                    State.Doc.Objects.UnselectAll() |> ignore
                    State.Doc.Views.Redraw()
                (objectId, prePicked, selmethod, point, uv, name)
        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Returns identifiers of all locked objects in the document. Locked objects
    ///    cannot be snapped to, and cannot be selected.</summary>
    ///<param name="includeLights">(bool) Optional, default value: <c>false</c>
    ///    Include light objects</param>
    ///<param name="includeGrips">(bool) Optional, default value: <c>false</c>
    ///    Include grip objects</param>
    ///<param name="includeReferences">(bool) Optional, default value: <c>false</c>
    ///    Include reference objects such as work session objects</param>
    ///<returns>(Guid ResizeArray) identifiers the locked objects.</returns>
    static member LockedObjects(    [<OPT;DEF(false)>]includeLights:bool,
                                    [<OPT;DEF(false)>]includeGrips:bool,
                                    [<OPT;DEF(false)>]includeReferences:bool) : Guid ResizeArray =
            let settings = DocObjects.ObjectEnumeratorSettings()
            settings.ActiveObjects <- true
            settings.NormalObjects <- true
            settings.LockedObjects <- true
            settings.HiddenObjects <- true
            settings.IncludeLights <- includeLights
            settings.IncludeGrips <- includeGrips
            settings.ReferenceObjects <- includeReferences
            resizeArray {
                for i in State.Doc.Objects.GetObjectList(settings) do
                    if i.IsLocked || (State.Doc.Layers.[i.Attributes.LayerIndex]).IsLocked then
                        yield i.Id }



    ///<summary>Returns identifiers of all hidden objects in the document. Hidden objects
    ///    are not visible, cannot be snapped to, and cannot be selected.</summary>
    ///<param name="includeLights">(bool) Optional, default value: <c>false</c>
    ///    Include light objects</param>
    ///<param name="includeGrips">(bool) Optional, default value: <c>false</c>
    ///    Include grip objects</param>
    ///<param name="includeReferences">(bool) Optional, default value: <c>false</c>
    ///    Include reference objects such as work session objects</param>
    ///<returns>(Guid ResizeArray) identifiers of the hidden objects.</returns>
    static member HiddenObjects(    [<OPT;DEF(false)>]includeLights:bool,
                                    [<OPT;DEF(false)>]includeGrips:bool,
                                    [<OPT;DEF(false)>]includeReferences:bool) : Guid ResizeArray =
        let settings = DocObjects.ObjectEnumeratorSettings()
        settings.ActiveObjects <- true
        settings.NormalObjects <- true
        settings.LockedObjects <- true
        settings.HiddenObjects <- true
        settings.IncludeLights <- includeLights
        settings.IncludeGrips <- includeGrips
        settings.ReferenceObjects <- includeReferences
        resizeArray {for i in State.Doc.Objects.GetObjectList(settings) do
                        if i.IsHidden || not <| (State.Doc.Layers.[i.Attributes.LayerIndex]).IsVisible then
                            i.Id }


    ///<summary>Inverts the current object selection. The identifiers of the newly
    ///    selected objects are returned.</summary>
    ///<param name="includeLights">(bool) Optional, default value: <c>false</c>
    ///    Include light objects. If omitted, light objects are not returned</param>
    ///<param name="includeGrips">(bool) Optional, default value: <c>false</c>
    ///    Include grips objects. If omitted, grips objects are not returned</param>
    ///<param name="includeReferences">(bool) Optional, default value: <c>false</c>
    ///    Include reference objects such as work session objects</param>
    ///<returns>(Guid ResizeArray) identifiers of the newly selected objects.</returns>
    static member InvertSelectedObjects([<OPT;DEF(false)>]includeLights:bool,
                                        [<OPT;DEF(false)>]includeGrips:bool,
                                        [<OPT;DEF(false)>]includeReferences:bool) : Guid ResizeArray =
        let settings = DocObjects.ObjectEnumeratorSettings()
        settings.IncludeLights <- includeLights
        settings.IncludeGrips <- includeGrips
        settings.IncludePhantoms <- true
        settings.ReferenceObjects <- includeReferences
        let rhobjs = State.Doc.Objects.GetObjectList(settings)
        let rc = ResizeArray()
        for obj in rhobjs do
            if obj.IsSelected(false) <> 0 && obj.IsSelectable() then
                rc.Add(obj.Id)
                obj.Select(true) |> ignore // TODO needs sync ? apparently not needed!
            else
                obj.Select(false) |> ignore
        State.Doc.Views.Redraw()
        rc


    ///<summary>Returns identifiers of the objects that were most recently created or changed
    ///    by scripting a Rhino command using the Command function. It is important to
    ///    call this function immediately after calling the Command function as only the
    ///    most recently created or changed object identifiers will be returned.</summary>
    ///<param name="select">(bool) Optional, default value: <c>false</c>
    ///    Select the object. If omitted, the object is not selected</param>
    ///<returns>(Guid ResizeArray) identifiers of the most recently created or changed objects.</returns>
    static member LastCreatedObjects([<OPT;DEF(false)>]select:bool) : Guid ResizeArray =
        match State.CommandSerialNumbers with
        |None -> ResizeArray()
        |Some (serialnum, ende) ->
            let mutable serialnumber = serialnum
            let rc = ResizeArray()
            while serialnumber < ende do
                let obj = State.Doc.Objects.Find(serialnumber)
                if notNull obj && not <| obj.IsDeleted then
                    rc.Add(obj.Id)
                if select then obj.Select(true) |> ignore // TODO needs sync ? apparently not needed!
                serialnumber <- serialnumber + 1u
                if select && rc.Count > 1 then State.Doc.Views.Redraw()
            rc


    ///<summary>Returns the identifier of the last object in the document. The last object
    ///    in the document is the first object created by the user.</summary>
    ///<param name="select">(bool) Optional, default value: <c>false</c>
    ///    Select the object</param>
    ///<param name="includeLights">(bool) Optional, default value: <c>false</c>
    ///    Include lights in the potential set</param>
    ///<param name="includeGrips">(bool) Optional, default value: <c>false</c>
    ///    Include grips in the potential set</param>
    ///<returns>(Guid) identifier of the object.</returns>
    static member LastObject( [<OPT;DEF(false)>]select:bool,
                              [<OPT;DEF(false)>]includeLights:bool,
                              [<OPT;DEF(false)>]includeGrips:bool) : Guid =
        let settings = DocObjects.ObjectEnumeratorSettings()
        settings.IncludeLights <- includeLights
        settings.IncludeGrips <- includeGrips
        settings.DeletedObjects <- false
        let rhobjs = State.Doc.Objects.GetObjectList(settings)
        if isNull rhobjs || Seq.isEmpty rhobjs then
            RhinoScriptingException.Raise "RhinoScriptSyntax.LastObject failed.  select:'%A' includeLights:'%A' includeGrips:'%A'" select includeLights includeGrips
        let firstobj = Seq.last rhobjs
        if isNull firstobj then
            RhinoScriptingException.Raise "RhinoScriptSyntax.LastObject failed.  select:'%A' includeLights:'%A' includeGrips:'%A'" select includeLights includeGrips
        if select then
            firstobj.Select(true) |> ignore // TODO needs sync ? apparently not needed!
            State.Doc.Views.Redraw()
        firstobj.Id


    ///<summary>Returns the identifier of the next object in the document.</summary>
    ///<param name="objectId">(Guid) The identifier of the object from which to get the next object</param>
    ///<param name="select">(bool) Optional, default value: <c>false</c>
    ///    Select the object</param>
    ///<param name="includeLights">(bool) Optional, default value: <c>false</c>
    ///    Include lights in the potential set</param>
    ///<param name="includeGrips">(bool) Optional, default value: <c>false</c>
    ///    Include grips in the potential set</param>
    ///<returns>(Guid) identifier of the object.</returns>
    static member NextObject( objectId:Guid,
                              [<OPT;DEF(false)>]select:bool,
                              [<OPT;DEF(false)>]includeLights:bool,
                              [<OPT;DEF(false)>]includeGrips:bool) : Guid =
        let settings = DocObjects.ObjectEnumeratorSettings()
        settings.IncludeLights <- includeLights
        settings.IncludeGrips <- includeGrips
        settings.DeletedObjects <- false
        State.Doc.Objects.GetObjectList(settings)
        |> Seq.skipWhile (fun obj -> obj.Id <> objectId)
        |> Seq.skip 1
        |> Seq.tryHead
        |> Option.defaultWith ( fun () -> RhinoScriptingException.Raise "RhinoScriptSyntax.NextObject not found for %A" (Nice.str objectId))
        |> fun obj ->
            if select then
                obj.Select(true) |> ignore // TODO needs sync ? apparently not needed!
                State.Doc.Views.Redraw()
            obj.Id



    ///<summary>Returns identifiers of all normal objects in the document. Normal objects
    ///    are visible, can be snapped to, and are independent of selection state.</summary>
    ///<param name="includeLights">(bool) Optional, default value: <c>false</c>
    ///    Include light objects. If omitted, light objects are not returned</param>
    ///<param name="includeGrips">(bool) Optional, default value: <c>false</c>
    ///    Include grips objects. If omitted, grips objects are not returned</param>
    ///<returns>(Guid ResizeArray) identifier of normal objects.</returns>
    static member NormalObjects([<OPT;DEF(false)>]includeLights:bool, [<OPT;DEF(false)>]includeGrips:bool) : Guid ResizeArray =
        let iter = DocObjects.ObjectEnumeratorSettings()
        iter.NormalObjects <- true
        iter.LockedObjects <- false
        iter.IncludeLights <- includeLights
        iter.IncludeGrips <- includeGrips
        resizeArray {for obj in State.Doc.Objects.GetObjectList(iter) do yield obj.Id }


    ///<summary>Returns identifiers of all objects based on color.</summary>
    ///<param name="color">(Drawing.Color) Color to get objects by</param>
    ///<param name="select">(bool) Optional, default value: <c>false</c>
    ///    Select the objects</param>
    ///<param name="includeLights">(bool) Optional, default value: <c>false</c>
    ///    Include lights in the set</param>
    ///<returns>(Guid ResizeArray) identifiers of objects of the selected color.</returns>
    static member ObjectsByColor( color:Drawing.Color,
                                  [<OPT;DEF(false)>]select:bool,
                                  [<OPT;DEF(false)>]includeLights:bool) : Guid ResizeArray =
        let rhinoobjects = State.Doc.Objects.FindByDrawColor(color, includeLights)
        if select then
            for obj in rhinoobjects do obj.Select(true)|> ignore // TODO needs sync ? apparently not needed!
            State.Doc.Views.Redraw()
        resizeArray {for obj in rhinoobjects do yield obj.Id }


    ///<summary>Returns identifiers of all objects based on the objects' group name.</summary>
    ///<param name="groupName">(string) Name of the group</param>
    ///<param name="select">(bool) Optional, default value: <c>false</c>
    ///    Select the objects</param>
    ///<returns>(Guid ResizeArray) identifiers for objects in the group.</returns>
    static member ObjectsByGroup(groupName:string, [<OPT;DEF(false)>]select:bool) : Guid ResizeArray =
        let groupinstance = State.Doc.Groups.FindName(groupName)
        if isNull groupinstance then
            RhinoScriptingException.Raise "RhinoScriptSyntax.ObjectsByGroup: '%s' does not exist in GroupTable" groupName
        let rhinoobjects = State.Doc.Groups.GroupMembers(groupinstance.Index)
        if isNull rhinoobjects then
            ResizeArray()
        else
            if select then
                for obj in rhinoobjects do obj.Select(true) |> ignore // TODO needs sync ? apparently not needed!
                State.Doc.Views.Redraw()
            resizeArray { for obj in rhinoobjects do yield obj.Id }


    ///<summary>Returns identifiers of all objects based on the objects' layer name.</summary>
    ///<param name="layerName">(string) Name of the layer</param>
    ///<param name="select">(bool) Optional, default value: <c>false</c>
    ///    Select the objects</param>
    ///<returns>(Guid ResizeArray) identifiers for objects in the specified layer.</returns>
    static member ObjectsByLayer(layerName:string, [<OPT;DEF(false)>]select:bool) : Guid ResizeArray =
        let layer = RhinoScriptSyntax.CoerceLayer(layerName)
        let rhinoobjects = State.Doc.Objects.FindByLayer(layer)
        if isNull rhinoobjects then ResizeArray()
        else
            if select then
                for rhobj in rhinoobjects do rhobj.Select(true) |> ignore // TODO needs sync ? apparently not needed!
                State.Doc.Views.Redraw()
            resizeArray {for obj in rhinoobjects do yield obj.Id }



    ///<summary>Returns identifiers of all objects based on user-assigned name.</summary>
    ///<param name="name">(string) Name of the object or objects</param>
    ///<param name="select">(bool) Optional, default value: <c>false</c>
    ///    Select the objects</param>
    ///<param name="includeLights">(bool) Optional, default value: <c>false</c>
    ///    Include light objects</param>
    ///<param name="includeReferences">(bool) Optional, default value: <c>false</c>
    ///    Include reference objects such as work session objects</param>
    ///<returns>(Guid ResizeArray) identifiers for objects with the specified name.</returns>
    static member ObjectsByName( name:string,
                                 [<OPT;DEF(false)>]select:bool,
                                 [<OPT;DEF(false)>]includeLights:bool,
                                 [<OPT;DEF(false)>]includeReferences:bool) : Guid ResizeArray =
        let settings = DocObjects.ObjectEnumeratorSettings()
        settings.HiddenObjects <- true
        settings.DeletedObjects <- false
        settings.IncludeGrips <- false
        settings.IncludePhantoms <- true
        settings.IncludeLights <- includeLights
        settings.NameFilter <- name
        settings.ReferenceObjects <- includeReferences
        let objects = State.Doc.Objects.GetObjectList(settings)
        let ids = resizeArray { for rhobj in objects do yield rhobj.Id }
        if ids.Count>0 && select then
            for rhobj in objects do rhobj.Select(true) |> ignore // TODO needs sync ? apparently not needed!
            State.Doc.Views.Redraw()
        ids

    ///<summary>Returns identifiers of all objects based on the objects' geometry type.</summary>
    ///<param name="geometryType">(int) The type(s) of geometry objects (points, Curves, Surfaces,
    ///    Meshes, etc.) that can be selected. Object types can be
    ///    added together as bit-coded flags to filter several different kinds of geometry.
    ///      Value        Description
    ///        0           All objects
    ///        1           Point
    ///        2           Point cloud
    ///        4           Curve
    ///        8           Surface or single-face brep
    ///        16          Polysurface or multiple-face
    ///        32          Mesh
    ///        256         Light
    ///        512         Annotation
    ///        4096        Instance or block reference
    ///        8192        Text dot object
    ///        16384       Grip object
    ///        32768       Detail
    ///        65536       Hatch
    ///        131072      Morph control
    ///        262144      SubD
    ///        134217728   Cage
    ///        268435456   Phantom
    ///        536870912   Clipping Plane
    ///        1073741824  Extrusion</param>
    ///<param name="select">(bool) Optional, default value: <c>false</c>
    ///    Select the objects</param>
    ///<param name="state">(int) Optional, default value: <c>0</c>
    ///    The object state (normal, locked, and hidden). Object states can be
    ///    added together to filter several different states of geometry.
    ///      Value     Description
    ///      0         All objects
    ///      1         Normal objects
    ///      2         Locked objects
    ///      4         Hidden objects</param>
    ///<returns>(Guid ResizeArray) identifiers of object that fit the specified type(s).</returns>
    static member ObjectsByType( geometryType:int,
                                 [<OPT;DEF(false)>]select:bool,
                                 [<OPT;DEF(0)>]state:int) : Guid ResizeArray =
        let mutable state = state
        if state = 0 then state <- 7
        let mutable bSurface = false
        let mutable bPolySurface = false
        let mutable bLights = false
        let mutable bGrips = false
        let mutable bPhantoms = false
        let mutable geometryfilter = ObjectFilterEnum.GetFilterEnum(geometryType)
        if geometryType = 0 then geometryfilter <- DocObjects.ObjectType.AnyObject
        if DocObjects.ObjectType.None <>(geometryfilter &&& DocObjects.ObjectType.Surface) then bSurface <- true // TODO verify this works OK !
        if DocObjects.ObjectType.None <>(geometryfilter &&& DocObjects.ObjectType.Brep ) then bPolySurface <- true
        if DocObjects.ObjectType.None <>(geometryfilter &&& DocObjects.ObjectType.Light ) then bLights <- true
        if DocObjects.ObjectType.None <>(geometryfilter &&& DocObjects.ObjectType.Grip ) then bGrips <- true
        if DocObjects.ObjectType.None <>(geometryfilter &&& DocObjects.ObjectType.Phantom ) then bPhantoms <- true
        let it = DocObjects.ObjectEnumeratorSettings()
        it.DeletedObjects <- false
        it.ActiveObjects <- true
        it.ReferenceObjects <- true
        it.IncludeLights <- bLights
        it.IncludeGrips <- bGrips
        it.IncludePhantoms <- bPhantoms
        if 0 <> state then
            it.NormalObjects <- false
            it.LockedObjects <- false
        if (state &&& 1) <> 0 then it.NormalObjects <- true
        if (state &&& 2) <> 0 then it.LockedObjects <- true
        if (state &&& 4) <> 0 then it.HiddenObjects <- true
        let objectIds = ResizeArray()
        let e = State.Doc.Objects.GetObjectList(it)
        for object in e do
            let  mutable bFound = false
            let objecttyp = object.ObjectType
            if objecttyp = DocObjects.ObjectType.Brep && (bSurface || bPolySurface) then
                let brep = RhinoScriptSyntax.CoerceBrep(object.Id)
                if notNull brep then
                    if brep.Faces.Count = 1 then
                        if bSurface then bFound <- true
                    else
                        if bPolySurface then bFound <- true
            elif objecttyp = DocObjects.ObjectType.Extrusion && (bSurface || bPolySurface) then
                let extrusion = object.Geometry :?> Extrusion
                let profilecount = extrusion.ProfileCount
                let capcount = extrusion.CapCount
                if profilecount = 1 && capcount = 0 && bSurface then
                    bFound <- true
                elif profilecount>0 && capcount>0 && bPolySurface then
                    bFound <- true
            elif objecttyp &&& geometryfilter <> DocObjects.ObjectType.None then
                bFound <- true
            if bFound then
                if select then object.Select(true) |> ignore // TODO needs sync ? apparently not needed!
                objectIds.Add(object.Id)
        if objectIds.Count > 0 && select then State.Doc.Views.Redraw()
        objectIds


    ///<summary>Returns the identifiers of all objects that are currently selected.</summary>
    ///<param name="includeLights">(bool) Optional, default value: <c>false</c>
    ///    Include light objects</param>
    ///<param name="includeGrips">(bool) Optional, default value: <c>false</c>
    ///    Include grip objects</param>
    ///<returns>(Guid ResizeArray) identifiers of selected objects.</returns>
    static member SelectedObjects([<OPT;DEF(false)>]includeLights:bool, [<OPT;DEF(false)>]includeGrips:bool) : Guid ResizeArray =
        let selobjects = State.Doc.Objects.GetSelectedObjects(includeLights, includeGrips)
        resizeArray {for obj in selobjects do obj.Id }


    ///<summary>Unselects all objects in the document.</summary>
    ///<returns>(int) The number of objects that were unselected.</returns>
    static member UnselectAllObjects() : int =
        let rc = State.Doc.Objects.UnselectAll()
        if rc>0 then State.Doc.Views.Redraw()
        rc


    ///<summary>Return identifiers of all objects that are visible in a specified view.
    /// This function is the same as rs.VisibleObjects in Rhino Python.
    /// use rs.ShownObjects to get all objects that are not hidden or on turned-off layers. .</summary>
    ///<param name="view">(string) Optional, The view to use. If omitted, the current active view is used</param>
    ///<param name="select">(bool) Optional, default value: <c>false</c>
    ///    Select the objects</param>
    ///<param name="includeLights">(bool) Optional, default value: <c>false</c>
    ///    Include light objects</param>
    ///<param name="includeGrips">(bool) Optional, default value: <c>false</c>
    ///    Include grip objects</param>
    ///<returns>(Guid ResizeArray) identifiers of the visible objects.</returns>
    static member VisibleObjectsInView(   [<OPT;DEF(null:string)>]view:string,
                                          [<OPT;DEF(false)>]select:bool,
                                          [<OPT;DEF(false)>]includeLights:bool,
                                          [<OPT;DEF(false)>]includeGrips:bool) : Guid ResizeArray =
        let get () =
            let it = DocObjects.ObjectEnumeratorSettings()
            it.DeletedObjects <- false
            it.ActiveObjects <- true
            it.ReferenceObjects <- true
            it.IncludeLights <- includeLights
            it.IncludeGrips <- includeGrips
            it.VisibleFilter <- true
            let viewport = if notNull view then (RhinoScriptSyntax.CoerceView(view)).MainViewport else State.Doc.Views.ActiveView.MainViewport
            it.ViewportFilter <- viewport
            let objectIds = ResizeArray()
            let e = State.Doc.Objects.GetObjectList(it)
            for object in e do
                let bbox = object.Geometry.GetBoundingBox(true)
                if viewport.IsVisible(bbox) then
                    if select then object.Select(true) |> ignore
                    objectIds.Add(object.Id)
            if objectIds.Count>0 && select then State.Doc.Views.Redraw()
            objectIds
        RhinoSync.DoSync get


    ///<summary>Picks objects using either a window or crossing selection.</summary>
    ///<param name="corner1">(Point3d) Corner1 of selection window</param>
    ///<param name="corner2">(Point3d) Corner2 of selection window</param>
    ///<param name="view">(string) Optional, View to perform the selection in</param>
    ///<param name="select">(bool) Optional, default value: <c>false</c>
    ///    Select picked objects</param>
    ///<param name="inWindow">(bool) Optional, default value: <c>true</c>
    ///    If False, then a crossing window selection is performed</param>
    ///<returns>(Guid ResizeArray) identifiers of selected objects.</returns>
    static member WindowPick( corner1:Point3d,
                              corner2:Point3d,
                              [<OPT;DEF(null:string)>]view:string,
                              [<OPT;DEF(false)>]select:bool,
                              [<OPT;DEF(true)>]inWindow:bool) : Guid ResizeArray =

        let pick () =
            let view = if notNull view then RhinoScriptSyntax.CoerceView(view) else State.Doc.Views.ActiveView
            let viewport = view.MainViewport
            let screen1 = Point2d(corner1)
            let screen2 = Point2d(corner2)
            let xf = viewport.GetTransform(DocObjects.CoordinateSystem.World, DocObjects.CoordinateSystem.Screen)
            screen1.Transform(xf)
            screen2.Transform(xf)


            let objects =
                // updated from https://github.com/mcneel/rhinoscriptsyntax/pull/185
                let pc = new Input.Custom.PickContext()
                pc.View <- view
                pc.PickStyle <- if inWindow then Input.Custom.PickStyle.WindowPick else Input.Custom.PickStyle.CrossingPick
                pc.PickGroupsEnabled <- if inWindow then true else false
                let _, frustumLine = viewport.GetFrustumLine((screen1.X + screen2.X) / 2.0, (screen1.Y + screen2.Y) / 2.0)
                pc.PickLine <- frustumLine

                let leftX = min screen1.X  screen2.X   |> round |> int
                let topY =  min screen1.Y screen2.Y    |> round |> int
                let w    =  abs(screen1.X - screen2.X) |> round |> int
                let h    =  abs(screen1.Y - screen2.Y) |> round |> int
                let rect = Drawing.Rectangle(leftX, topY, w, h)

                pc.SetPickTransform(viewport.GetPickTransform(rect))
                pc.UpdateClippingPlanes()

                State.Doc.Objects.PickObjects(pc)

            let rc = ResizeArray()
            if notNull objects then
                let rc = ResizeArray()
                for rhobjr in objects do
                    let rhobj = rhobjr.Object()
                    rc.Add(rhobj.Id)
                    if select then rhobj.Select(true) |> ignore
                if select then State.Doc.Views.Redraw()
            rc
        RhinoSync.DoSyncRedrawHideEditor pick



    //---End of header marker: don't change: {@$%^&*()*&^%$@}


    ///<summary>Adds a box shaped Polysurface to the document.</summary>
    ///<param name="corners">(Point3d seq) 8 points that define the corners of the box. Points need to
    ///    be in counter-clockwise order starting with the bottom rectangle of the box</param>
    ///<returns>(Guid) identifier of the new object.</returns>
    static member AddBox(corners:Point3d seq) : Guid =
        let brep = Brep.CreateFromBox(corners)
        if isNull brep then RhinoScriptingException.Raise "RhinoScriptSyntax.AddBox: Unable to create brep from box.  %d corners:'%A'" (Seq.length corners) corners
        let rc = State.Doc.Objects.AddBrep(brep)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddBox: Unable to add brep to document. corners:'%A'" corners
        State.Doc.Views.Redraw()
        rc

    ///<summary>Adds a cone shaped Polysurface to the document.
    /// The cone will have it's tip at the origin of the given plane. And grow along its Z axis.
    /// So it will be an upside down cone on world XY plane</summary>
    ///<param name="basis">(Plane) The plane at the tip of the cone. From this tip the cone wil expand along the Z axis. </param>
    ///<param name="height">(float) The height of cone. </param>
    ///<param name="radius">(float) The radius at the basis of the cone.</param>
    ///<param name="cap">(bool) Optional, default value: <c>true</c>. Add capping surface at basis of the cone?</param>
    ///<returns>(Guid) identifier of the new object.</returns>
    static member AddCone( basis:Plane,
                           height:float,
                           radius:float,
                           [<OPT;DEF(true)>]cap:bool) : Guid =
        let cone = Cone(basis, height, radius)
        let brep = Brep.CreateFromCone(cone, cap)// cone is upside down
        let rc = State.Doc.Objects.AddBrep(brep)
        State.Doc.Views.Redraw()
        rc

    ///<summary>Adds a cone shaped Polysurface to the document.
    /// The cone will have it's base center at the first point and the tip at the second point</summary>
    ///<param name="baseCenter">(Point3d) The point in the center of the base.</param>
    ///<param name="tip">(Point3d) The tip of cone. </param>
    ///<param name="radius">(float) The radius at the basis of the cone.</param>
    ///<param name="cap">(bool) Optional, default value: <c>true</c>. Add capping surface at basis of the cone?</param>
    ///<returns>(Guid) identifier of the new object.</returns>
    static member AddCone( baseCenter:Point3d,
                           tip:Point3d,
                           radius:float,
                           [<OPT;DEF(true)>]cap:bool) : Guid =
        let n = baseCenter-tip
        let pl = RhinoScriptSyntax.PlaneFromNormal(tip,n)
        let cone = Cone(pl, n.Length, radius)
        let brep = Brep.CreateFromCone(cone, cap)// cone is upside down
        let rc = State.Doc.Objects.AddBrep(brep)
        State.Doc.Views.Redraw()
        rc



    ///<summary>Adds a planar Surface through objects at a designated location. For more
    ///    information, see the Rhino help file for the CutPlane command.</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of objects that the cutting Plane will
    ///    pass through</param>
    ///<param name="startPoint">(Point3d) Start point of line that defines the cutting Plane</param>
    ///<param name="endPoint">(Point3d) End point of line that defines the cutting Plane</param>
    ///<param name="normal">(Vector3d) Optional, default value: <c>world Z axis</c>
    ///    Vector that will be contained in the returned planar Surface.
    ///    If omitted, the world Z axis is used (NOT the normal to, or Z axis of, the active view's construction plane as in rhinopython).</param>
    ///<returns>(Guid) identifier of new object.</returns>
    static member AddCutPlane( objectIds:Guid seq,
                               startPoint:Point3d,
                               endPoint:Point3d,
                               [<OPT;DEF(Vector3d())>]normal:Vector3d) : Guid =
        // from commit in v8.x : https://github.com/mcneel/rhinoscriptsyntax/commit/85e122790647a932e50d743a37af5efe9cfda955
        let bbox =
            let objs = objectIds|> Seq.map RhinoScriptSyntax.CoerceRhinoObject
            let  _,bbox0 = DocObjects.RhinoObject.GetTightBoundingBox(objs) //not available on Rhino 6 !!
            if not bbox0.IsValid then
                RhinoScriptingException.Raise "RhinoScriptSyntax.AddCutPlane GetTightBoundingBox failed.startPoint:'%A' endPoint:'%A' normal:'%A' objectIds:%s "startPoint endPoint normal (Nice.str objectIds)
            let mutable bboxMin = bbox0.Min
            let mutable bboxMax = bbox0.Max
            for i=0 to 2 do
                if (abs(bboxMin.[i] - bboxMax.[i]) < RhinoMath.SqrtEpsilon)then
                    bboxMin.[i] <- bboxMin.[i] - 1.0
                    bboxMax.[i] <- bboxMax.[i] + 1.0
            let mutable v = bboxMax - bboxMin
            v <- v * 1.1
            let p = bboxMin + v
            bboxMin <- bboxMax - v
            bboxMax <- p
            Rhino.Geometry.BoundingBox(bboxMin, bboxMax)
        // #else RH6
        // let bbox = BoundingBox.Unset
        // for objectId in objectIds do
        //     let rhobj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        //     let geometry = rhobj.Geometry
        //     bbox.Union( geometry.GetBoundingBox(true))
        // if not bbox.IsValid then
        //     RhinoScriptingException.Raise "RhinoScriptSyntax.AddCutPlane failed.  objectIds:'%A' startPoint:'%A' endPoint:'%A' normal:'%A'" (Nice.str objectIds) startPoint endPoint normal
        // #endif
        let line = Geometry.Line(startPoint, endPoint)
        let normal = if normal.IsZero then Vector3d.ZAxis else normal // TODO or use original ?? : scriptcontext.doc.Views.ActiveView.ActiveViewport.ConstructionPlane().Normal
        let surface = Rhino.Geometry.PlaneSurface.CreateThroughBox(line, normal, bbox)
        if surface|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.AddCutPlane failed.  objectIds:'%A' startPoint:'%A' endPoint:'%A' normal:'%A'" (Nice.str objectIds) startPoint endPoint normal
        let objectId = State.Doc.Objects.AddSurface(surface)
        if objectId = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddCutPlane failed.  objectIds:'%A' startPoint:'%A' endPoint:'%A' normal:'%A'" (Nice.str objectIds) startPoint endPoint normal
        State.Doc.Views.Redraw()
        objectId



    ///<summary>Adds a cylinder-shaped Polysurface to the document.</summary>
    ///<param name="basis">(Plane) The 3D basis point of the cylinder or the basis Plane of the cylinder</param>
    ///<param name="height">(float) If basis is a point, then height is a 3D height point of the
    ///    cylinder. The height point defines the height and direction of the
    ///    cylinder. If basis is a Plane, then height is the numeric height value
    ///    of the cylinder</param>
    ///<param name="radius">(float) Radius of the cylinder</param>
    ///<param name="cap">(bool) Optional, default value: <c>true</c>
    ///    Cap the cylinder</param>
    ///<returns>(Guid) identifier of new object.</returns>
    static member AddCylinder( basis:Plane,
                               height:float,
                               radius:float,
                               [<OPT;DEF(true)>]cap:bool) : Guid =
        let circle = Circle(basis, radius)
        let cylinder = Cylinder(circle, height)
        let brep = cylinder.ToBrep(cap, cap)
        let objectId = State.Doc.Objects.AddBrep(brep)
        if objectId = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddCylinder failed.  basis:'%A' height:'%A' radius:'%A' cap:'%A'" basis height radius cap
        State.Doc.Views.Redraw()
        objectId


    ///<summary>Creates a Surface from 2, 3, or 4 edge Curves.</summary>
    ///<param name="curveIds">(Guid seq) List of Curves</param>
    ///<returns>(Guid) identifier of new object.</returns>
    static member AddEdgeSrf(curveIds:Guid seq) : Guid =
        let curves =  resizeArray { for objectId in curveIds do yield RhinoScriptSyntax.CoerceCurve(objectId) }
        let brep = Brep.CreateEdgeSurface(curves)
        if brep|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.AddEdgeSrf failed.  curveIds:'%s'" (Nice.str curveIds)
        let objectId = State.Doc.Objects.AddBrep(brep)
        if objectId = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddEdgeSrf failed.  curveIds:'%s'" (Nice.str curveIds)
        State.Doc.Views.Redraw()
        objectId


    ///<summary>Creates a Surface from a network of crossing Curves.</summary>
    ///<param name="curves">(Guid seq) Curves from which to create the Surface</param>
    ///<param name="continuity">(int) Optional, default value: <c>1</c>
    ///    How the edges match the input geometry
    ///    0 = loose
    ///    1 = position
    ///    2 = tangency
    ///    3 = curvature</param>
    ///<param name="edgeTolerance">(float) Optional, Edge tolerance</param>
    ///<param name="interiorTolerance">(float) Optional, Interior tolerance</param>
    ///<param name="angleTolerance">(float) Optional, Angle tolerance , in radians?</param>
    ///<returns>(Guid) identifier of new object.</returns>
    static member AddNetworkSrf( curves:Guid seq,
                                 [<OPT;DEF(1)>]continuity:int,
                                 [<OPT;DEF(0.0)>]edgeTolerance:float,
                                 [<OPT;DEF(0.0)>]interiorTolerance:float,
                                 [<OPT;DEF(0.0)>]angleTolerance:float) : Guid =
        let curves =  resizeArray { for curve in curves do yield RhinoScriptSyntax.CoerceCurve(curve) }
        let surf, _ = NurbsSurface.CreateNetworkSurface(curves, continuity, edgeTolerance, interiorTolerance, angleTolerance)// 0.0 Tolerance OK ? TODO
        if notNull surf then
            let rc = State.Doc.Objects.AddSurface(surf)
            State.Doc.Views.Redraw()
            rc
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddNetworkSrf failed on %A" curves

    ///<summary>Adds a NURBS Surface object to the document.</summary>
    ///<param name="pointCount">(int * int) Number of control points in the u and v direction</param>
    ///<param name="points">(Point3d IList) List of 3D points</param>
    ///<param name="knotsU">(float IList) List of Knot values for the Surface in the u direction.
    ///    Must contain pointCount[0]+degree[0]-1 elements</param>
    ///<param name="knotsV">(float IList) List of Knot values for the Surface in the v direction.
    ///    Must contain pointCount[1]+degree[1]-1 elements</param>
    ///<param name="degree">(int * int) Degree of the Surface in the u and v directions</param>
    ///<param name="weights">(float IList) Optional, List of Weight values for the Surface. The number of elements in
    ///    weights must equal the number of elements in points. Values must be greater than zero</param>
    ///<returns>(Guid) identifier of new object.</returns>
    static member AddNurbsSurface( pointCount:int * int,
                                   points:Point3d IList,
                                   knotsU:float seq,
                                   knotsV:float seq,
                                   degree:int * int,
                                   [<OPT;DEF(null:float IList)>]weights:float IList) : Guid =
        let pu, pv = pointCount
        let du, dv = degree
        if points.Count < (pu*pv) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddNurbsSurface failed.  pointCount:'%A' points:'%A' knotsU:'%A' knotsV:'%A' degree:'%A' weights:'%A'" pointCount points knotsU knotsV degree weights
        let ns = NurbsSurface.Create(3, notNull weights , du + 1, dv + 1, pu, pv)
        //add the points && weights
        let controlpoints = ns.Points
        let mutable index = 0

        if notNull weights then
            if weights.Count < (pu*pv) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.AddNurbsSurface failed.  pointCount:'%A' points:'%A' knotsU:'%A' knotsV:'%A' degree:'%A' weights:'%A'" pointCount points knotsU knotsV degree weights
            for i = 0 to pu - 1 do
                for j = 0 to pv - 1 do
                    let cp = ControlPoint(points.[index], weights.[index])
                    controlpoints.SetControlPoint(i, j, cp)|> ignore
                    index <- index + 1
        else
            for i = 0 to pu - 1 do
                for j = 0 to pv - 1 do
                    let cp = ControlPoint(points.[index])
                    controlpoints.SetControlPoint(i, j, cp)|> ignore
                    index <- index + 1
        index <- 0
        for i = 0 to pu - 1 do
            for j = 0 to pv - 1 do
                if notNull weights then
                    let cp = ControlPoint(points.[index], weights.[index])
                    controlpoints.SetControlPoint(i, j, cp)|> ignore
                else
                    let cp = ControlPoint(points.[index])
                    controlpoints.SetControlPoint(i, j, cp)|> ignore
                index <- index + 1

        //add the knots
        let mutable i = 0
        for ku in knotsU do
            ns.KnotsU.[i] <-  ku
            i<-i+1
        if i<> ns.KnotsU.Count then RhinoScriptingException.Raise "RhinoScriptSyntax.AddNurbsSurface failed.  knotsU expected %d knots but input had %d" ns.KnotsU.Count i
        let mutable j = 0
        for kv in knotsV do
            ns.KnotsV.[j] <-  kv
            j<-j+1
        if j<> ns.KnotsV.Count then RhinoScriptingException.Raise "RhinoScriptSyntax.AddNurbsSurface failed.  knotsV expected %d knots but input had %d" ns.KnotsV.Count j


        if not ns.IsValid then RhinoScriptingException.Raise "RhinoScriptSyntax.AddNurbsSurface failed.  pointCount:'%A' points:'%A' knotsU:'%A' knotsV:'%A' degree:'%A' weights:'%A'" pointCount points knotsU knotsV degree weights
        let objectId = State.Doc.Objects.AddSurface(ns)
        if objectId = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddNurbsSurface failed.  pointCount:'%A' points:'%A' knotsU:'%A' knotsV:'%A' degree:'%A' weights:'%A'" pointCount points knotsU knotsV degree weights
        State.Doc.Views.Redraw()
        objectId

    ///<summary>Fits a Surface through Curve, point, point cloud, and Mesh objects.</summary>
    ///<param name="objectIds">(Guid seq) A list of object identifiers that indicate the objects to use for the patch fitting.
    ///    Acceptable object types include Curves, points, point clouds, and Meshes</param>
    ///<param name="startSurfaceId">(Guid) The identifier of the starting Surface. It is best if you create a starting Surface that is similar in shape
    ///    to the Surface you are trying to create</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c>
    ///    The tolerance used by input analysis functions.</param>
    ///<param name="trim">(bool) Optional, default value: <c>true</c>
    ///    Try to find an outside Curve and trims the Surface to it. The default value is True</param>
    ///<param name="pointSpacing">(float) Optional, default value: <c>0.1</c>
    ///    The basic distance between points sampled from input Curves. The default value is 0.1</param>
    ///<param name="flexibility">(float) Optional, default value: <c>1.0</c>
    ///    Determines the behavior of the Surface in areas where its not otherwise controlled by the input.
    ///    Lower numbers make the Surface behave more like a stiff material, higher, more like a flexible material.
    ///    That is, each span is made to more closely match the spans adjacent to it if there is no input geometry
    ///    mapping to that area of the Surface when the flexibility value is low. The scale is logarithmic.
    ///    For example, numbers around 0.001 or 0.1 make the patch pretty stiff and numbers around 10 or 100
    ///    make the Surface flexible. The default value is 1.0</param>
    ///<param name="surfacePull">(float) Optional, default value: <c>1.0</c>
    ///    Similar to stiffness, but applies to the starting Surface. The bigger the pull, the closer
    ///    the resulting Surface shape will be to the starting Surface. The default value is 1.0</param>
    ///<param name="fixEdges">(bool) Optional, default value: <c>false</c>
    ///    Clamps the edges of the starting Surface in place. This option is useful if you are using a
    ///    Curve or points for deforming an existing Surface, and you do not want the edges of the starting Surface
    ///    to move. The default if False</param>
    ///<returns>(Guid) Identifier of the new Surface object.</returns>
    static member AddPatch( objectIds:Guid seq,
                              startSurfaceId: Guid,
                              [<OPT;DEF(0.0)>]tolerance:float,
                              [<OPT;DEF(true)>]trim:bool,
                              [<OPT;DEF(0.1)>]pointSpacing:float,
                              [<OPT;DEF(1.0)>]flexibility:float,
                              [<OPT;DEF(1.0)>]surfacePull:float,
                              [<OPT;DEF(false)>]fixEdges:bool) : Guid =
                    let uspan, vspan = 10, 10
                    let geometry =   resizeArray {for objectId in objectIds do RhinoScriptSyntax.CoerceRhinoObject(objectId).Geometry }
                    let surface = RhinoScriptSyntax.CoerceSurface(startSurfaceId)
                    let tolerance = if 0.0 = tolerance then State.Doc.ModelAbsoluteTolerance else tolerance
                    let b =  Array.create 4 fixEdges
                    let brep = Brep.CreatePatch(geometry, surface, uspan, vspan, trim, false, pointSpacing, flexibility, surfacePull, b, tolerance)
                    if notNull brep then
                        let rc =  State.Doc.Objects.AddBrep(brep)
                        State.Doc.Views.Redraw()
                        rc
                    else
                        RhinoScriptingException.Raise "RhinoScriptSyntax.AddPatch failed for %A and %A" (Nice.str objectIds) startSurfaceId

    ///<summary>Fits a Surface through Curve, point, point cloud, and Mesh objects.</summary>
    ///<param name="objectIds">(Guid seq) A list of object identifiers that indicate the objects to use for the patch fitting.
    ///    Acceptable object types include Curves, points, point clouds, and Meshes</param>
    ///<param name="uvSpans">(int * int) The U and V direction span counts for the automatically generated Surface . however it is best if you create a starting Surface that is similar in shape
    ///    to the Surface you are trying to create an use the other overload of this method</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c>
    ///    The tolerance used by input analysis functions.</param>
    ///<param name="trim">(bool) Optional, default value: <c>true</c>
    ///    Try to find an outside Curve and trims the Surface to it. The default value is True</param>
    ///<param name="pointSpacing">(float) Optional, default value: <c>0.1</c>
    ///    The basic distance between points sampled from input Curves. The default value is 0.1</param>
    ///<param name="flexibility">(float) Optional, default value: <c>1.0</c>
    ///    Determines the behavior of the Surface in areas where its not otherwise controlled by the input.
    ///    Lower numbers make the Surface behave more like a stiff material, higher, more like a flexible material.
    ///    That is, each span is made to more closely match the spans adjacent to it if there is no input geometry
    ///    mapping to that area of the Surface when the flexibility value is low. The scale is logarithmic.
    ///    For example, numbers around 0.001 or 0.1 make the patch pretty stiff and numbers around 10 or 100
    ///    make the Surface flexible. The default value is 1.0</param>
    ///<param name="surfacePull">(float) Optional, default value: <c>1.0</c>
    ///    Similar to stiffness, but applies to the starting Surface. The bigger the pull, the closer
    ///    the resulting Surface shape will be to the starting Surface. The default value is 1.0</param>
    ///<param name="fixEdges">(bool) Optional, default value: <c>false</c>
    ///    Clamps the edges of the starting Surface in place. This option is useful if you are using a
    ///    Curve or points for deforming an existing Surface, and you do not want the edges of the starting Surface
    ///    to move. The default if False</param>
    ///<returns>(Guid) Identifier of the new Surface object.</returns>
    static member AddPatch( objectIds:Guid seq,
                            uvSpans: int * int ,
                            [<OPT;DEF(0.0)>]tolerance:float,
                            [<OPT;DEF(true)>]trim:bool,
                            [<OPT;DEF(0.1)>]pointSpacing:float,
                            [<OPT;DEF(1.0)>]flexibility:float,
                            [<OPT;DEF(1.0)>]surfacePull:float,
                            [<OPT;DEF(false)>]fixEdges:bool) : Guid =

        let uspan, vspan = uvSpans
        let geometry =   resizeArray {for objectId in objectIds do RhinoScriptSyntax.CoerceRhinoObject(objectId).Geometry }
        let tolerance = if 0.0 = tolerance then State.Doc.ModelAbsoluteTolerance else tolerance
        let b =  Array.create 4 fixEdges
        let brep = Brep.CreatePatch(geometry, null, uspan, vspan, trim, false, pointSpacing, flexibility, surfacePull, b, tolerance) //TODO test with null as srf
        if notNull brep then
            let rc =  State.Doc.Objects.AddBrep(brep)
            State.Doc.Views.Redraw()
            rc
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddPatch failed for %A and %A" (Nice.str objectIds) uvSpans


    ///<summary>Creates a single walled Surface with a circular profile around a Curve.</summary>
    ///<param name="curveId">(Guid) Identifier of rail Curve</param>
    ///<param name="parameters">(float seq) normalized Curve parameters</param>
    ///<param name="radii">(float seq) radius values at normalized Curve parameters</param>
    ///<param name="blendType">(int) Optional, default value: <c>0</c>
    ///    0(local) or 1(global)</param>
    ///<param name="cap">(int) Optional, default value: <c>0</c>
    ///    0(none), 1(flat), 2(round)</param>
    ///<param name="fit">(bool) Optional, default value: <c>false</c>
    ///    Attempt to fit a single Surface</param>
    ///<returns>(Guid ResizeArray) identifiers of new objects created.</returns>
    static member AddPipe( curveId:Guid,
                           parameters:float seq,
                           radii:float seq,
                           [<OPT;DEF(0)>]blendType:int,
                           [<OPT;DEF(0)>]cap:int,
                           [<OPT;DEF(false)>]fit:bool) : Guid ResizeArray =
        let rail = RhinoScriptSyntax.CoerceCurve(curveId)
        let abstol = State.Doc.ModelAbsoluteTolerance
        let angtol = State.Doc.ModelAngleToleranceRadians
        let cap :PipeCapMode  = LanguagePrimitives.EnumOfValue  cap
        let breps = Brep.CreatePipe(rail, parameters, radii, (blendType = 0), cap, fit, abstol, angtol)
        let rc =  resizeArray { for brep in breps do yield State.Doc.Objects.AddBrep(brep) }
        State.Doc.Views.Redraw()
        rc



    ///<summary>Creates one Surface from one Polyline Geometry.</summary>
    ///<param name="polyline">(Polyline) one Polyline Geometry to use for creating planar Surfaces</param>
    ///<returns>(Guid) identifier of Surface created .</returns>
    static member AddPlanarSrf(polyline:Polyline) : Guid=
        let tolerance = State.Doc.ModelAbsoluteTolerance
        let breps = Brep.CreatePlanarBreps(new PolylineCurve(polyline), tolerance)
        if notNull breps then
            if breps.Length <> 1 then RhinoScriptingException.Raise "RhinoScriptSyntax.AddPlanarSrf created more then one surface on one input curve, use the seq overload instead on the same function on %s" (Nice.str polyline)
            let rc =  State.Doc.Objects.AddBrep(breps.[0])
            State.Doc.Views.Redraw()
            rc
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddPlanarSrf(polyline:Polyline) failed on  %s" (Nice.str polyline)

    ///<summary>Creates one Surface from one planar Curve.</summary>
    ///<param name="curve">(Curve) one Curve Geometry to use for creating planar Surfaces</param>
    ///<returns>(Guid) identifier of Surface created .</returns>
    static member AddPlanarSrf(curve:Curve) : Guid=
        let tolerance = State.Doc.ModelAbsoluteTolerance
        let breps = Brep.CreatePlanarBreps(curve, tolerance)
        if notNull breps then
            if breps.Length <> 1 then RhinoScriptingException.Raise "RhinoScriptSyntax.AddPlanarSrf created more then one surface on one input curve, use the seq overload instead on the same function on %s" (Nice.str curve)
            let rc =  State.Doc.Objects.AddBrep(breps.[0])
            State.Doc.Views.Redraw()
            rc
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddPlanarSrf(curve:Curve) failed on %s" (Nice.str curve)

    ///<summary>Creates one or more Surfaces from planar Curves.</summary>
    ///<param name="curves">(Curve seq) several Curves Geometries to use for creating planar Surfaces</param>
    ///<returns>(Guid ResizeArray) identifiers of Surfaces created .</returns>
    static member AddPlanarSrf(curves:Curve seq) : Guid ResizeArray =
        let tolerance = State.Doc.ModelAbsoluteTolerance
        let breps = Brep.CreatePlanarBreps(curves, tolerance)
        if notNull breps then
            let rc =  resizeArray { for brep in breps do yield State.Doc.Objects.AddBrep(brep) }
            State.Doc.Views.Redraw()
            rc
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddPlanarSrf(curves:Curve seq) failed on %s" (Nice.str curves)

    ///<summary>Creates one or more Surfaces from planar Curves.</summary>
    ///<param name="objectIds">(Guid seq) Curves to use for creating planar Surfaces</param>
    ///<returns>(Guid ResizeArray) identifiers of Surfaces created .</returns>
    static member AddPlanarSrf(objectIds:Guid seq) : Guid ResizeArray =
        let curves =  resizeArray { for objectId in objectIds do yield RhinoScriptSyntax.CoerceCurve(objectId) }
        let tolerance = State.Doc.ModelAbsoluteTolerance
        let breps = Brep.CreatePlanarBreps(curves, tolerance)
        if notNull breps then
            let rc =  resizeArray { for brep in breps do yield State.Doc.Objects.AddBrep(brep) }
            State.Doc.Views.Redraw()
            rc
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddPlanarSrf(objectIds:Guid seq) failed on %s" (Nice.str objectIds)



    ///<summary>Create a Plane Surface and add it to the document.</summary>
    ///<param name="plane">(Plane) The Plane</param>
    ///<param name="uDir">(float) The magnitude in the U direction</param>
    ///<param name="vDir">(float) The magnitude in the V direction</param>
    ///<returns>(Guid) The identifier of the new object.</returns>
    static member AddPlaneSurface( plane:Plane,
                                   uDir:float,
                                   vDir:float) : Guid =
        //plane = RhinoScriptSyntax.CoercePlane(plane)
        let uinterval = Interval(0.0, uDir)
        let vinterval = Interval(0.0, vDir)
        let planesurface = new PlaneSurface(plane, uinterval, vinterval)
        if planesurface|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.AddPlaneSurface failed.  plane:'%A' uDir:'%A' vDir:'%A'" plane uDir vDir
        let rc = State.Doc.Objects.AddSurface(planesurface)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddPlaneSurface failed.  plane:'%A' uDir:'%A' vDir:'%A'" plane uDir vDir
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds a Surface created by lofting Curves to the document.
    ///    - no Curve sorting performed. pass in Curves in the order you want them sorted
    ///    - directions of open Curves not adjusted. Use CurveDirectionsMatch and
    ///      ReverseCurve to adjust the directions of open Curves
    ///    - seams of closed Curves are not adjusted. Use CurveSeam to adjust the seam
    ///      of closed Curves.</summary>
    ///<param name="objectIds">(Guid seq) Ordered list of the Curves to loft through</param>
    ///<param name="start">(Point3d) Optional, Starting point of the loft</param>
    ///<param name="ende">(Point3d) Optional, Ending point of the loft</param>
    ///<param name="loftType">(int) Optional, default value: <c>0</c>
    ///    Type of loft. Possible options are:
    ///    0 = Normal. Uses chord-length parameterization in the loft direction
    ///    1 = Loose. The Surface is allowed to move away from the original Curves
    ///      to make a smoother Surface. The Surface control points are created
    ///      at the same locations as the control points of the loft input Curves.
    ///    2 = Straight. The sections between the Curves are straight. This is
    ///      also known as a ruled Surface.
    ///    3 = Tight. The Surface sticks closely to the original Curves. Uses square
    ///      root of chord-length parameterization in the loft direction</param>
    ///<param name="rebuild">(int) Optional, default value: <c>0</c>
    ///    If not 0 then Rebuilds the shape Curves before lofting with this control point count</param>
    ///<param name="refit">(float) Optional, if given the loft is refitted, the value is the tolerance used to rebuild</param>
    ///<param name="closed">(bool) Optional, default value: <c>false</c>
    ///    Close the loft back to the first Curve</param>
    ///<returns>(Guid ResizeArray) Array containing the identifiers of the new Surface objects.</returns>
    static member AddLoftSrf( objectIds:Guid seq,
                              [<OPT;DEF(Point3d())>]start:Point3d, //TODO make overload instead,[<OPT;DEF(Point3d())>] may leak  see draw vector and transform point!
                              [<OPT;DEF(Point3d())>]ende:Point3d,
                              [<OPT;DEF(0)>]loftType:int,
                              [<OPT;DEF(0)>]rebuild:int,
                              [<OPT;DEF(0.0)>]refit:float,
                              [<OPT;DEF(false)>]closed:bool) : Guid ResizeArray =
        if loftType<0 || loftType>4 then RhinoScriptingException.Raise "RhinoScriptSyntax.AddLoftSrf: LoftType must be 0-4.  objectIds:'%A' start:'%A' end:'%A' loftType:'%A' rebuild:'%A' refit:'%A' closed:'%A'" (Nice.str objectIds) start ende loftType rebuild refit closed
        if rebuild<>0 && refit<>0.0 then RhinoScriptingException.Raise "RhinoScriptSyntax.AddLoftSrf: set either rebuild or refit to a value ! not both.  objectIds:'%A' start:'%A' end:'%A' loftType:'%A' rebuild:'%A' refit:'%A' closed:'%A'" (Nice.str objectIds) start ende loftType rebuild refit closed
        let curves =  resizeArray { for objectId in objectIds do yield RhinoScriptSyntax.CoerceCurve(objectId) }
        if Seq.length(curves)<2 then RhinoScriptingException.Raise "RhinoScriptSyntax.AddLoftSrf failed.  objectIds:'%A' start:'%A' end:'%A' loftType:'%A' rebuild:'%A' refit:'%A' closed:'%A'" (Nice.str objectIds) start ende loftType rebuild refit closed
        let start = if start = Point3d.Origin  then Point3d.Unset else start
        let ende  = if ende  = Point3d.Origin  then Point3d.Unset else ende
        let mutable lt = LoftType.Normal
        if loftType = 1 then lt <- LoftType.Loose
        elif loftType = 2 then lt <- LoftType.Straight
        elif loftType = 3 then lt <- LoftType.Tight
        //elif loftType = 4 then lt <- LoftType.Developable
        let mutable breps = null
        if rebuild = 0 && refit = 0.0 then
            breps <- Brep.CreateFromLoft(curves, start, ende, lt, closed)
        elif rebuild > 0 then
            breps <- Brep.CreateFromLoftRebuild(curves, start, ende, lt, closed, rebuild)
        elif refit > 0.0 then
            breps <- Brep.CreateFromLoftRefit(curves, start, ende, lt, closed, refit)
        if isNull breps then RhinoScriptingException.Raise "RhinoScriptSyntax.AddLoftSrf failed.  objectIds:'%A' start:'%A' end:'%A' loftType:'%A' rebuild:'%A' refit:'%A' closed:'%A'" (Nice.str objectIds) start ende loftType rebuild refit closed
        let idlist = ResizeArray()
        for brep in breps do
            let objectId = State.Doc.Objects.AddBrep(brep)
            if objectId <> Guid.Empty then idlist.Add(objectId)
        if idlist.IsNotEmpty then State.Doc.Views.Redraw()
        idlist


    ///<summary>Create a Surface by revolving a Curve around an axis.</summary>
    ///<param name="curveId">(Guid) Identifier of profile Curve</param>
    ///<param name="axis">(Line) Line for the rail revolve axis</param>
    ///<param name="startAngle">(float) Optional, default value: <c>0.0</c>
    ///    Start angles of revolve</param>
    ///<param name="endAngle">(float) Optional, default value: <c>360.0</c>
    ///    End angles of revolve</param>
    ///<returns>(Guid) identifier of new object.</returns>
    static member AddRevSrf( curveId:Guid,
                             axis:Line,
                             [<OPT;DEF(0.0)>]startAngle:float,
                             [<OPT;DEF(360.0)>]endAngle:float) : Guid =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        //axis = RhinoScriptSyntax.Coerceline(axis)
        let startAngle = toRadians(startAngle)
        let endAngle = toRadians(endAngle)
        let srf = RevSurface.Create(curve, axis, startAngle, endAngle)
        if isNull srf then RhinoScriptingException.Raise "RhinoScriptSyntax.AddRevSrf failed. curveId:'%s' axis:'%A' startAngle:'%A' endAngle:'%A'" (Nice.str curveId) axis startAngle endAngle
        let ns = srf.ToNurbsSurface()
        if isNull ns then RhinoScriptingException.Raise "RhinoScriptSyntax.AddRevSrf failed. curveId:'%s' axis:'%A' startAngle:'%A' endAngle:'%A'" (Nice.str curveId) axis startAngle endAngle
        let rc = State.Doc.Objects.AddSurface(ns)
        State.Doc.Views.Redraw()
        rc


    ///<summary>Add a spherical Surface to the document.</summary>
    ///<param name="center">(Point3d) Center point of the sphere</param>
    ///<param name="radius">(float) Radius of the sphere in the current model units</param>
    ///<returns>(Guid) identifier of the new object .</returns>
    static member AddSphere(center:Point3d, radius:float) : Guid =
        let sphere = Sphere(center, radius)
        let rc = State.Doc.Objects.AddSphere(sphere)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddSphere failed.  centerOrPlane:'%A' radius:'%A'" center radius
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds a spaced series of planar Curves resulting from the intersection of
    ///    defined cutting Planes through a Surface or Polysurface. For more
    ///    information, see Rhino help for details on the Contour command.</summary>
    ///<param name="objectId">(Guid) Object identifier to contour</param>
    ///<param name="plane">(Plane) The Plane that defines the cutting Plane</param>
    ///<returns>(Guid ResizeArray) ids of new contour Curves .</returns>
    static member AddSrfContourCrvs( objectId:Guid,
                                     plane:Plane) : Guid ResizeArray =
        let brep = RhinoScriptSyntax.CoerceBrep(objectId)
        //plane = RhinoScriptSyntax.CoercePlane(pointsOrPlane)
        let curves =  Brep.CreateContourCurves(brep, plane)
        let rc = ResizeArray()
        for crv in curves do
            let objectId = State.Doc.Objects.AddCurve(crv)
            if objectId <> Guid.Empty then rc.Add(objectId)
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds a spaced series of planar Curves resulting from the intersection of
    ///    defined cutting Planes through a Surface or Polysurface. For more
    ///    information, see Rhino help for details on the Contour command.</summary>
    ///<param name="objectId">(Guid) Object identifier to contour</param>
    ///<param name="startPoint">(Point3d) The start point of a center line</param>
    ///<param name="endPoint">(Point3d)   the end point of a center line</param>
    ///<param name="interval">(float) Distance between contour Curves</param>
    ///<returns>(Guid ResizeArray) ids of new contour Curves .</returns>
    static member AddSrfContourCrvs( objectId:Guid,
                                     startPoint:Point3d,
                                     endPoint :Point3d ,
                                     interval:float) : Guid ResizeArray=
        let brep = RhinoScriptSyntax.CoerceBrep(objectId)
        let curves =  Brep.CreateContourCurves(brep, startPoint , endPoint, interval)
        let rc = ResizeArray()
        for crv in curves do
            let objectId = State.Doc.Objects.AddCurve(crv)
            if objectId <> Guid.Empty then rc.Add(objectId)
        State.Doc.Views.Redraw()
        rc


    ///<summary>Creates a Surface from a grid of points.</summary>
    ///<param name="count">(int * int) Tuple of two numbers defining number of points in the u, v directions</param>
    ///<param name="points">(Point3d seq) List of 3D points</param>
    ///<param name="degreeU">(int) Optional, default value: <c>3</c> degree of the Surface in the U directions</param>
    ///<param name="degreeV">(int) Optional, default value: <c>3</c> degree of the Surface in the V directions</param>
    ///<returns>(Guid) The identifier of the new object.</returns>
    static member AddSrfControlPtGrid( count:int * int,
                                       points:Point3d seq,
                                       [<OPT;DEF(3)>]degreeU:int,
                                       [<OPT;DEF(3)>]degreeV:int           ) : Guid =
        //points = RhinoScriptSyntax.Coerce3dPointlist(points)
        let surf = NurbsSurface.CreateFromPoints(points, fst count, snd count,  degreeU,  degreeV)
        if isNull surf then RhinoScriptingException.Raise "RhinoScriptSyntax.AddSrfControlPtGrid failed.  count:'%A' points:'%A' degree:'%A'" count points (degreeU,degreeV)
        let objectId = State.Doc.Objects.AddSurface(surf)
        if objectId <> Guid.Empty then
            State.Doc.Views.Redraw()
            objectId
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddSrfControlPtGrid failed.  count:'%A' points:'%A' degree:'%A'" count points (degreeU,degreeV)

    ///<summary>Creates a new Surface from four corner points.</summary>
    ///<param name="pointA">(Point3d) First corner point</param>
    ///<param name="pointB">(Point3d) Second  corner point</param>
    ///<param name="pointC">(Point3d) Third corner point</param>
    ///<param name="pointD">(Point3d) Fourth corner point</param>
    ///<returns>(Guid) The identifier of the new object.</returns>
    static member AddSrfPt(pointA:Point3d , pointB:Point3d , pointC: Point3d , pointD: Point3d) : Guid =
        let surface = NurbsSurface.CreateFromCorners(pointA , pointB , pointC , pointD)
        if surface|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.AddSrfPt failed.  points:'%A, %A, %A and %A" pointA pointB pointC pointD
        let rc = State.Doc.Objects.AddSurface(surface)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddSrfPt failed.  points:'%A, %A, %A and %A" pointA pointB pointC pointD
        State.Doc.Views.Redraw()
        rc

    ///<summary>Creates a new Surface from three corner points.</summary>
    ///<param name="pointA">(Point3d) First corner point</param>
    ///<param name="pointB">(Point3d) Second  corner point</param>
    ///<param name="pointC">(Point3d) Third corner point</param>
    ///<returns>(Guid) The identifier of the new object.</returns>
    static member AddSrfPt(pointA:Point3d , pointB:Point3d , pointC: Point3d ) : Guid =
        let surface = NurbsSurface.CreateFromCorners(pointA , pointB , pointC)
        if surface|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.AddSrfPt failed.  points:'%A, %A and %A" pointA pointB pointC
        let rc = State.Doc.Objects.AddSurface(surface)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.AddSrfPt failed.  points:'%A, %A and %A" pointA pointB pointC
        State.Doc.Views.Redraw()
        rc


    ///<summary>Creates a Surface from a grid of points.</summary>
    ///<param name="count">(int * int) Tuple of two numbers defining number of points in the u, v directions</param>
    ///<param name="points">(Point3d seq) List of 3D points</param>
    ///<param name="degreeU">(int) Optional, default value: <c>3</c> degree of the Surface in the U directions</param>
    ///<param name="degreeV">(int) Optional, default value: <c>3</c> degree of the Surface in the V directions</param>
    ///<param name="closedU">(bool * bool) Optional, default value: <c>false</c>  boolean defining if the Surface is closed in the U directions</param>
    ///<param name="closedV">(bool * bool) Optional, default value: <c>false</c>  boolean defining if the Surface is closed in the V directions</param>
    ///<returns>(Guid) The identifier of the new object.</returns>
    static member AddSrfPtGrid( count:int * int,
                                points:Point3d seq,
                                [<OPT;DEF(3)>]degreeU:int,
                                [<OPT;DEF(3)>]degreeV:int,
                                [<OPT;DEF(false)>]closedU:bool,
                                [<OPT;DEF(false)>]closedV:bool) : Guid =
        //points = RhinoScriptSyntax.Coerce3dPointlist(points)
        let surf = NurbsSurface.CreateThroughPoints(points, fst count, snd count, degreeU, degreeV, closedU, closedV)
        if isNull surf then RhinoScriptingException.Raise "RhinoScriptSyntax.AddSrfPtGrid failed.  count:'%A' points:'%A' degree:'%A' closed:'%A'" count points (degreeU,degreeV) (closedU,closedV)
        let objectId = State.Doc.Objects.AddSurface(surf)
        if objectId <> Guid.Empty then
            State.Doc.Views.Redraw()
            objectId
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.AddSrfPtGrid failed.  count:'%A' points:'%A' degree:'%A' closed:'%A'" count points (degreeU,degreeV) (closedU,closedV)


    ///<summary>Adds a Surface created through profile Curves that define the Surface
    ///    shape and one Curve that defines a Surface edge.</summary>
    ///<param name="rail">(Guid) Identifier of the rail Curve</param>
    ///<param name="shapes">(Guid seq) One or more cross section shape Curves</param>
    ///<param name="closed">(bool) Optional, default value: <c>false</c>
    ///    If True, then create a closed Surface</param>
    ///<returns>(Guid ResizeArray) List of new Surface objects.</returns>
    static member AddSweep1( rail:Guid,
                             shapes:Guid seq,
                             [<OPT;DEF(false)>]closed:bool) : Guid ResizeArray =
        let rail = RhinoScriptSyntax.CoerceCurve(rail)
        let shapes =  resizeArray { for shape in shapes do yield RhinoScriptSyntax.CoerceCurve(shape) }
        let tolerance = State.Doc.ModelAbsoluteTolerance
        let breps = Brep.CreateFromSweep(rail, shapes, closed, tolerance)
        if isNull breps then RhinoScriptingException.Raise "RhinoScriptSyntax.AddSweep1 failed.  rail:'%A' shapes:'%A' closed:'%A'" rail shapes closed
        let rc =  resizeArray { for brep in breps do yield State.Doc.Objects.AddBrep(brep) }
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds a Surface created through profile Curves that define the Surface
    ///    shape and two Curves that defines a Surface edge.</summary>
    ///<param name="rails">(Guid * Guid) Identifiers of the two rail Curve</param>
    ///<param name="shapes">(Guid seq) One or more cross section shape Curves</param>
    ///<param name="closed">(bool) Optional, default value: <c>false</c>
    ///    If True, then create a closed Surface</param>
    ///<returns>(Guid ResizeArray) List of new Surface objects.</returns>
    static member AddSweep2( rails:Guid * Guid,
                             shapes:Guid seq,
                             [<OPT;DEF(false)>]closed:bool) : Guid ResizeArray =
        let rail1 = RhinoScriptSyntax.CoerceCurve(fst rails)
        let rail2 = RhinoScriptSyntax.CoerceCurve(snd rails)
        let shapes =  resizeArray { for shape in shapes do yield RhinoScriptSyntax.CoerceCurve(shape) }
        let tolerance = State.Doc.ModelAbsoluteTolerance
        let breps = Brep.CreateFromSweep(rail1, rail2, shapes, closed, tolerance)
        if isNull breps then RhinoScriptingException.Raise "RhinoScriptSyntax.AddSweep2 failed.  rails:'%A' shapes:'%A' closed:'%A'" rails shapes closed
        let rc =  resizeArray { for brep in breps do yield State.Doc.Objects.AddBrep(brep) }
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds a Surface created through profile Curves that define the Surface
    ///    shape and two Curves that defines a Surface edge.</summary>
    ///<param name="profile">(Guid) Identifier of the profile Curve</param>
    ///<param name="rail">(Guid) Identifier of the rail Curve</param>
    ///<param name="axis">(Line) A Line identifying the start point and end point of the rail revolve axis</param>
    ///<param name="scaleHeight">(bool) Optional, default value: <c>false</c>
    ///    If True, Surface will be locally scaled. Defaults to False</param>
    ///<returns>(Guid) identifier of the new object.</returns>
    static member AddRailRevSrf( profile:Guid,
                                 rail:Guid,
                                 axis:Line,
                                 [<OPT;DEF(false)>]scaleHeight:bool) : Guid =
        let profileinst = RhinoScriptSyntax.CoerceCurve(profile)
        let railinst = RhinoScriptSyntax.CoerceCurve(rail)
        let surface = NurbsSurface.CreateRailRevolvedSurface(profileinst, railinst, axis, scaleHeight)
        if isNull surface then RhinoScriptingException.Raise "RhinoScriptSyntax.AddRailRevSrf failed.  profile:'%A' rail:'%A' axis:'%A' scaleHeight:'%A'" profile rail axis scaleHeight
        let rc = State.Doc.Objects.AddSurface(surface)
        State.Doc.Views.Redraw()
        rc


    ///<summary>Adds a torus shaped revolved Surface to the document.</summary>
    ///<param name="basis">(Plane) The basis Plane of the torus</param>
    ///<param name="majorRadius">(float) Major radius of  the torus</param>
    ///<param name="minorRadius">(float) Minor radius of  torus</param>
    ///<returns>(Guid) The identifier of the new object.</returns>
    static member AddTorus( basis:Plane,
                            majorRadius:float,
                            minorRadius:float) : Guid =
        let torus = Torus(basis, majorRadius, minorRadius)
        let revsurf = torus.ToRevSurface()
        let rc = State.Doc.Objects.AddSurface(revsurf)
        State.Doc.Views.Redraw()
        rc


    ///<summary>Performs a boolean difference operation on two sets of input Surfaces
    ///    and Polysurfaces. For more details, see the BooleanDifference command in
    ///    the Rhino help file.</summary>
    ///<param name="input0">(Guid seq) List of Surfaces to subtract from</param>
    ///<param name="input1">(Guid seq) List of Surfaces to be subtracted</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>true</c>
    ///    Delete all input objects</param>
    ///<returns>(Guid ResizeArray) List of identifiers of newly created objects .</returns>
    static member BooleanDifference( input0:Guid seq,
                                     input1:Guid seq,
                                     [<OPT;DEF(true)>]deleteInput:bool) : Guid ResizeArray =

        let breps0 =  resizeArray { for objectId in input0 do yield RhinoScriptSyntax.CoerceBrep(objectId) }
        let breps1 =  resizeArray { for objectId in input1 do yield RhinoScriptSyntax.CoerceBrep(objectId) }
        let tolerance = State.Doc.ModelAbsoluteTolerance
        let newbreps = Brep.CreateBooleanDifference(breps0, breps1, tolerance)
        if newbreps|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.BooleanDifference failed.  input0:'%A' input1:'%A' deleteInput:'%A'" input0 input1 deleteInput
        let rc =  resizeArray { for brep in newbreps do yield State.Doc.Objects.AddBrep(brep) }
        if deleteInput then
            for objectId in input0 do State.Doc.Objects.Delete(objectId, true)|> ignore
            for objectId in input1 do State.Doc.Objects.Delete(objectId, true)|> ignore
        State.Doc.Views.Redraw()
        rc


    ///<summary>Performs a boolean intersection operation on two sets of input Surfaces
    ///    and Polysurfaces. For more details, see the BooleanIntersection command in
    ///    the Rhino help file.</summary>
    ///<param name="input0">(Guid seq) List of Surfaces</param>
    ///<param name="input1">(Guid seq) List of Surfaces</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>true</c>
    ///    Delete all input objects</param>
    ///<returns>(Guid ResizeArray) List of identifiers of newly created objects .</returns>
    static member BooleanIntersection( input0:Guid seq,
                                       input1:Guid seq,
                                       [<OPT;DEF(true)>]deleteInput:bool) : Guid ResizeArray =
        let breps0 =  resizeArray { for objectId in input0 do yield RhinoScriptSyntax.CoerceBrep(objectId) }
        let breps1 =  resizeArray { for objectId in input1 do yield RhinoScriptSyntax.CoerceBrep(objectId) }
        let tolerance = State.Doc.ModelAbsoluteTolerance
        let newbreps = Brep.CreateBooleanIntersection(breps0, breps1, tolerance)
        if newbreps|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.BooleanIntersection failed.  input0:'%A' input1:'%A' deleteInput:'%A'" input0 input1 deleteInput
        let rc =  resizeArray { for brep in newbreps do yield State.Doc.Objects.AddBrep(brep) }
        if deleteInput then
            for objectId in input0 do State.Doc.Objects.Delete(objectId, true)|> ignore
            for objectId in input1 do State.Doc.Objects.Delete(objectId, true)|> ignore
        State.Doc.Views.Redraw()
        rc


    ///<summary>Performs a boolean union operation on a set of input Surfaces and
    ///    Polysurfaces. For more details, see the BooleanUnion command in the
    ///    Rhino help file.</summary>
    ///<param name="input">(Guid seq) List of Surfaces to union</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>true</c>
    ///    Delete all input objects</param>
    ///<returns>(Guid ResizeArray) List of identifiers of newly created objects .</returns>
    static member BooleanUnion(input:Guid seq, [<OPT;DEF(true)>]deleteInput:bool) : Guid ResizeArray =
        if Seq.length(input)<2 then RhinoScriptingException.Raise "RhinoScriptSyntax.BooleanUnion failed.  input:'%A' deleteInput:'%A'" input deleteInput
        let breps =  resizeArray { for objectId in input do yield RhinoScriptSyntax.CoerceBrep(objectId) }
        let tolerance = State.Doc.ModelAbsoluteTolerance
        let newbreps = Brep.CreateBooleanUnion(breps, tolerance)
        if newbreps|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.BooleanUnion failed.  input:'%A' deleteInput:'%A'" input deleteInput
        let rc =  resizeArray { for brep in newbreps do yield State.Doc.Objects.AddBrep(brep) }
        if  deleteInput then
            for objectId in input do State.Doc.Objects.Delete(objectId, true)|> ignore
        State.Doc.Views.Redraw()
        rc


    ///<summary>Returns the point on a Surface or Polysurface that is closest to a test
    ///    point. This function works on both untrimmed and trimmed Surfaces.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<param name="point">(Point3d) The test, or sampling point</param>
    ///<returns>(Point3d * float * float * ComponentIndexType * int * Vector3d) of closest point information . The list will
    ///    contain the following information:
    ///    Element     Type            Description
    ///      0        Point3d          The 3-D point at the parameter value of the closest point.
    ///      1        (U of U, V)      Parameter values of closest point.
    ///                                   Note, V is 0 if the component index type is brepEdge or brepVertex.
    ///      2        (V of U, V)      Parameter values of closest point.
    ///                                   Note, V is 0 if the component index type is brepEdge or brepVertex.
    ///      3        (type, index)   The type  the brep component that contains the closest point. Possible types are
    ///                                   BrepVertex 1 Targets a brep vertex index.
    ///                                   BrepEdge   2 Targets a brep edge index.
    ///                                   BrepFace   3 Targets a brep face index.
    ///                                   BrepTrim   4 Targets a brep trim index.
    ///                                   BrepLoop   5 Targets a brep loop index.
    ///      4        int             The index of the brep component
    ///      5        Vector3d        The normal to the brepFace, or the tangent to the brepEdge.</returns>
    static member BrepClosestPoint(objectId:Guid, point:Point3d) : Point3d * float * float * ComponentIndexType * int * Vector3d =
        let brep = RhinoScriptSyntax.CoerceBrep(objectId)
        let clpt = ref Point3d.Origin
        let ci = ref ComponentIndex.Unset
        let s = ref 0.0
        let t = ref 0.0
        let n = ref Vector3d.Zero
        let ok = brep.ClosestPoint(point, clpt, ci, s, t, 0.0, n)
        if ok then
            let typ = (!ci).ComponentIndexType
            let idx = (!ci).Index
            !clpt,!s,!t, typ, idx, !n
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.BrepClosestPoint failed for %A and %A" (Nice.str objectId) point


    ///<summary>Caps planar holes in a Surface or Polysurface.</summary>
    ///<param name="surfaceId">(Guid) The identifier of the Surface or Polysurface to cap</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member CapPlanarHoles(surfaceId:Guid) : bool =
        let brep = RhinoScriptSyntax.CoerceBrep(surfaceId)
        let tolerance = State.Doc.ModelAbsoluteTolerance
        let newbrep = brep.CapPlanarHoles(tolerance)
        if notNull newbrep then
            if newbrep.SolidOrientation = BrepSolidOrientation.Inward then
                newbrep.Flip()
            //surfaceId = RhinoScriptSyntax.CoerceGuid(surfaceId)
            if State.Doc.Objects.Replace(surfaceId, newbrep) then
                State.Doc.Views.Redraw()
                true
            else
                false
        else
            false


    ///<summary>Duplicates the edge Curves of a Surface or Polysurface. For more
    ///    information, see the Rhino help file for information on the DupEdge
    ///    command.</summary>
    ///<param name="objectId">(Guid) The identifier of the Surface or Polysurface object</param>
    ///<param name="select">(bool) Optional, default value: <c>false</c>
    ///    Select the duplicated edge Curves. The default is not to select (False)</param>
    ///<returns>(Guid ResizeArray) identifying the newly created Curve objects.</returns>
    static member DuplicateEdgeCurves(objectId:Guid, [<OPT;DEF(false)>]select:bool) : Guid ResizeArray =
        let brep = RhinoScriptSyntax.CoerceBrep(objectId)
        let outcurves = brep.DuplicateEdgeCurves()
        let curves = ResizeArray()
        for curve in outcurves do
            if curve.IsValid then
                let rc = State.Doc.Objects.AddCurve(curve)
                curve.Dispose()
                if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.DuplicateEdgeCurves failed on one of the edge curves"
                curves.Add(rc)
                if select then
                    let rhobject = RhinoScriptSyntax.CoerceRhinoObject(rc)
                    rhobject.Select(true)  |>  ignore // TODO needs sync ? apparently not needed!
        if curves.IsNotEmpty then State.Doc.Views.Redraw()
        curves


    ///<summary>Create Curves that duplicate a Surface or Polysurface border.</summary>
    ///<param name="surfaceId">(Guid) Identifier of a Surface</param>
    ///<param name="typ">(int) Optional, default value: <c>0</c>
    ///    The border Curves to return
    ///    0 = both exterior and interior,
    ///    1 = exterior
    ///    2 = interior</param>
    ///<returns>(Guid ResizeArray) list of Curve ids .</returns>
    static member DuplicateSurfaceBorder(surfaceId:Guid, [<OPT;DEF(0)>]typ:int) : Guid ResizeArray =
        let brep = RhinoScriptSyntax.CoerceBrep(surfaceId)
        let inner = typ = 0 || typ = 2
        let outer = typ = 0 || typ = 1
        let mutable curves = brep.DuplicateNakedEdgeCurves(outer, inner)
        if curves|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.DuplicateSurfaceBorder failed.  surfaceId:'%s' type:'%d'" (Nice.str surfaceId) typ
        let tolerance = State.Doc.ModelAbsoluteTolerance * 2.1
        curves <- Curve.JoinCurves(curves, tolerance)
        if curves|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.DuplicateSurfaceBorder failed.  surfaceId:'%s' type:'%d'" (Nice.str surfaceId) typ
        let rc =  resizeArray { for c in curves do yield State.Doc.Objects.AddCurve(c) }
        State.Doc.Views.Redraw()
        rc


    ///<summary>Evaluates a Surface at a U, V parameter.</summary>
    ///<param name="surfaceId">(Guid) The object's identifier</param>
    ///<param name="u">(float) U of u, v parameters to evaluate</param>
    ///<param name="v">(float) V of u, v parameters to evaluate</param>
    ///<returns>(Point3d) a 3-D point.</returns>
    static member EvaluateSurface( surfaceId:Guid,
                                   u:float ,
                                   v:float ) : Point3d =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let rc = surface.PointAt(u, v)
        if rc.IsValid then rc
        else RhinoScriptingException.Raise "RhinoScriptSyntax.EvaluateSurface failed.  surfaceId:'%s' u:'%f' v:'%f'" (Nice.str surfaceId) u v


    ///<summary>Lengthens an untrimmed Surface object.</summary>
    ///<param name="surfaceId">(Guid) Identifier of a Surface</param>
    ///<param name="parameter">(float * float) Tuple of two values defining the U, V parameter to evaluate.
    ///    The Surface edge closest to the U, V parameter will be the edge that is
    ///    extended</param>
    ///<param name="length">(float) Amount to extend to Surface</param>
    ///<param name="smooth">(bool) Optional, default value: <c>true</c>
    ///    If True, the Surface is extended smoothly curving from the
    ///    edge. If False, the Surface is extended in a straight line from the edge</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member ExtendSurface( surfaceId:Guid,
                                 parameter:float * float,
                                 length:float,
                                 [<OPT;DEF(true)>]smooth:bool) : bool =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let edge = surface.ClosestSide(parameter|> fst, parameter|> snd)
        let newsrf = surface.Extend(edge, length, smooth)
        if notNull newsrf then
            State.Doc.Objects.Replace(surfaceId, newsrf)|> ignore
            State.Doc.Views.Redraw()
        else
            ()
        notNull newsrf

    ///<summary>Explodes, or un-joins, one or more Polysurface objects. Polysurfaces
    ///    will be exploded into separate Surfaces.</summary>
    ///<param name="objectIds">(Guid seq) Identifiers of Polysurfaces to explode</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>false</c>
    ///    Delete input objects after exploding</param>
    ///<returns>(Guid ResizeArray) List of identifiers of exploded pieces .</returns>
    static member ExplodePolysurfaces(objectIds:Guid seq, [<OPT;DEF(false)>]deleteInput:bool) : Guid ResizeArray =
        let ids = ResizeArray()
        for objectId in objectIds do
            let brep = RhinoScriptSyntax.CoerceBrep(objectId)
            if brep.Faces.Count>1 then
                for i = 0 to brep.Faces.Count - 1 do
                    let copyface = brep.Faces.[i].DuplicateFace(false)
                    let faceid = State.Doc.Objects.AddBrep(copyface)
                    if faceid <> Guid.Empty then ids.Add(faceid)
                if  deleteInput then State.Doc.Objects.Delete(objectId, true) |> ignore
        State.Doc.Views.Redraw()
        ids


    ///<summary>Extracts iso-parametric Curves from a Surface.</summary>
    ///<param name="surfaceId">(Guid) Identifier of a Surface</param>
    ///<param name="parameter">(float * float) U, v parameter of the Surface to evaluate</param>
    ///<param name="direction">(int) Direction to evaluate
    ///    0 = u
    ///    1 = v
    ///    2 = both</param>
    ///<returns>(Guid ResizeArray) List of Curve ids .</returns>
    static member ExtractIsoCurve( surfaceId:Guid,
                                   parameter:float * float,
                                   direction:int) : Guid ResizeArray =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let ids = ResizeArray()
        let mutable curves = [| |]
        if direction = 0 || direction = 2 then

            match surface with
            | :? BrepFace as br ->
                curves <- br.TrimAwareIsoCurve(0, parameter|> snd)
            | _ ->
                curves <- [|surface.IsoCurve(0, parameter|> snd) |]
            if notNull curves then
                for curve in curves do
                    let objectId = State.Doc.Objects.AddCurve(curve)
                    if objectId <> Guid.Empty then ids.Add(objectId)

        if direction = 1 || direction = 2 then
            curves <- null
            match surface with
            | :? BrepFace as br ->
                curves <- br.TrimAwareIsoCurve(1, parameter|> fst)
            | _ ->
                curves <- [|surface.IsoCurve(1, parameter|> fst)|]
            if notNull curves then
                for curve in curves do
                    let objectId = State.Doc.Objects.AddCurve(curve)
                    if objectId <> Guid.Empty then ids.Add(objectId)
        State.Doc.Views.Redraw()
        ids


    ///<summary>Separates or copies a Surface or a copy of a Surface from a Polysurface.</summary>
    ///<param name="objectId">(Guid) Polysurface identifier</param>
    ///<param name="faceIndices">(int seq) One or more numbers representing faces</param>
    ///<param name="copy">(bool) Optional, default value: <c>false</c>
    ///    If True the faces are copied. If False, the faces are extracted</param>
    ///<returns>(Guid ResizeArray) identifiers of extracted Surface objects .</returns>
    static member ExtractSurface( objectId:Guid,
                                  faceIndices:int seq,
                                  [<OPT;DEF(false)>]copy:bool) : Guid ResizeArray =
        let brep = RhinoScriptSyntax.CoerceBrep(objectId)
        let rc = ResizeArray()
        let faceIndices = Seq.sort(faceIndices)|> Seq.rev
        for index in faceIndices do
            let face = brep.Faces.[index]
            let newbrep = face.DuplicateFace(true)
            let objectId = State.Doc.Objects.AddBrep(newbrep)
            rc.Add(objectId)
        if copy then
            for index in faceIndices do brep.Faces.RemoveAt(index)
            State.Doc.Objects.Replace(objectId, brep)|> ignore
        State.Doc.Views.Redraw()
        rc


    ///<summary>Creates a Surface by extruding a Curve along a path.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve to extrude</param>
    ///<param name="pathId">(Guid) Identifier of the path Curve</param>
    ///<returns>(Guid) identifier of new Surface .</returns>
    static member ExtrudeCurve(curveId:Guid, pathId:Guid) : Guid =
        let curve1 = RhinoScriptSyntax.CoerceCurve(curveId)
        let curve2 = RhinoScriptSyntax.CoerceCurve(pathId)
        let srf = SumSurface.Create(curve1, curve2)
        let rc = State.Doc.Objects.AddSurface(srf)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.ExtrudeCurve failed. curveId:'%s' pathId:'%s'" (Nice.str curveId) <| Nice.str pathId
        State.Doc.Views.Redraw()
        rc


    ///<summary>Creates a Surface by extruding a Curve to a point.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve to extrude</param>
    ///<param name="point">(Point3d) 3D point</param>
    ///<returns>(Guid) identifier of new Surface .</returns>
    static member ExtrudeCurvePoint(curveId:Guid, point:Point3d) : Guid =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        //point = RhinoScriptSyntax.Coerce3dPoint(point)
        let srf = Surface.CreateExtrusionToPoint(curve, point)
        let rc = State.Doc.Objects.AddSurface(srf)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.ExtrudeCurvePoint failed. curveId:'%s' point:'%A'" (Nice.str curveId) point
        State.Doc.Views.Redraw()
        rc


    ///<summary>Create Surface by extruding a Curve along two points that define a line.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve to extrude</param>
    ///<param name="startPoint">(Point3d) Start point</param>
    ///<param name="endPoint">(Point3d) End point, that specifies distance and direction</param>
    ///<returns>(Guid) identifier of new Surface .</returns>
    static member ExtrudeCurveStraight( curveId:Guid,
                                        startPoint:Point3d,
                                        endPoint:Point3d) : Guid =
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        //startPoint = RhinoScriptSyntax.Coerce3dPoint(startPoint)
        //endPoint = RhinoScriptSyntax.Coerce3dPoint(endPoint)
        let vec = endPoint - startPoint
        let srf = Surface.CreateExtrusion(curve, vec)
        let rc = State.Doc.Objects.AddSurface(srf)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.ExtrudeCurveStraight failed. curveId:'%s' startPoint:'%A' endPoint:'%A'" (Nice.str curveId) startPoint endPoint
        State.Doc.Views.Redraw()
        rc


    ///<summary>Create Surface by extruding along a path Curve.</summary>
    ///<param name="surfaceId">(Guid) Identifier of the Surface to extrude</param>
    ///<param name="curveId">(Guid) Identifier of the path Curve</param>
    ///<param name="cap">(bool) Optional, default value: <c>true</c>
    ///    Extrusion is capped at both ends</param>
    ///<returns>(Guid) identifier of new Surface .</returns>
    static member ExtrudeSurface( surfaceId:Guid,
                                  curveId:Guid,
                                  [<OPT;DEF(true)>]cap:bool) : Guid =
        let brep = RhinoScriptSyntax.CoerceBrep(surfaceId)
        let curve = RhinoScriptSyntax.CoerceCurve(curveId)
        let newbrep = brep.Faces.[0].CreateExtrusion(curve, cap)
        if notNull newbrep then
            let rc = State.Doc.Objects.AddBrep(newbrep)
            State.Doc.Views.Redraw()
            rc
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.ExtrudeSurface failed on Surface: %s and Curve %s" (Nice.str surfaceId)  (Nice.str curveId)


    ///<summary>Create constant radius rolling ball fillets between two Surfaces. Note,
    ///    this function does not trim the original Surfaces of the fillets.</summary>
    ///<param name="surface0">(Guid) first Surface</param>
    ///<param name="surface1">(Guid) second Surface</param>
    ///<param name="radius">(float) A positive fillet radius</param>
    ///<param name="uvparam0">(Point2d) Optional, A u, v Surface parameter of Surface0 near where the fillet
    ///    is expected to hit the Surface</param>
    ///<param name="uvparam1">(Point2d) Optional, Same as uvparam0, but for Surface1</param>
    ///<returns>(Guid ResizeArray) ids of Surfaces created .</returns>
    static member FilletSurfaces( surface0:Guid,
                                  surface1:Guid,
                                  radius:float,
                                  [<OPT;DEF(Point2d())>]uvparam0:Point2d,
                                  [<OPT;DEF(Point2d())>]uvparam1:Point2d) : Guid ResizeArray=
        let surface0 = RhinoScriptSyntax.CoerceSurface(surface0)
        let surface1 = RhinoScriptSyntax.CoerceSurface(surface1)
        let tol = State.Doc.ModelAbsoluteTolerance
        let surfaces =
            if uvparam0<>Point2d.Origin && uvparam1<>Point2d.Origin then
                Surface.CreateRollingBallFillet(surface0, uvparam0, surface1, uvparam1, radius, tol)
            else
                Surface.CreateRollingBallFillet(surface0, surface1, radius, tol)
        if isNull surfaces then RhinoScriptingException.Raise "RhinoScriptSyntax.FilletSurfaces failed.  surface0:'%A' surface1:'%A' radius:'%A' uvparam0:'%A' uvparam1:'%A'" surface0 surface1 radius uvparam0 uvparam1
        let rc = ResizeArray()
        for surf in surfaces do
            rc.Add( State.Doc.Objects.AddSurface(surf))
        State.Doc.Views.Redraw()
        rc


    ///<summary>Returns the normal direction of a Surface. This feature can
    /// also be found in Rhino's Dir command.</summary>
    ///<param name="surfaceId">(Guid) Identifier of a Surface object</param>
    ///<returns>(bool) The current normal orientation.</returns>
    static member IsSurfaceFliped(surfaceId:Guid) : bool = //GET
        let brep = RhinoScriptSyntax.CoerceBrep(surfaceId)
        if brep.Faces.Count>1 then RhinoScriptingException.Raise "RhinoScriptSyntax.IsSurfaceFliped failed. surfaceId:'%s'" (Nice.str surfaceId)
        let face = brep.Faces.[0]
        face.OrientationIsReversed

    ///<summary>Changes the normal direction of a Surface. This feature can
    /// also be found in Rhino's Dir command.
    /// Use RhinoScriptSyntax.IsSurfaceFliped to get State.</summary>
    ///<param name="surfaceId">(Guid) Identifier of a Surface object</param>
    ///<param name="flip">(bool) New normal orientation, either flipped(True) or not flipped (False)</param>
    ///<returns>(unit) void, nothing.</returns>
    static member FlipSurface(surfaceId:Guid, flip:bool) : unit = //SET
        let brep = RhinoScriptSyntax.CoerceBrep(surfaceId)
        if brep.Faces.Count>1 then RhinoScriptingException.Raise "RhinoScriptSyntax.FlipSurface failed. surfaceId:'%s' flip:'%A'" (Nice.str surfaceId) flip
        let face = brep.Faces.[0]
        let oldreverse = face.OrientationIsReversed
        if brep.IsSolid = false && oldreverse <> flip then
            brep.Flip()
            State.Doc.Objects.Replace(surfaceId, brep)|> ignore
            State.Doc.Views.Redraw()

    ///<summary>Changes the normal direction of multiple Surface. This feature can
    /// also be found in Rhino's Dir command.
    /// Use RhinoScriptSyntax.IsSurfaceFliped to get State.</summary>
    ///<param name="surfaceIds">(Guid seq) Identifiers of multiple Surface objects</param>
    ///<param name="flip">(bool) New normal orientation, either flipped(True) or not flipped (False)</param>
    ///<returns>(unit) void, nothing.</returns>
    static member FlipSurface(surfaceIds:Guid seq, flip:bool) : unit = //MULTISET
        for surfaceId in surfaceIds do
            let brep = RhinoScriptSyntax.CoerceBrep(surfaceId)
            if brep.Faces.Count>1 then RhinoScriptingException.Raise "RhinoScriptSyntax.FlipSurface failed.  surfaceId:'%s' flip:'%A'" (Nice.str surfaceId) flip
            let face = brep.Faces.[0]
            let oldreverse = face.OrientationIsReversed
            if brep.IsSolid = false && oldreverse <> flip then
                brep.Flip()
                State.Doc.Objects.Replace(surfaceId, brep)|> ignore
        State.Doc.Views.Redraw()


    ///<summary>Intersects a brep object with another brep object. Note, unlike the
    ///    SurfaceSurfaceIntersection function this function works on trimmed Surfaces.</summary>
    ///<param name="brep1">(Guid) Identifier of first brep object</param>
    ///<param name="brep2">(Guid) Identifier of second brep object</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c>
    ///    Distance tolerance at segment midpoints. If omitted,
    ///    the current absolute tolerance is used</param>
    ///<returns>(Guid ResizeArray) identifying the newly created intersection Curve and point objects.</returns>
    static member IntersectBreps( brep1:Guid,
                                  brep2:Guid,
                                  [<OPT;DEF(0.0)>]tolerance:float) : Guid ResizeArray =
        let brep1 = RhinoScriptSyntax.CoerceBrep(brep1)
        let brep2 = RhinoScriptSyntax.CoerceBrep(brep2)
        let tolerance = Util.ifZero2 State.Doc.ModelAbsoluteTolerance  tolerance
        let ok, outcurves, outpoints = Intersect.Intersection.BrepBrep(brep1, brep2, tolerance)
        let ids = ResizeArray()
        if not ok then ids // empty array TODO or fail ?
        else
            let mergedcurves = Curve.JoinCurves(outcurves, 2.1 * tolerance)

            if notNull mergedcurves then
                for curve in mergedcurves do
                    if curve.IsValid then
                        let rc = State.Doc.Objects.AddCurve(curve)
                        curve.Dispose()
                        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.IntersectBreps failed.  brep1:'%A' brep2:'%A' tolerance:'%A'" brep1 brep2 tolerance
                        ids.Add(rc)
            else
                for curve in outcurves do
                    if curve.IsValid then
                        let rc = State.Doc.Objects.AddCurve(curve)
                        curve.Dispose()
                        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.IntersectBreps failed.  brep1:'%A' brep2:'%A' tolerance:'%A'" brep1 brep2 tolerance
                        ids.Add(rc)
            for point in outpoints do
                let rc = State.Doc.Objects.AddPoint(point)
                if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.IntersectBreps failed.  brep1:'%A' brep2:'%A' tolerance:'%A'" brep1 brep2 tolerance
                ids.Add(rc)
            State.Doc.Views.Redraw()
            ids


    ///<summary>Calculates intersections of two spheres.</summary>
    ///<param name="spherePlane0">(Plane) An equatorial Plane of the first sphere. The origin of the
    ///    Plane will be the center point of the sphere</param>
    ///<param name="sphereRadius0">(float) Radius of the first sphere</param>
    ///<param name="spherePlane1">(Plane) Plane for second sphere</param>
    ///<param name="sphereRadius1">(float) Radius for second sphere</param>
    ///<returns>(int * Circle * float ) of intersection results
    ///    [0] = type of intersection (0 = point, 1 = circle, 2 = spheres are identical)
    ///    [1] = Circle of  intersection , if type is Point take Circle center
    ///    [2] = radius of circle if circle intersection.</returns>
    static member IntersectSpheres( spherePlane0:Plane,
                                    sphereRadius0:float,
                                    spherePlane1:Plane,
                                    sphereRadius1:float) : int * Circle * float =
        let sphere0 = Sphere(spherePlane0, sphereRadius0)
        let sphere1 = Sphere(spherePlane1, sphereRadius1)
        let rc, circle = Intersect.Intersection.SphereSphere(sphere0, sphere1)
        if rc = Intersect.SphereSphereIntersection.Point then
            0, circle, 0.0
        elif rc = Intersect.SphereSphereIntersection.Circle then
            1, circle, circle.Radius
        elif rc = Intersect.SphereSphereIntersection.Overlap then
            2, circle, sphere0.Radius
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.IntersectSpheres failed.  spherePlane0:'%A' sphereRadius0:'%A' spherePlane1:'%A' sphereRadius1:'%A'" spherePlane0 sphereRadius0 spherePlane1 sphereRadius1



    ///<summary>Determines if a Surface is a portion of a cone.</summary>
    ///<param name="objectId">(Guid) The Surface object's identifier</param>
    ///<returns>(bool) True , otherwise False.</returns>
    static member IsCone(objectId:Guid) : bool =
        let surface = RhinoScriptSyntax.CoerceSurface(objectId)
        surface.IsCone()


    ///<summary>Determines if a Surface is a portion of a cone.</summary>
    ///<param name="objectId">(Guid) The cylinder object's identifier</param>
    ///<returns>(bool) True , otherwise False.</returns>
    static member IsCylinder(objectId:Guid) : bool =
        let surface = RhinoScriptSyntax.CoerceSurface(objectId)
        surface.IsCylinder()


    ///<summary>Verifies an object is a Plane Surface. Plane Surfaces can be created by
    ///    the Plane command. Note, a Plane Surface is not a planar NURBS Surface.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True , otherwise False.</returns>
    static member IsPlaneSurface(objectId:Guid) : bool =
        let face = RhinoScriptSyntax.CoerceSurface(objectId)
        match face with
        | :? BrepFace  as bface ->
            if bface.IsSurface then
                match bface.UnderlyingSurface() with
                | :?  PlaneSurface -> true
                | _ -> false
            else
                false
        | _ -> false


    ///<summary>Checks if a point is inside a closed Mesh , Surface or Polysurface.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<param name="point">(Point3d) The test, or sampling point</param>
    ///<param name="strictlyIn">(bool) Optional, default value: <c>false</c>
    ///    If true, the test point must be inside by at least tolerance</param>
    ///<param name="tolerance">(float) Optional, default value: <c>RhinoMath.SqrtEpsilon</c>
    ///    Distance tolerance used for intersection and determining
    ///    strict inclusion.</param>
    ///<returns>(bool) True , otherwise False.</returns>
    static member IsPointInSurface( objectId:Guid,
                                    point:Point3d,
                                    [<OPT;DEF(false)>]strictlyIn:bool,
                                    [<OPT;DEF(0.0)>]tolerance:float) : bool =
        //objectId = RhinoScriptSyntax.CoerceGuid(objectId)
        //point = RhinoScriptSyntax.Coerce3dPoint(point)
        //if objectId|> isNull  || point|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.IsPointInSurface failed.  objectId:'%s' point:'%A' strictlyIn:'%A' tolerance:'%A'" (Nice.str objectId) point strictlyIn tolerance
        let obj = State.Doc.Objects.FindId(objectId)
        let  tolerance= Util.ifZero1 tolerance RhinoMath.SqrtEpsilon
        match obj with
        | :? DocObjects.ExtrusionObject as es->
            let brep= es.ExtrusionGeometry.ToBrep(false)
            if not brep.IsSolid then RhinoScriptingException.Raise "RhinoScriptSyntax.IsPointInSurface failed on not closed Extrusion %A"  objectId
            brep.IsPointInside(point, tolerance, strictlyIn)
        | :? DocObjects.BrepObject as bo->
            let br= bo.BrepGeometry
            if not br.IsSolid then RhinoScriptingException.Raise "RhinoScriptSyntax.IsPointInSurface failed on not closed Brep %A"  objectId
            br.IsPointInside(point, tolerance, strictlyIn)
        | :? DocObjects.MeshObject as mo ->
            let me = mo.MeshGeometry
            if not me.IsClosed then RhinoScriptingException.Raise "RhinoScriptSyntax.IsPointInSurface failed on not closed Mesh %A"  objectId
            me.IsPointInside(point, tolerance, strictlyIn)
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.IsPointInSurface does not work  on %s %A" (RhinoScriptSyntax.ObjectDescription(objectId)) objectId

    ///<summary>Checks if a point lies on a Surface.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<param name="point">(Point3d) The test, or sampling point</param>
    ///<returns>(bool) True , otherwise False.</returns>
    static member IsPointOnSurface(objectId:Guid, point:Point3d) : bool =
        let surf = RhinoScriptSyntax.CoerceSurface(objectId)
        //point = RhinoScriptSyntax.Coerce3dPoint(point)
        let mutable rc, u, v = surf.ClosestPoint(point)
        if rc  then
            let srfpt = surf.PointAt(u, v)
            if srfpt.DistanceTo(point) > State.Doc.ModelAbsoluteTolerance then
                rc <- false
            else
                match RhinoScriptSyntax.TryCoerceBrep(objectId) with
                | Some b ->
                    rc <- b.Faces.[0].IsPointOnFace(u, v) <> PointFaceRelation.Exterior
                | _ -> ()
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.IsPointOnSurface failed for surf.ClosestPoint on %A %A" (Nice.str objectId) point
        rc


    ///<summary>Verifies an object is a Polysurface or Extrusion. Polysurfaces consist of two or more Surfaces joined together.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True if successful, otherwise False.</returns>
    static member IsPolysurface(objectId:Guid) : bool =
        match State.Doc.Objects.FindId(objectId) with
        | null -> RhinoScriptingException.Raise "RhinoScriptSyntax.IsPolysurface: %A is not an object in State.Doc.Objects table" objectId
        | o ->  match o.Geometry with
                | :? Brep as b -> b.Faces.Count > 1
                | :? Extrusion  -> true
                | _ -> false

    ///<summary>Verifies an object is a or Extrusion. </summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True if successful, otherwise False.</returns>
    static member IsExtrusion(objectId:Guid) : bool =
        match State.Doc.Objects.FindId(objectId) with
        | null -> RhinoScriptingException.Raise "RhinoScriptSyntax.IsExtrusion: %A is not an object in State.Doc.Objects table" objectId
        | o ->  match o.Geometry with
                | :? Extrusion  -> true
                | _ -> false

    ///<summary>Verifies an object is a Brep. That is a trimmed surface or a polysurface but not an extrusion.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True if successful, otherwise False.</returns>
    static member IsBrep(objectId:Guid) : bool =
        match State.Doc.Objects.FindId(objectId) with
        | null -> RhinoScriptingException.Raise "RhinoScriptSyntax.IsBrep: %A is not an object in State.Doc.Objects table" objectId
        | o ->  match o.Geometry with
                | :? Brep  -> true
                | _ -> false



    ///<summary>Verifies a Guid refers to a closed Polysurface or closed Extrusion. If the Polysurface fully encloses
    ///    a volume, it is considered a solid.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True if successful, otherwise False.</returns>
    static member IsPolysurfaceClosed(objectId:Guid) : bool =
        match State.Doc.Objects.FindId(objectId) with
        | null -> RhinoScriptingException.Raise "RhinoScriptSyntax.IsPolysurfaceClosed: %A is not an object in State.Doc.Objects table" objectId
        | o ->  match o.Geometry with
                | :? Brep as b -> b.IsSolid
                | :? Extrusion as e -> e.IsSolid
                | _ -> false


    ///<summary>Determines if a Surface is a portion of a Sphere.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True , otherwise False.</returns>
    static member IsSphere(objectId:Guid) : bool =
        match RhinoScriptSyntax.TryCoerceSurface(objectId) with
        | Some b ->  b.IsSphere()
        | _ -> false



    ///<summary>Verifies an object is a Surface, Extrusion or Brep objects with only one face.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(bool) True , otherwise False.</returns>
    static member IsSurface(objectId:Guid) : bool =
        RhinoScriptSyntax.TryCoerceSurface(objectId).IsSome


    ///<summary>Verifies a Surface object is closed in the specified direction. If the
    ///    Surface fully encloses a volume, it is considered a solid.</summary>
    ///<param name="surfaceId">(Guid) Identifier of a Surface</param>
    ///<param name="direction">(int)
    ///    0 = U direction check,
    ///    1 = V direction check</param>
    ///<returns>(bool) True or False.</returns>
    static member IsSurfaceClosed(surfaceId:Guid, direction:int) : bool =
        match RhinoScriptSyntax.TryCoerceSurface(surfaceId) with
        | Some surface ->  surface.IsClosed(direction)
        | _ -> false


    ///<summary>Verifies a Surface object is periodic in the specified direction.</summary>
    ///<param name="surfaceId">(Guid) Identifier of a Surface</param>
    ///<param name="direction">(int)
    ///    0 = U direction check,
    ///    1 = V direction check</param>
    ///<returns>(bool) True or False.</returns>
    static member IsSurfacePeriodic(surfaceId:Guid, direction:int) : bool =
        match RhinoScriptSyntax.TryCoerceSurface(surfaceId) with
        | Some surface ->  surface.IsPeriodic(direction)
        | _ -> false



    ///<summary>Verifies a Surface object is planar.</summary>
    ///<param name="surfaceId">(Guid) Identifier of a Surface</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c>
    ///    Tolerance used when checked. If omitted, the current absolute
    ///    tolerance is used</param>
    ///<returns>(bool) True or False.</returns>
    static member IsSurfacePlanar(surfaceId:Guid, [<OPT;DEF(0.0)>]tolerance:float) : bool =
        let tolerance = Util.ifZero1 tolerance State.Doc.ModelAbsoluteTolerance
        match RhinoScriptSyntax.TryCoerceSurface(surfaceId) with
        | Some surface ->  surface.IsPlanar(tolerance)
        | _ -> false


    ///<summary>Verifies a Surface object is rational.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<returns>(bool) True , otherwise False.</returns>
    static member IsSurfaceRational(surfaceId:Guid) : bool =
        match RhinoScriptSyntax.TryCoerceSurface(surfaceId) with //TODO better fail if input is not a surface ?? here and above functions
        | Some surface ->
            let ns = surface.ToNurbsSurface()
            if ns|> isNull  then false
            else ns.IsRational
        | _ -> false


    ///<summary>Verifies a Surface object is singular in the specified direction.
    ///    Surfaces are considered singular if a side collapses to a point.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<param name="direction">(int)
    ///    0 = south
    ///    1 = east
    ///    2 = north
    ///    3 = west</param>
    ///<returns>(bool) True or False.</returns>
    static member IsSurfaceSingular(surfaceId:Guid, direction:int) : bool =
        match RhinoScriptSyntax.TryCoerceSurface(surfaceId) with    //TODO better fail if input is not a surface ?? here and above functions
        | Some surface ->
            surface.IsSingular(direction)
        | _ -> false


    ///<summary>Verifies a Surface object has been trimmed.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<returns>(bool) True or False.</returns>
    static member IsSurfaceTrimmed(surfaceId:Guid) : bool =
        match RhinoScriptSyntax.TryCoerceBrep(surfaceId) with
        | Some brep ->  not brep.IsSurface
        | _ -> false //TODO better fail if input is not a surface ?? here and above functions



    ///<summary>Determines if a Surface is a portion of a torus.</summary>
    ///<param name="surfaceId">(Guid) The Surface object's identifier</param>
    ///<returns>(bool) True , otherwise False.</returns>
    static member IsTorus(surfaceId:Guid) : bool =
        match RhinoScriptSyntax.TryCoerceSurface(surfaceId) with //TODO better fail if input is not a surface ?? here and above functions
        | Some surface ->  surface.IsTorus()
        | _ -> false


    ///<summary>Gets the sphere definition from a Surface, if possible.</summary>
    ///<param name="surfaceId">(Guid) The identifier of the Surface object</param>
    ///<returns>(Plane * float) The equatorial Plane of the sphere, and its radius.</returns>
    static member SurfaceSphere(surfaceId:Guid) : Plane * float =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let tol = State.Doc.ModelAbsoluteTolerance
        let sphere = ref Sphere.Unset
        let issphere = surface.TryGetSphere(sphere, tol)
        if issphere then (!sphere).EquatorialPlane, (!sphere).Radius
        else RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceSphere input is not a sphere %A"surfaceId


    ///<summary>Joins two or more Surface or Polysurface objects together to form one
    ///    Polysurface object.</summary>
    ///<param name="objectIds">(Guid seq) List of object identifiers</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>false</c>
    ///    Delete the original Surfaces</param>
    ///<returns>(Guid) identifier of newly created object.</returns>
    static member JoinSurfaces(objectIds:Guid seq, [<OPT;DEF(false)>]deleteInput:bool) : Guid =
        let breps =  resizeArray { for objectId in objectIds do yield RhinoScriptSyntax.CoerceBrep(objectId) }
        if breps.Count<2 then RhinoScriptingException.Raise "RhinoScriptSyntax.JoinSurfaces failed, less than two objects given.  objectIds:'%A' deleteInput:'%A'" (Nice.str objectIds) deleteInput
        let tol = State.Doc.ModelAbsoluteTolerance * 2.1
        let joinedbreps = Brep.JoinBreps(breps, tol)
        if joinedbreps|> isNull  then
            RhinoScriptingException.Raise "RhinoScriptSyntax.JoinSurfaces failed.  objectIds:'%A' deleteInput:'%A'" (Nice.str objectIds) deleteInput
        if joinedbreps.Length <> 1 then
            RhinoScriptingException.Raise "RhinoScriptSyntax.JoinSurfaces resulted in more than one object: %d  objectIds:'%A' deleteInput:'%A'" joinedbreps.Length objectIds deleteInput
        let rc = State.Doc.Objects.AddBrep(joinedbreps.[0])
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.JoinSurfaces failed.  objectIds:'%A' deleteInput:'%A'" (Nice.str objectIds) deleteInput
        if  deleteInput then
            for objectId in objectIds do
                //id = RhinoScriptSyntax.CoerceGuid(objectId)
                State.Doc.Objects.Delete(objectId, true) |> ignore
        State.Doc.Views.Redraw()
        rc


    ///<summary>Makes an existing Surface a periodic NURBS Surface.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<param name="direction">(int) The direction to make periodic, either
    ///    0 = U
    ///    1 = V</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>false</c>
    ///    Delete the input Surface</param>
    ///<returns>(Guid) if deleteInput is False, identifier of the new Surface.</returns>
    static member MakeSurfacePeriodic( surfaceId:Guid,
                                       direction:int,
                                       [<OPT;DEF(false)>]deleteInput:bool) : Guid =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let newsurf = Surface.CreatePeriodicSurface(surface, direction)
        if newsurf|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.MakeSurfacePeriodic failed.  surfaceId:'%s' direction:'%A' deleteInput:'%A'" (Nice.str surfaceId) direction deleteInput
        //id = RhinoScriptSyntax.CoerceGuid(surfaceId)
        if deleteInput then
            State.Doc.Objects.Replace(surfaceId, newsurf)|> ignore
            State.Doc.Views.Redraw()
            surfaceId
        else
            let objectIdn = State.Doc.Objects.AddSurface(newsurf)
            State.Doc.Views.Redraw()
            objectIdn


    ///<summary>Offsets a trimmed or untrimmed Surface by a distance. The offset Surface
    ///    will be added to Rhino.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<param name="distance">(float) The distance to offset</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c>
    ///    The offset tolerance. Use 0.0 to make a loose offset. Otherwise, the
    ///    document's absolute tolerance is usually sufficient</param>
    ///<param name="bothSides">(bool) Optional, default value: <c>false</c>
    ///    Offset to both sides of the input Surface</param>
    ///<param name="createSolid">(bool) Optional, default value: <c>false</c>
    ///    Make a solid object</param>
    ///<returns>(Guid) identifier of the new object.</returns>
    static member OffsetSurface( surfaceId:Guid,
                                 distance:float,
                                 [<OPT;DEF(0.0)>]tolerance:float,
                                 [<OPT;DEF(false)>]bothSides:bool,
                                 [<OPT;DEF(false)>]createSolid:bool) : Guid =
        let brep = RhinoScriptSyntax.CoerceBrep(surfaceId)
        let mutable face = null
        if (1 = brep.Faces.Count) then face <- brep.Faces.[0]
        if face|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.OffsetSurface failed.  surfaceId:'%s' distance:'%A' tolerance:'%A' bothSides:'%A' createSolid:'%A'" (Nice.str surfaceId) distance tolerance bothSides createSolid
        let tolerance= Util.ifZero1 tolerance State.Doc.ModelAbsoluteTolerance
        let newbrep = Brep.CreateFromOffsetFace(face, distance, tolerance, bothSides, createSolid)
        if newbrep|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.OffsetSurface failed.  surfaceId:'%s' distance:'%A' tolerance:'%A' bothSides:'%A' createSolid:'%A'" (Nice.str surfaceId) distance tolerance bothSides createSolid
        let rc = State.Doc.Objects.AddBrep(newbrep)
        if rc = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.OffsetSurface failed.  surfaceId:'%s' distance:'%A' tolerance:'%A' bothSides:'%A' createSolid:'%A'" (Nice.str surfaceId) distance tolerance bothSides createSolid
        State.Doc.Views.Redraw()
        rc


    ///<summary>Pulls a Curve object to a Surface object.</summary>
    ///<param name="surface">(Guid) The Surface's identifier</param>
    ///<param name="curve">(Guid) The Curve's identifier</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>false</c>
    ///    Should the input items be deleted</param>
    ///<returns>(Guid ResizeArray) List of new Curves.</returns>
    static member PullCurve( surface:Guid,
                             curve:Guid,
                             [<OPT;DEF(false)>]deleteInput:bool) : Guid ResizeArray =
        let crvobj = RhinoScriptSyntax.CoerceRhinoObject(curve)
        let brep = RhinoScriptSyntax.CoerceBrep(surface)
        let curve = RhinoScriptSyntax.CoerceCurve(curve)
        let tol = State.Doc.ModelAbsoluteTolerance
        let curves = Curve.PullToBrepFace(curve, brep.Faces.[0], tol)
        let rc =  resizeArray { for curve in curves do yield State.Doc.Objects.AddCurve(curve) }
        if deleteInput  then
            State.Doc.Objects.Delete(crvobj, true) |> ignore
        State.Doc.Views.Redraw()
        rc


    ///<summary>Rebuilds a Surface to a given degree and control point count. For more
    ///    information see the Rhino help file for the Rebuild command.</summary>
    ///<param name="objectId">(Guid) The Surface's identifier</param>
    ///<param name="degreeU">(int) Optional, default value: <c>3</c> degree of the Surface in the U directions</param>
    ///<param name="degreeV">(int) Optional, default value: <c>3</c> degree of the Surface in the V directions</param>
    ///<param name="pointcountU">(int) Optional, default value: <c>10*</c> the Surface point count in U  directions</param>
    ///<param name="pointcountV">(int) Optional, default value: <c>10*</c> the Surface point count in V  directions</param>
    ///<returns>(bool) True of False indicating success or failure.</returns>
    static member RebuildSurface( objectId:Guid,
                                  [<OPT;DEF(3)>]degreeU:int,
                                  [<OPT;DEF(3)>]degreeV:int,
                                  [<OPT;DEF(10)>]pointcountU:int ,
                                  [<OPT;DEF(10)>]pointcountV:int ) : bool =

        let surface = RhinoScriptSyntax.CoerceSurface(objectId)
        let newsurf = surface.Rebuild( degreeU, degreeV, pointcountU, pointcountV )
        if newsurf|> isNull  then false
        else
            //objectId = RhinoScriptSyntax.CoerceGuid(objectId)
            let rc = State.Doc.Objects.Replace(objectId, newsurf)
            if rc then State.Doc.Views.Redraw()
            rc


    ///<summary>Deletes a knot from a Surface object.</summary>
    ///<param name="surface">(Guid) The reference of the Surface object</param>
    ///<param name="uvParameter">(float * float)) An indexable item containing a U, V parameter on the Surface. List, tuples and UVIntervals will work.
    ///    Note, if the parameter is not equal to one of the existing knots, then the knot closest to the specified parameter will be removed</param>
    ///<param name="vDirection">(bool) If True, or 1, the V direction will be addressed. If False, or 0, the U direction</param>
    ///<returns>(bool) True of False indicating success or failure.</returns>
    static member RemoveSurfaceKnot( surface:Guid,
                                     uvParameter:float * float,
                                     vDirection:bool) : bool =
        let srfinst = RhinoScriptSyntax.CoerceSurface(surface)
        let uparam = uvParameter|> fst
        let vparam = uvParameter|> snd
        let success, nuparam, nvparam = srfinst.GetSurfaceParameterFromNurbsFormParameter(uparam, vparam)
        if not success then false
        else
            let nsrf = srfinst.ToNurbsSurface()
            if isNull nsrf then false
            else
                let knots = if vDirection then nsrf.KnotsV  else nsrf.KnotsU
                let success = knots.RemoveKnotsAt(nuparam, nvparam)
                if not success then false
                else
                    State.Doc.Objects.Replace(surface, nsrf)|> ignore
                    State.Doc.Views.Redraw()
                    true


    ///<summary>Reverses U or V directions of a Surface, or swaps (transposes) U and V
    ///    directions.</summary>
    ///<param name="surfaceId">(Guid) Identifier of a Surface object</param>
    ///<param name="direction">(int) As a bit coded flag to swap
    ///    1 = reverse U
    ///    2 = reverse V
    ///    4 = transpose U and V (values can be combined)</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ReverseSurface(surfaceId:Guid, direction:int) : unit =
        let brep = RhinoScriptSyntax.CoerceBrep(surfaceId)
        if brep.Faces.Count <> 1 then RhinoScriptingException.Raise "RhinoScriptSyntax.ReverseSurface failed.  surfaceId:'%s' direction:'%A'" (Nice.str surfaceId) direction
        let face = brep.Faces.[0]
        if direction &&& 1 <> 0 then            face.Reverse(0, true)|> ignore
        if direction &&& 2 <> 0 then            face.Reverse(1, true)|> ignore
        if direction &&& 4 <> 0 then            face.Transpose(true) |> ignore
        State.Doc.Objects.Replace(surfaceId, brep)|> ignore
        State.Doc.Views.Redraw()



    ///<summary>Shoots a ray at a collection of Surfaces or Polysurfaces.</summary>
    ///<param name="surfaceIds">(Guid seq) One of more Surface identifiers</param>
    ///<param name="startPoint">(Point3d) Starting point of the ray</param>
    ///<param name="direction">(Vector3d) Vector identifying the direction of the ray</param>
    ///<param name="reflections">(int) Optional, default value: <c>10</c>
    ///    The maximum number of times the ray will be reflected</param>
    ///<returns>(Point3d array) Array of reflection points.</returns>
    static member ShootRay( surfaceIds:Guid seq,
                            startPoint:Point3d,
                            direction:Vector3d,
                            [<OPT;DEF(10)>]reflections:int) : Point3d array =
        //startPoint = RhinoScriptSyntax.Coerce3dPoint(startPoint)
        //direction = RhinoScriptSyntax.Coerce3dvector(direction)
        //id = RhinoScriptSyntax.CoerceGuid(surfaceIds)
        //if notNull objectId then surfaceIds <- .[id]
        let ray = Ray3d(startPoint, direction)
        let breps = resizeArray {for objectId in surfaceIds do RhinoScriptSyntax.CoerceBrep(objectId)}
        if breps.Count = 0 then RhinoScriptingException.Raise "RhinoScriptSyntax.ShootRay failed.  surfaceIds:'%A' startPoint:'%A' direction:'%A' reflections:'%A'"  surfaceIds startPoint direction reflections
        Intersect.Intersection.RayShoot(ray, Seq.cast breps, reflections)



    ///<summary>Creates the shortest possible Curve(geodesic) between two points on a
    ///    Surface. For more details, see the ShortPath command in Rhino help.</summary>
    ///<param name="surfaceId">(Guid) Identifier of a Surface</param>
    ///<param name="startPoint">(Point3d) Start point the short Curve</param>
    ///<param name="endPoint">(Point3d) End point of the short Curve</param>
    ///<returns>(Guid) identifier of the new Surface.</returns>
    static member ShortPath( surfaceId:Guid,
                             startPoint:Point3d,
                             endPoint:Point3d) : Guid =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        //start = RhinoScriptSyntax.Coerce3dPoint(startPoint)
        //end = RhinoScriptSyntax.Coerce3dPoint(endPoint)
        let rcstart, ustart, vstart = surface.ClosestPoint(startPoint)
        let rcend, uend, vend = surface.ClosestPoint(endPoint)
        if not rcstart || not rcend then RhinoScriptingException.Raise "RhinoScriptSyntax.ShortPath failed.  surfaceId:'%s' startPoint:'%A' endPoint:'%A'" (Nice.str surfaceId) startPoint endPoint
        let start = Point2d(ustart, vstart)
        let ende = Point2d(uend, vend)
        let tolerance = State.Doc.ModelAbsoluteTolerance
        let curve = surface.ShortPath(start, ende, tolerance)
        if curve|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.ShortPath failed.  surfaceId:'%s' startPoint:'%A' endPoint:'%A'" (Nice.str surfaceId) startPoint endPoint
        let objectId = State.Doc.Objects.AddCurve(curve)
        if objectId = Guid.Empty then RhinoScriptingException.Raise "RhinoScriptSyntax.ShortPath failed.  surfaceId:'%s' startPoint:'%A' endPoint:'%A'" (Nice.str surfaceId) startPoint endPoint
        State.Doc.Views.Redraw()
        objectId


    ///<summary>Shrinks the underlying untrimmed Surfaces near to the trimming
    ///    boundaries. See the ShrinkTrimmedSrf command in the Rhino help.</summary>
    ///<param name="objectId">(Guid) The Surface's identifier</param>
    ///<param name="createCopy">(bool) Optional, default value: <c>false</c>
    ///    If True, the original Surface is not deleted</param>
    ///<returns>(Guid) If createCopy is true the new Guid, else the input Guid.</returns>
    static member ShrinkTrimmedSurface(objectId:Guid, [<OPT;DEF(false)>]createCopy:bool) : Guid =
        let brep = RhinoScriptSyntax.CoerceBrep(objectId)
        if brep.Faces.ShrinkFaces() then RhinoScriptingException.Raise "RhinoScriptSyntax.ShrinkTrimmedSurface failed.  objectId:'%s' createCopy:'%A'" (Nice.str objectId) createCopy
        if  createCopy then
            let oldobj = State.Doc.Objects.FindId(objectId)
            let attr = oldobj.Attributes
            let rc = State.Doc.Objects.AddBrep(brep, attr)
            State.Doc.Views.Redraw()
            rc
        else
            State.Doc.Objects.Replace(objectId, brep)|> ignore
            State.Doc.Views.Redraw()
            objectId




    ///<summary>Splits a brep.</summary>
    ///<param name="brepId">(Guid) Identifier of the brep to split</param>
    ///<param name="cutterId">(Guid) Identifier of the brep to split with</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>false</c>
    ///    Delete input breps</param>
    ///<returns>(Guid ResizeArray) identifiers of split pieces.</returns>
    static member SplitBrep( brepId:Guid,
                             cutterId:Guid,
                             [<OPT;DEF(false)>]deleteInput:bool) : Guid ResizeArray =
        let brep = RhinoScriptSyntax.CoerceBrep(brepId)
        let cutter = RhinoScriptSyntax.CoerceBrep(cutterId)
        let tol = State.Doc.ModelAbsoluteTolerance
        let pieces = brep.Split(cutter, tol)
        if isNull pieces then RhinoScriptingException.Raise "RhinoScriptSyntax.SplitBrep failed.  brepId:'%s' cutterId:'%s' deleteInput:'%A'" (Nice.str brepId) (Nice.str cutterId) deleteInput
        if deleteInput then
            //brepId = RhinoScriptSyntax.CoerceGuid(brepId)
            State.Doc.Objects.Delete(brepId, true) |> ignore
        let rc =  resizeArray { for piece in pieces do yield State.Doc.Objects.AddBrep(piece) }
        State.Doc.Views.Redraw()
        rc


    ///<summary>Calculate the area of a Surface Geometry.
    /// The results are based on the current drawing units.</summary>
    ///<param name="srf">(Geometry.Surface) The Surface geometry</param>
    ///<returns>(float) of area.</returns>
    static member SurfaceArea(srf:Surface) : float  =
        let amp =AreaMassProperties.Compute(srf, area=true, firstMoments=false, secondMoments=false, productMoments=false)
        if isNull amp then  RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceArea failed on Surface: %A" srf
        amp.Area


    ///<summary>Calculate the area of a Brep / Polysurface  Geometry.
    /// The results are based on the current drawing units.</summary>
    ///<param name="brep">(Geometry.Brep) The Polysurface geometry</param>
    ///<returns>(float) of area.</returns>
    static member SurfaceArea(brep:Brep) : float  =
        let amp = AreaMassProperties.Compute(brep, area=true, firstMoments=false, secondMoments=false, productMoments=false)
        if isNull amp then  RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceArea failed on Brep: %A" brep
        amp.Area

    ///<summary>Calculate the area of a Surface or Polysurface object.
    /// The results are based on the current drawing units.</summary>
    ///<param name="objectId">(Guid) The Surface's identifier</param>
    ///<returns>(float) of area.</returns>
    static member SurfaceArea(objectId:Guid) : float  =
        match RhinoScriptSyntax.CoerceGeometry objectId with
        | :? Surface as s -> RhinoScriptSyntax.SurfaceArea s
        | :? Brep    as b -> RhinoScriptSyntax.SurfaceArea b
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceArea doesnt work on on %A" (Nice.str  objectId)


    ///<summary>Calculates the area centroid of a Surface or Polysurface.</summary>
    ///<param name="objectId">(Guid) The Surface's identifier</param>
    ///<returns>(Point3d ) Area centroid.</returns>
    static member SurfaceAreaCentroid(objectId:Guid) : Point3d =
        objectId
        |> RhinoScriptSyntax.TryCoerceBrep
        |> Option.map AreaMassProperties.Compute
        |> Option.orElseWith (fun () ->
            objectId
            |> RhinoScriptSyntax.TryCoerceSurface
            |> Option.map AreaMassProperties.Compute
            )
        |> Option.defaultWith (fun () -> RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceAreaCentroid failed.  objectId:'%s'" (Nice.str objectId))
        |> fun amp -> amp.Centroid


    ///<summary>Calculates area moments of inertia of a Surface or Polysurface object.
    ///    See the Rhino help for "Mass Properties calculation details".</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<returns>((float*float*float) ResizeArray ) of moments and error bounds in tuples(X, Y, Z) - see help topic
    ///    Index   Description
    ///    [0]     First Moments.
    ///    [1]     The absolute (+/-) error bound for the First Moments.
    ///    [2]     Second Moments.
    ///    [3]     The absolute (+/-) error bound for the Second Moments.
    ///    [4]     Product Moments.
    ///    [5]     The absolute (+/-) error bound for the Product Moments.
    ///    [6]     Area Moments of Inertia about the World Coordinate Axes.
    ///    [7]     The absolute (+/-) error bound for the Area Moments of Inertia about World Coordinate Axes.
    ///    [8]     Area Radii of Gyration about the World Coordinate Axes.
    ///    [9]     (Not implemented yet) The absolute (+/-) error bound for the Area Radii of Gyration about World Coordinate Axes.
    ///    [10]    Area Moments of Inertia about the Centroid Coordinate Axes.
    ///    [11]    The absolute (+/-) error bound for the Area Moments of Inertia about the Centroid Coordinate Axes.
    ///    [12]    Area Radii of Gyration about the Centroid Coordinate Axes.
    ///    [13]    (Not implemented yet) The absolute (+/-) error bound for the Area Radii of Gyration about the Centroid Coordinate Axes.</returns>
    static member SurfaceAreaMoments(surfaceId:Guid) : (float*float*float) ResizeArray =
        surfaceId
        |> RhinoScriptSyntax.TryCoerceBrep
        |> Option.map AreaMassProperties.Compute
        |> Option.orElseWith (fun () ->
            surfaceId
            |> RhinoScriptSyntax.TryCoerceSurface
            |> Option.map AreaMassProperties.Compute
            )
        |> Option.defaultWith (fun () -> RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceAreaMoments failed on %A" surfaceId)
        |> fun mp ->
            resizeArray {
                yield (mp.WorldCoordinatesFirstMoments.X, mp.WorldCoordinatesFirstMoments.Y, mp.WorldCoordinatesFirstMoments.Z)                                     //  [0]     First Moments.
                yield (mp.WorldCoordinatesFirstMomentsError.X, mp.WorldCoordinatesFirstMomentsError.Y, mp.WorldCoordinatesFirstMomentsError.Z)                      //  [1]     The absolute (+/-) error bound for the First Moments.
                yield (mp.WorldCoordinatesSecondMoments.X, mp.WorldCoordinatesSecondMoments.Y, mp.WorldCoordinatesSecondMoments.Z)                                  //  [2]     Second Moments.
                yield (mp.WorldCoordinatesSecondMomentsError.X, mp.WorldCoordinatesSecondMomentsError.Y, mp.WorldCoordinatesSecondMomentsError.Z)                   //  [3]     The absolute (+/-) error bound for the Second Moments.
                yield (mp.WorldCoordinatesProductMoments.X, mp.WorldCoordinatesProductMoments.Y, mp.WorldCoordinatesProductMoments.Z)                               //  [4]     Product Moments.
                yield (mp.WorldCoordinatesProductMomentsError.X, mp.WorldCoordinatesProductMomentsError.Y, mp.WorldCoordinatesProductMomentsError.Z)                //  [5]     The absolute (+/-) error bound for the Product Moments.
                yield (mp.WorldCoordinatesMomentsOfInertia.X, mp.WorldCoordinatesMomentsOfInertia.Y, mp.WorldCoordinatesMomentsOfInertia.Z)                         //  [6]     Area Moments of Inertia about the World Coordinate Axes.
                yield (mp.WorldCoordinatesMomentsOfInertiaError.X, mp.WorldCoordinatesMomentsOfInertiaError.Y, mp.WorldCoordinatesMomentsOfInertiaError.Z)          //  [7]     The absolute (+/-) error bound for the Area Moments of Inertia about World Coordinate Axes.
                yield (mp.WorldCoordinatesRadiiOfGyration.X, mp.WorldCoordinatesRadiiOfGyration.Y, mp.WorldCoordinatesRadiiOfGyration.Z)                            //  [8]     Area Radii of Gyration about the World Coordinate Axes.
                yield (0., 0., 0.) // need to add error calc to RhinoCommon                                                                                         //  [9]     The absolute (+/-) error bound for the Area Radii of Gyration about World Coordinate Axes.
                yield (mp.CentroidCoordinatesMomentsOfInertia.X, mp.CentroidCoordinatesMomentsOfInertia.Y, mp.CentroidCoordinatesMomentsOfInertia.Z)                //  [10]    Area Moments of Inertia about the Centroid Coordinate Axes.
                yield (mp.CentroidCoordinatesMomentsOfInertiaError.X, mp.CentroidCoordinatesMomentsOfInertiaError.Y, mp.CentroidCoordinatesMomentsOfInertiaError.Z) //  [11]    The absolute (+/-) error bound for the Area Moments of Inertia about the Centroid Coordinate Axes.
                yield (mp.CentroidCoordinatesRadiiOfGyration.X, mp.CentroidCoordinatesRadiiOfGyration.Y, mp.CentroidCoordinatesRadiiOfGyration.Z)                   //  [12]    Area Radii of Gyration about the Centroid Coordinate Axes.
                yield (0., 0., 0.) //need to add error calc to RhinoCommon                                                                                          //  [13]    The absolute (+/-) error bound for the Area Radii of Gyration about the Centroid Coordinate Axes</returns>
                }


    ///<summary>Returns the point on a Surface that is closest to a test point.</summary>
    ///<param name="surfaceId">(Guid) Identifier of a Surface object</param>
    ///<param name="testPoint">(Point3d) Sampling point</param>
    ///<returns>(Point3d) The closest point on the Surface.</returns>
    static member SurfaceClosestPoint(surfaceId:Guid, testPoint:Point3d) : Point3d =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let rc, u, v = surface.ClosestPoint(testPoint)
        if not rc then RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceClosestPoint failed on %A and %A" surfaceId testPoint
        surface.PointAt(u, v)

    ///<summary>Returns U, V parameters of point on a Surface that is closest to a test point.</summary>
    ///<param name="surfaceId">(Guid) Identifier of a Surface object</param>
    ///<param name="testPoint">(Point3d) Sampling point</param>
    ///<returns>(float * float) The U, V parameters of the closest point on the Surface.</returns>
    static member SurfaceClosestParameter(surfaceId:Guid, testPoint:Point3d) : float * float =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let rc, u, v = surface.ClosestPoint(testPoint)
        if not rc then RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceClosestParameter failed on %A and %A" surfaceId testPoint
        u, v


    ///<summary>Returns the definition of a Surface cone.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<returns>(Plane * float * float) containing the definition of the cone
    ///    [0]   the Plane of the cone. The apex of the cone is at the
    ///      Plane's origin and the axis of the cone is the Plane's z-axis
    ///    [1]   the height of the cone
    ///    [2]   the radius of the cone.</returns>
    static member SurfaceCone(surfaceId:Guid) : Plane * float * float =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let rc, cone = surface.TryGetCone()
        if not rc then RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceCone failed.  surfaceId:'%s'" (Nice.str surfaceId)
        cone.Plane, cone.Height, cone.Radius


    ///<summary>Returns the curvature of a Surface at a U, V parameter. See Rhino help
    ///    for details of Surface curvature.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<param name="parameter">(float * float) U, v parameter</param>
    ///<returns>(Point3d * Vector3d * float * Vector3d * float * Vector3d * float * float) of curvature information
    ///    [0]   point at specified U, V parameter
    ///    [1]   normal direction
    ///    [2]   maximum principal curvature
    ///    [3]   maximum principal curvature direction
    ///    [4]   minimum principal curvature
    ///    [5]   minimum principal curvature direction
    ///    [6]   gaussian curvature
    ///    [7]   mean curvature.</returns>
    static member SurfaceCurvature(surfaceId:Guid, parameter:float * float) : Point3d * Vector3d * float * Vector3d * float * Vector3d * float * float=
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        //if Seq.length(parameter)<2 then RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceCurvature failed.  surfaceId:'%s' parameter:'%A'" (Nice.str surfaceId) parameter
        let c = surface.CurvatureAt(parameter|> fst, parameter|> snd)
        if c|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceCurvature failed.  surfaceId:'%s' parameter:'%A'" (Nice.str surfaceId) parameter
        c.Point, c.Normal, c.Kappa(0), c.Direction(0), c.Kappa(1), c.Direction(1), c.Gaussian, c.Mean


    ///<summary>Returns the definition of a cylinder Surface.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<returns>(Plane * float * float) of the cylinder Plane, height and radius.</returns>
    static member SurfaceCylinder(surfaceId:Guid) : Plane * float * float =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let tol = State.Doc.ModelAbsoluteTolerance
        let cy = ref Cylinder.Unset
        let rc = surface.TryGetFiniteCylinder(cy, tol)
        if rc  then
            let cylinder = !cy
            cylinder.BasePlane, cylinder.TotalHeight, cylinder.Radius
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceCylinder failed on %A" surfaceId


    ///<summary>Returns the U and V degrees of a Surface.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<returns>(int*int) The degree in U and V direction.</returns>
    static member SurfaceDegree(surfaceId:Guid ) : int*int =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        surface.Degree(0), surface.Degree(1)


    ///<summary>Returns the domain of a Surface object in the specified direction.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<param name="direction">(int) Domain direction 0 = U, or 1 = V</param>
    ///<returns>(float * float) containing the domain interval in the specified direction.</returns>
    static member SurfaceDomain(surfaceId:Guid, direction:int) : float * float =
        if direction <> 0 && direction <> 1 then RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceDomain failed.  surfaceId:'%s' direction:'%A'" (Nice.str surfaceId) direction
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let domain = surface.Domain(direction)
        domain.T0, domain.T1


    ///<summary>Returns the edit, or Greville points of a Surface object. For each
    ///    Surface control point, there is a corresponding edit point.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<param name="returnAll">(bool) Optional, default value: <c>true</c>
    ///    If True, all Surface edit points are returned. If False,
    ///    the function will return Surface edit points based on whether or not the
    ///    Surface is closed or periodic</param>
    ///<returns>(Point3d ResizeArray) a list of 3D points.</returns>
    static member SurfaceEditPoints( surfaceId:Guid, [<OPT;DEF(true)>]returnAll:bool) : Point3d ResizeArray =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let nurb = surface.ToNurbsSurface()
        if isNull nurb then RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceEditPoints failed.  surfaceId:'%s'  returnAll:'%A'" (Nice.str surfaceId) returnAll
        let mutable ufirst = 0
        let mutable ulast = nurb.Points.CountU
        let mutable vfirst = 0
        let mutable vlast = nurb.Points.CountV
        let mutable degree = -1
        if not returnAll then
            if nurb.IsClosed(0) then ulast <- nurb.Points.CountU-1
            if nurb.IsPeriodic(0) then
                degree <- nurb.Degree(0)
                ufirst <- degree/2
                ulast <- nurb.Points.CountU-degree + ufirst
            if nurb.IsClosed(1) then vlast <- nurb.Points.CountV-1
            if nurb.IsPeriodic(1) then
                degree <- nurb.Degree(1)
                vfirst <- degree/2
                vlast <- nurb.Points.CountV-degree + vfirst
        resizeArray {
            for u = ufirst to ulast-1 do
                for v = vfirst to  vlast-1 do
                    let pt = nurb.Points.GetGrevillePoint(u, v)
                    nurb.PointAt(pt.X, pt.Y)
                    }
    ///<summary>Returns the parameters at edit, or Greville points of a Surface object. For each
    ///    Surface control point, there is a corresponding edit point.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<param name="returnAll">(bool) Optional, default value: <c>true</c>
    ///    If True, all Surface edit points are returned. If False,
    ///    the function will return Surface edit points based on whether or not the
    ///    Surface is closed or periodic</param>
    ///<returns>((float*float) ResizeArray) a list of U and V parameters.</returns>
    static member SurfaceEditPointParameters( surfaceId:Guid, [<OPT;DEF(true)>]returnAll:bool) : (float*float) ResizeArray =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let nurb = surface.ToNurbsSurface()
        if isNull nurb then RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceEditPointParameters failed.  surfaceId:'%s'  returnAll:'%A'" (Nice.str surfaceId) returnAll
        let mutable ufirst = 0
        let mutable ulast = nurb.Points.CountU
        let mutable vfirst = 0
        let mutable vlast = nurb.Points.CountV
        let mutable degree = -1
        if not returnAll then
            if nurb.IsClosed(0) then ulast <- nurb.Points.CountU-1
            if nurb.IsPeriodic(0) then
                degree <- nurb.Degree(0)
                ufirst <- degree/2
                ulast <- nurb.Points.CountU-degree + ufirst
            if nurb.IsClosed(1) then vlast <- nurb.Points.CountV-1
            if nurb.IsPeriodic(1) then
                degree <- nurb.Degree(1)
                vfirst <- degree/2
                vlast <- nurb.Points.CountV-degree + vfirst
        resizeArray {
            for u = ufirst to ulast-1 do
                for v = vfirst to  vlast-1 do
                    let pt = nurb.Points.GetGrevillePoint(u, v)
                    pt.X, pt.Y
                    }


    ///<summary>A general purpose Surface evaluator.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<param name="parameter">(float * float) U, v parameter to evaluate</param>
    ///<param name="derivative">(int) Number of derivatives to evaluate</param>
    ///<returns>(Point3d * Vector3d ResizeArray) list length (derivative + 1)*(derivative + 2)/2
    ///    Elements of tuple:
    ///    [fst] The 3-D point.
    ///    [snd] List of Vectors:
    ///            [0]      The first derivative.
    ///            [1]      The first derivative.
    ///            [2]      The second derivative.
    ///            [3]      The second derivative.
    ///            [4]      The second derivative.
    ///            [5]      etc...</returns>
    static member SurfaceEvaluate( surfaceId:Guid,
                                   parameter:float * float,
                                   derivative:int) : Point3d * Vector3d ResizeArray =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let success, point, der = surface.Evaluate(parameter|> fst, parameter|> snd, derivative)
        if not success then RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceEvaluate failed.  surfaceId:'%s' parameter:'%A' derivative:'%A'" (Nice.str surfaceId) parameter derivative
        let rc = resizeArray {()}
        if der.Length > 0 then
          for d in der do rc.Add(d)
        point, rc


    ///<summary>Returns a Plane based on the normal, u, and v directions at a Surface
    ///    U, V parameter.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<param name="uvParameter">(float * float) U, v parameter to evaluate</param>
    ///<returns>(Plane) Plane.</returns>
    static member SurfaceFrame(surfaceId:Guid, uvParameter:float * float) : Plane =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let rc, frame = surface.FrameAt(uvParameter|> fst, uvParameter|> snd)
        if rc  then frame
        else RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceFrame failed on %A at %A" surfaceId uvParameter


    ///<summary>Returns the isocurve density of a Surface or Polysurface object.
    /// An isoparametric Curve is a Curve of constant U or V value on a Surface.
    /// Rhino uses isocurves and Surface edge Curves to visualize the shape of a
    /// NURBS Surface.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<returns>(int) The current isocurve density
    ///      -1: Hides the Surface isocurves
    ///      0: Display boundary and knot wires
    ///      1: Display boundary and knot wires and one interior wire if there are no interior knots
    ///      bigger than 1: Display boundary and knot wires and (N + 1) interior wires.</returns>
    static member SurfaceIsocurveDensity(surfaceId:Guid) : int = //GET
        match RhinoScriptSyntax.CoerceRhinoObject(surfaceId) with
        | :?  DocObjects.BrepObject as rhinoObject ->
                rhinoObject.Attributes.WireDensity
        | :?  DocObjects.SurfaceObject as rhinoObject ->
                rhinoObject.Attributes.WireDensity
        | :?  DocObjects.ExtrusionObject as rhinoObject ->
                rhinoObject.Attributes.WireDensity
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceIsocurveDensity Get failed.  surfaceId:'%s'" (Nice.str surfaceId)


    ///<summary>Sets the isocurve density of a Surface or Polysurface object.
    /// An isoparametric Curve is a Curve of constant U or V value on a Surface.
    /// Rhino uses isocurves and Surface edge Curves to visualize the shape of a
    /// NURBS Surface.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<param name="density">(int) The isocurve wireframe density. The possible values are
    ///      -1: Hides the Surface isocurves
    ///      0: Display boundary and knot wires
    ///      1: Display boundary and knot wires and one interior wire if there are no interior knots
    ///      bigger than 1: Display boundary and knot wires and (N + 1) interior wires</param>
    ///<returns>(unit) void, nothing.</returns>
    static member SurfaceIsocurveDensity(surfaceId:Guid, density:int) : unit = //SET
        match RhinoScriptSyntax.CoerceRhinoObject(surfaceId) with
        | :?  DocObjects.BrepObject as rhinoObject ->
                let dens = if density<0 then -1 else density
                rhinoObject.Attributes.WireDensity <- dens
                rhinoObject.CommitChanges() |> ignore
                State.Doc.Views.Redraw()
        | :?  DocObjects.SurfaceObject as rhinoObject ->
                let dens = if density<0 then -1 else density
                rhinoObject.Attributes.WireDensity <- dens
                rhinoObject.CommitChanges() |> ignore
                State.Doc.Views.Redraw()
        | :?  DocObjects.ExtrusionObject as rhinoObject ->
                let dens = if density<0 then -1 else density
                rhinoObject.Attributes.WireDensity <- dens
                rhinoObject.CommitChanges() |> ignore
                State.Doc.Views.Redraw()
        | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceIsocurveDensity Get failed.  surfaceId:'%s' density:'%A'" (Nice.str surfaceId) density


    ///<summary>Sets the isocurve density of multiple Surface or Polysurface objects.
    /// An isoparametric Curve is a Curve of constant U or V value on a Surface.
    /// Rhino uses isocurves and Surface edge Curves to visualize the shape of a
    /// NURBS Surface.</summary>
    ///<param name="surfaceIds">(Guid seq) The Surface's identifiers</param>
    ///<param name="density">(int) The isocurve wireframe density. The possible values are
    ///      -1: Hides the Surface isocurves
    ///      0: Display boundary and knot wires
    ///      1: Display boundary and knot wires and one interior wire if there are no interior knots
    ///      bigger than 1: Display boundary and knot wires and (N + 1) interior wires</param>
    ///<returns>(unit) void, nothing.</returns>
    static member SurfaceIsocurveDensity(surfaceIds:Guid seq, density:int) : unit = //MULTISET
        for surfaceId in surfaceIds do
            match RhinoScriptSyntax.CoerceRhinoObject(surfaceId) with
            | :?  DocObjects.BrepObject as rhinoObject ->
                    let dens = if density<0 then -1 else density
                    rhinoObject.Attributes.WireDensity <- dens
                    rhinoObject.CommitChanges() |> ignore
            | :?  DocObjects.SurfaceObject as rhinoObject ->
                    let dens = if density<0 then -1 else density
                    rhinoObject.Attributes.WireDensity <- dens
                    rhinoObject.CommitChanges() |> ignore
            | :?  DocObjects.ExtrusionObject as rhinoObject ->
                    let dens = if density<0 then -1 else density
                    rhinoObject.Attributes.WireDensity <- dens
                    rhinoObject.CommitChanges() |> ignore
            | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceIsocurveDensity Get failed.  surfaceId:'%s' density:'%A'" (Nice.str surfaceId) density
        State.Doc.Views.Redraw()

    ///<summary>Returns the control point count of a Surface
    ///    SurfaceId = the Surface's identifier.</summary>
    ///<param name="surfaceId">(Guid) The Surface object's identifier</param>
    ///<returns>(int * int) a list containing (U count, V count).</returns>
    static member SurfaceKnotCount(surfaceId:Guid) : int * int =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let ns = surface.ToNurbsSurface()
        ns.KnotsU.Count, ns.KnotsV.Count


    ///<summary>Returns the knots, or knot vector, of a Surface object.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<returns>(NurbsSurfaceKnotList * NurbsSurfaceKnotList) knot values of the Surface.
    ///    The list will contain the following information:
    ///    Element   Description
    ///      [0]     Knot vectors in U direction
    ///      [1]     Knot vectors in V direction.</returns>
    static member SurfaceKnots(surfaceId:Guid) : Collections.NurbsSurfaceKnotList * Collections.NurbsSurfaceKnotList=
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let nurbsurf = surface.ToNurbsSurface()
        if nurbsurf|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceKnots failed.  surfaceId:'%s'" (Nice.str surfaceId)
        nurbsurf.KnotsU , nurbsurf.KnotsV
        //let sknots =  resizeArray { for knot in nurbsurf.KnotsU do yield knot }
        //let tknots =  resizeArray { for knot in nurbsurf.KnotsV do yield knot }
        //if isNull sknots || not tknots then RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceKnots failed.  surfaceId:'%s'" (Nice.str surfaceId)
        //sknots, tknots


    ///<summary>Returns 3D vector that is the normal to a Surface at a parameter.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<param name="uvParameter">(float * float) The uv parameter to evaluate</param>
    ///<returns>(Vector3d) Normal vector.</returns>
    static member SurfaceNormal(surfaceId:Guid, uvParameter:float * float) : Vector3d =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        surface.NormalAt(uvParameter|> fst, uvParameter|> snd)

    ///<summary>Returns 3D vector that is the normal to a Surface at mid parameter.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<returns>(Vector3d) Normal vector.</returns>
    static member SurfaceNormal(surfaceId:Guid) : Vector3d =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let u = surface.Domain(0).ParameterAt(0.5)
        let v = surface.Domain(1).ParameterAt(0.5)
        surface.NormalAt(u,v)


    ///<summary>Converts Surface parameter to a normalized Surface parameter; one that
    ///    ranges between 0.0 and 1.0 in both the U and V directions.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<param name="parameter">(float * float) The Surface parameter to convert</param>
    ///<returns>(float * float) normalized Surface parameter.</returns>
    static member SurfaceNormalizedParameter(surfaceId:Guid, parameter:float * float) : float * float =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let udomain = surface.Domain(0)
        let vdomain = surface.Domain(1)
        if parameter|> fst<udomain.Min || parameter|> fst>udomain.Max then
            RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceNormalizedParameter failed.  surfaceId:'%s' parameter:'%A'" (Nice.str surfaceId) parameter
        if parameter|> snd<vdomain.Min || parameter|> snd>vdomain.Max then
            RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceNormalizedParameter failed.  surfaceId:'%s' parameter:'%A'" (Nice.str surfaceId) parameter
        let u = udomain.NormalizedParameterAt(parameter|> fst)
        let v = vdomain.NormalizedParameterAt(parameter|> snd)
        u, v


    ///<summary>Converts normalized Surface parameter to a Surface domain specific (regular) parameter.
    /// or a parameter within the Surface's domain.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<param name="parameter">(float * float) The normalized parameter to convert</param>
    ///<returns>(float * float) u and v Surface parameters.</returns>
    static member SurfaceParameter(surfaceId:Guid, parameter:float * float) : float * float =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let x = surface.Domain(0).ParameterAt(parameter|> fst)
        let y = surface.Domain(1).ParameterAt(parameter|> snd)
        x, y


    ///<summary>Returns the control point count of a Surface
    ///    SurfaceId = the Surface's identifier.</summary>
    ///<param name="surfaceId">(Guid) The Surface object's identifier</param>
    ///<returns>(int * int) THe number of control points in UV direction. (U count, V count).</returns>
    static member SurfacePointCount(surfaceId:Guid) : int * int =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let ns = surface.ToNurbsSurface()
        ns.Points.CountU, ns.Points.CountV


    ///<summary>Returns the control points, or control vertices, of a Surface object.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<param name="returnAll">(bool) Optional, default value: <c>true</c>
    ///    If True all Surface edit points are returned. If False,
    ///    the function will return Surface edit points based on whether or not
    ///    the Surface is closed or periodic</param>
    ///<returns>(Point3d ResizeArray) The control points.</returns>
    static member SurfacePoints(surfaceId:Guid, [<OPT;DEF(true)>]returnAll:bool) : Point3d ResizeArray =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let ns = surface.ToNurbsSurface()
        if ns|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.SurfacePoints failed.  surfaceId:'%s' returnAll:'%A'" (Nice.str surfaceId) returnAll
        let rc = ResizeArray()
        for u = 0 to ns.Points.CountU - 1 do
            for v = 0 to ns.Points.CountV - 1 do
                let pt = ns.Points.GetControlPoint(u, v)
                rc.Add(pt.Location)
        rc


    ///<summary>Returns the definition of a Surface torus.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<returns>(Plane * float * float) containing the definition of the torus
    ///    [0]   the base Plane of the torus
    ///    [1]   the major radius of the torus
    ///    [2]   the minor radius of the torus.</returns>
    static member SurfaceTorus(surfaceId:Guid) : Plane * float * float =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let rc, torus = surface.TryGetTorus()
        if rc then torus.Plane, torus.MajorRadius, torus.MinorRadius
        else RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceTorus failed for %A" surfaceId


    ///<summary>Calculates volume of a closed Surface or Polysurface.</summary>
    ///<param name="objectId">(Guid) The Surface's identifier</param>
    ///<returns>(float) The volume.</returns>
    static member SurfaceVolume(objectId:Guid) : float =
        objectId
        |> RhinoScriptSyntax.TryCoerceBrep
        |> Option.map VolumeMassProperties.Compute
        |> Option.orElseWith (fun () ->
            objectId
            |> RhinoScriptSyntax.TryCoerceSurface
            |> Option.map VolumeMassProperties.Compute
            )
        |> Option.defaultWith (fun () -> RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceVolume failed on %A" (Nice.str objectId))
        |> fun amp -> amp.Volume


    ///<summary>Calculates volume centroid of a closed Surface or Polysurface.</summary>
    ///<param name="objectId">(Guid) The Surface's identifier</param>
    ///<returns>(Point3d) Volume Centroid.</returns>
    static member SurfaceVolumeCentroid(objectId:Guid) : Point3d =
        objectId
        |> RhinoScriptSyntax.TryCoerceBrep
        |> Option.bind (fun b -> if b.IsSolid then Some b else RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceVolumeCentroid failed on  open Brep %A" (Nice.str objectId))
        |> Option.map VolumeMassProperties.Compute
        |> Option.orElseWith (fun () ->
            objectId
            |> RhinoScriptSyntax.TryCoerceSurface
            |> Option.bind (fun s -> if s.IsSolid then Some s else RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceVolumeCentroid failed on  open Surface %A" (Nice.str objectId))
            |> Option.map VolumeMassProperties.Compute
            )
        |> Option.defaultWith (fun () -> RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceVolumeCentroid failed on %A" (Nice.str objectId))
        |> fun amp -> amp.Centroid


    ///<summary>Calculates volume moments of inertia of a Surface or Polysurface object.
    ///    For more information, see Rhino help for "Mass Properties calculation details".</summary>
    ///<param name="objectId">(Guid) The Surface's identifier</param>
    ///<returns>((float*float*float) ResizeArray) A List of moments and error bounds in tuple(X, Y, Z) - see help topic
    ///    Index   Description
    ///    [ 0]    First Moments.
    ///    [ 1]    The absolute (+/-) error bound for the First Moments.
    ///    [ 2]    Second Moments.
    ///    [ 3]    The absolute (+/-) error bound for the Second Moments.
    ///    [ 4]    Product Moments.
    ///    [ 5]    The absolute (+/-) error bound for the Product Moments.
    ///    [ 6]    Area Moments of Inertia about the World Coordinate Axes.
    ///    [ 7]    The absolute (+/-) error bound for the Area Moments of Inertia about World Coordinate Axes.
    ///    [ 8]    Area Radii of Gyration about the World Coordinate Axes.
    ///    [ 9]    (0,0,0) NOT WORKING , but should be: The absolute (+/-) error bound for the Area Radii of Gyration about World Coordinate Axes.
    ///    [10]    Area Moments of Inertia about the Centroid Coordinate Axes.
    ///    [11]    The absolute (+/-) error bound for the Area Moments of Inertia about the Centroid Coordinate Axes.
    ///    [12]    Area Radii of Gyration about the Centroid Coordinate Axes.
    ///    [13]    (0,0,0) NOT WORKING , but should be: The absolute (+/-) error bound for the Area Radii of Gyration about the Centroid Coordinate Axes.
    /// </returns>
    static member SurfaceVolumeMoments(objectId:Guid) : (float*float*float) ResizeArray =
        objectId
        |> RhinoScriptSyntax.TryCoerceBrep
        |> Option.bind (fun b -> if b.IsSolid then Some b else RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceVolumeMoments failed on  open Brep %A" (Nice.str objectId))
        |> Option.map VolumeMassProperties.Compute
        |> Option.orElseWith (fun () ->
            objectId
            |> RhinoScriptSyntax.TryCoerceSurface
            |> Option.bind (fun s -> if s.IsSolid then Some s else RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceVolumeMoments failed on  open Surface %A" (Nice.str objectId))
            |> Option.map VolumeMassProperties.Compute
            )
        |> Option.defaultWith (fun () -> RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceVolumeMoments failed on %A" (Nice.str objectId))
        |> fun mp ->
            resizeArray {
                yield (mp.WorldCoordinatesFirstMoments.X, mp.WorldCoordinatesFirstMoments.Y, mp.WorldCoordinatesFirstMoments.Z)                                     //  [0]     First Moments.
                yield (mp.WorldCoordinatesFirstMomentsError.X, mp.WorldCoordinatesFirstMomentsError.Y, mp.WorldCoordinatesFirstMomentsError.Z)                      //  [1]     The absolute (+/-) error bound for the First Moments.
                yield (mp.WorldCoordinatesSecondMoments.X, mp.WorldCoordinatesSecondMoments.Y, mp.WorldCoordinatesSecondMoments.Z)                                  //  [2]     Second Moments.
                yield (mp.WorldCoordinatesSecondMomentsError.X, mp.WorldCoordinatesSecondMomentsError.Y, mp.WorldCoordinatesSecondMomentsError.Z)                   //  [3]     The absolute (+/-) error bound for the Second Moments.
                yield (mp.WorldCoordinatesProductMoments.X, mp.WorldCoordinatesProductMoments.Y, mp.WorldCoordinatesProductMoments.Z)                               //  [4]     Product Moments.
                yield (mp.WorldCoordinatesProductMomentsError.X, mp.WorldCoordinatesProductMomentsError.Y, mp.WorldCoordinatesProductMomentsError.Z)                //  [5]     The absolute (+/-) error bound for the Product Moments.
                yield (mp.WorldCoordinatesMomentsOfInertia.X, mp.WorldCoordinatesMomentsOfInertia.Y, mp.WorldCoordinatesMomentsOfInertia.Z)                         //  [6]     Area Moments of Inertia about the World Coordinate Axes.
                yield (mp.WorldCoordinatesMomentsOfInertiaError.X, mp.WorldCoordinatesMomentsOfInertiaError.Y, mp.WorldCoordinatesMomentsOfInertiaError.Z)          //  [7]     The absolute (+/-) error bound for the Area Moments of Inertia about World Coordinate Axes.
                yield (mp.WorldCoordinatesRadiiOfGyration.X, mp.WorldCoordinatesRadiiOfGyration.Y, mp.WorldCoordinatesRadiiOfGyration.Z)                            //  [8]     Area Radii of Gyration about the World Coordinate Axes.
                yield (0., 0., 0.) // need to add error calc to RhinoCommon                                                                                         //  [9]     The absolute (+/-) error bound for the Area Radii of Gyration about World Coordinate Axes.
                yield (mp.CentroidCoordinatesMomentsOfInertia.X, mp.CentroidCoordinatesMomentsOfInertia.Y, mp.CentroidCoordinatesMomentsOfInertia.Z)                //  [10]    Area Moments of Inertia about the Centroid Coordinate Axes.
                yield (mp.CentroidCoordinatesMomentsOfInertiaError.X, mp.CentroidCoordinatesMomentsOfInertiaError.Y, mp.CentroidCoordinatesMomentsOfInertiaError.Z) //  [11]    The absolute (+/-) error bound for the Area Moments of Inertia about the Centroid Coordinate Axes.
                yield (mp.CentroidCoordinatesRadiiOfGyration.X, mp.CentroidCoordinatesRadiiOfGyration.Y, mp.CentroidCoordinatesRadiiOfGyration.Z)                   //  [12]    Area Radii of Gyration about the Centroid Coordinate Axes.
                yield (0., 0., 0.) //need to add error calc to RhinoCommon                                                                                          //  [13]    The absolute (+/-) error bound for the Area Radii of Gyration about the Centroid Coordinate Axes</returns>
                }



    ///<summary>Returns list of weight values assigned to the control points of a Surface.
    ///    The number of weights returned will be equal to the number of control points
    ///    in the U and V directions.</summary>
    ///<param name="objectId">(Guid) The Surface's identifier</param>
    ///<returns>(float ResizeArray) point weights.</returns>
    static member SurfaceWeights(objectId:Guid) : float ResizeArray =
        let surface = RhinoScriptSyntax.CoerceSurface(objectId)
        let ns = surface.ToNurbsSurface()
        if ns|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.SurfaceWeights failed.  objectId:'%s'" (Nice.str objectId)
        let rc = ResizeArray()
        for u = 0 to ns.Points.CountU - 1 do
            for v = 0 to ns.Points.CountV - 1 do
                let pt = ns.Points.GetControlPoint(u, v)
                rc.Add(pt.Weight)
        rc

    ///<summary>Trims a Surface or Polysurface using an oriented cutter brep or Surface.</summary>
    ///<param name="objectId">(Guid) Surface or Polysurface identifier</param>
    ///<param name="cutter">(Guid) Surface or Polysurface  performing the trim</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c></param>
    ///<returns>(Guid ResizeArray) identifiers of retained components.</returns>
    static member TrimBrep( objectId:Guid,
                            cutter:Guid,
                            [<OPT;DEF(0.0)>]tolerance:float) : Guid ResizeArray =
        let brep = RhinoScriptSyntax.CoerceBrep(objectId)
        let cutter = RhinoScriptSyntax.CoerceBrep(cutter)
        let tolerance= Util.ifZero1 tolerance  State.Doc.ModelAbsoluteTolerance
        let breps = brep.Trim(cutter, tolerance)
        if breps.Length > 1 then
            let rho = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            let attrs = rho.Attributes
            let rc = ResizeArray()
            for i = 0 to breps.Length - 1 do
                if i = 0 then
                    State.Doc.Objects.Replace(objectId, breps.[i]) |> ignore
                    rc.Add(objectId)
                else
                    rc.Add(State.Doc.Objects.AddBrep(breps.[i], attrs))
            State.Doc.Views.Redraw()
            rc
        else
            let rc =  resizeArray { for brep in breps do yield State.Doc.Objects.AddBrep(brep) }
            State.Doc.Views.Redraw()
            rc

    ///<summary>Trims a Surface using an oriented cutter Plane.</summary>
    ///<param name="objectId">(Guid) Surface or Polysurface identifier</param>
    ///<param name="cutter">(Plane) Plane performing the trim</param>
    ///<param name="tolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c></param>
    ///<returns>(Guid ResizeArray) identifiers of retained components.</returns>
    static member TrimBrep( objectId:Guid,
                            cutter:Plane,
                            [<OPT;DEF(0.0)>]tolerance:float) : Guid ResizeArray =
        let brep = RhinoScriptSyntax.CoerceBrep(objectId)
        let tolerance = Util.ifZero1 tolerance  State.Doc.ModelAbsoluteTolerance
        let breps = brep.Trim(cutter, tolerance)
        if breps.Length > 1 then
            let rho = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            let attrs = rho.Attributes
            let rc = ResizeArray()
            for i = 0 to breps.Length - 1 do
                if i = 0 then
                    State.Doc.Objects.Replace(objectId, breps.[i]) |> ignore
                    rc.Add(objectId)
                else
                    rc.Add(State.Doc.Objects.AddBrep(breps.[i], attrs))
            State.Doc.Views.Redraw()
            rc
        else
            let rc =  resizeArray { for brep in breps do yield State.Doc.Objects.AddBrep(brep) }
            State.Doc.Views.Redraw()
            rc

    ///<summary>Remove portions of the Surface outside of the specified interval in U direction.</summary>
    ///<param name="surfaceId">(Guid) Surface identifier</param>
    ///<param name="interval">(float*float) Sub section of the Surface to keep.</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>false</c>
    ///    Should the input Surface be deleted</param>
    ///<returns>(Guid) new Surface identifier.</returns>
    static member TrimSurfaceU( surfaceId:Guid,
                                interval:float*float,
                                [<OPT;DEF(false)>]deleteInput:bool) : Guid =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let mutable u = surface.Domain(0)
        let mutable v = surface.Domain(1)
        u.[0] <-  interval|> fst
        u.[1] <-  interval|> snd
        let newsurface = surface.Trim(u, v)
        if notNull newsurface then
            let rc = State.Doc.Objects.AddSurface(newsurface)
            if deleteInput then  State.Doc.Objects.Delete(surfaceId, true) |> ignore
            State.Doc.Views.Redraw()
            rc
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.TrimSurfaceU failed on %A with domain %A" surfaceId interval

    ///<summary>Remove portions of the Surface outside of the specified interval in V direction.</summary>
    ///<param name="surfaceId">(Guid) Surface identifier</param>
    ///<param name="interval">(float*float) Sub section of the Surface to keep.</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>false</c>
    ///    Should the input Surface be deleted</param>
    ///<returns>(Guid) new Surface identifier.</returns>
    static member TrimSurfaceV( surfaceId:Guid,
                               interval:float*float,
                               [<OPT;DEF(false)>]deleteInput:bool) : Guid =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let mutable u = surface.Domain(0)
        let mutable v = surface.Domain(1)
        v.[0] <-  interval|> fst
        v.[1] <-  interval|> snd
        let newsurface = surface.Trim(u, v)
        if notNull newsurface then
            let rc = State.Doc.Objects.AddSurface(newsurface)
            if deleteInput then  State.Doc.Objects.Delete(surfaceId, true) |> ignore
            State.Doc.Views.Redraw()
            rc
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.TrimSurfaceV failed on %A with domain %A" surfaceId interval


    ///<summary>Remove portions of the Surface outside of the specified interval ain U and V direction.</summary>
    ///<param name="surfaceId">(Guid) Surface identifier</param>
    ///<param name="intervalU">(float*float) Sub section of the Surface to keep in U direction</param>
    ///<param name="intervalV">(float*float) Sub section of the Surface to keep in V direction</param>
    ///<param name="deleteInput">(bool) Optional, default value: <c>false</c>
    ///    Should the input Surface be deleted</param>
    ///<returns>(Guid) new Surface identifier.</returns>
    static member TrimSurfaceUV( surfaceId:Guid,
                               intervalU:float*float,
                               intervalV:float*float,
                               [<OPT;DEF(false)>]deleteInput:bool) : Guid =
        let surface = RhinoScriptSyntax.CoerceSurface(surfaceId)
        let mutable u = surface.Domain(0)
        let mutable v = surface.Domain(1)
        u.[0]  <- intervalU|> fst
        u.[1]  <- intervalU|> snd
        v.[0]  <- intervalV|> fst
        v.[1]  <- intervalV|> snd
        let newsurface = surface.Trim(u, v)
        if notNull newsurface then
            let rc = State.Doc.Objects.AddSurface(newsurface)
            if deleteInput then  State.Doc.Objects.Delete(surfaceId, true) |> ignore
            State.Doc.Views.Redraw()
            rc
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.TrimSurfaceUV failed on %A with domain %A and %A" surfaceId intervalU intervalV



    ///<summary>Flattens a develop-able Surface or Polysurface.</summary>
    ///<param name="surfaceId">(Guid) The Surface's identifier</param>
    ///<param name="explode">(bool) Optional, default value: <c>false</c>
    ///    If True, the resulting Surfaces are not joined</param>
    ///<param name="followingGeometry">(Guid seq) Optional, List of Curves, dots, and points which
    ///    should be unrolled with the Surface</param>
    ///<param name="absoluteTolerance">(float) Optional, default value: <c>State.Doc.ModelAbsoluteTolerance</c>
    ///    Absolute tolerance</param>
    ///<param name="relativeTolerance">(float) Optional, default value: <c>State.Doc.ModelRelativeTolerance</c>
    ///    Relative tolerance</param>
    ///<returns>(Guid ResizeArray * Guid ResizeArray) Two lists: List of unrolled Surface ids and list of following objects.</returns>
    static member UnrollSurface( surfaceId:Guid,
                                 [<OPT;DEF(false)>]explode:bool,
                                 [<OPT;DEF(null:Guid seq)>]followingGeometry:Guid seq,
                                 [<OPT;DEF(0.0)>]absoluteTolerance:float,
                                 [<OPT;DEF(0.0)>]relativeTolerance:float) : Guid ResizeArray * Guid ResizeArray =
        let brep = RhinoScriptSyntax.CoerceBrep(surfaceId)
        let unroll = Unroller(brep)
        unroll.ExplodeOutput <- explode
        let relativeTolerance = Util.ifZero1 relativeTolerance  State.Doc.ModelRelativeTolerance
        let  absoluteTolerance = Util.ifZero1 absoluteTolerance  State.Doc.ModelAbsoluteTolerance
        unroll.AbsoluteTolerance <- absoluteTolerance
        unroll.RelativeTolerance <- relativeTolerance
        if notNull followingGeometry then
            for objectId in followingGeometry do
                let geom = RhinoScriptSyntax.CoerceGeometry(objectId)
                match geom with
                | :? Curve as g -> unroll.AddFollowingGeometry(g) //TODO verify order is correct ???
                | :? Point as g -> unroll.AddFollowingGeometry(g)
                | :? TextDot as g -> unroll.AddFollowingGeometry(g)
                | _ -> RhinoScriptingException.Raise "RhinoScriptSyntax.UnrollSurface: cannot add (a %s) as following Geometry" (Nice.str objectId)

        let breps, curves, points, dots = unroll.PerformUnroll()
        if isNull breps then RhinoScriptingException.Raise "RhinoScriptSyntax.UnrollSurface: failed on  %A" surfaceId
        let rc =  resizeArray { for brep in breps do yield State.Doc.Objects.AddBrep(brep) }
        let newfollowing = ResizeArray()
        for curve in curves do
            let objectId = State.Doc.Objects.AddCurve(curve) //TODO verify order is correct ???
            newfollowing.Add(objectId)
        for point in points do
            let objectId = State.Doc.Objects.AddPoint(point)
            newfollowing.Add(objectId)
        for dot in dots do
            let objectId = State.Doc.Objects.AddTextDot(dot)
            newfollowing.Add(objectId)
        State.Doc.Views.Redraw()
        rc, newfollowing


    ///<summary>Changes the degree of a Surface object. For more information see the Rhino help file for the ChangeDegree command.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<param name="degree">(int * int) Two integers, specifying the degrees for the U  V directions</param>
    ///<returns>(bool) True of False indicating success or failure.</returns>
    static member ChangeSurfaceDegree(objectId:Guid, degree:int * int) : bool =
        let surface = RhinoScriptSyntax.CoerceNurbsSurface(objectId)
        let u, v = degree
        let maxnurbsdegree = 11
        if u < 1 || u > maxnurbsdegree || v < 1 || v > maxnurbsdegree ||  (surface.Degree(0) = u && surface.Degree(1) = v) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.ChangeSurfaceDegree failed on %A" (Nice.str objectId)
        let mutable r = false
        if surface.IncreaseDegreeU(u) then
            if surface.IncreaseDegreeV(v) then
                r <- State.Doc.Objects.Replace(objectId, surface)
        r



    //---End of header marker: don't change: {@$%^&*()*&^%$@}


    ///<summary>Closes a currently open tool-bar collection.</summary>
    ///<param name="name">(string) Name of a currently open tool-bar collection</param>
    ///<param name="prompt">(bool) Optional, default value: <c>false</c>
    ///    If True, user will be prompted to save the collection file
    ///    if it has been modified prior to closing</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member CloseToolbarCollection(name:string, [<OPT;DEF(false)>]prompt:bool) : bool =
        let tbfile = RhinoApp.ToolbarFiles.FindByName(name, true)
        if notNull tbfile then  tbfile.Close(prompt)
        else false


    ///<summary>Hides a previously visible tool-bar group in an open tool-bar collection.</summary>
    ///<param name="name">(string) Name of a currently open tool-bar file</param>
    ///<param name="toolbarGroup">(string) Name of a tool-bar group to hide</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member HideToolbar(name:string, toolbarGroup:string) : bool =
        let tbfile = RhinoApp.ToolbarFiles.FindByName(name, true)
        if notNull tbfile then
            let group = tbfile.GetGroup(toolbarGroup)
            if notNull group then
                group.Visible <- false
                true
            else
                false
        else
            false


    ///<summary>Verifies a tool-bar (or tool-bar group) exists in an open collection file.</summary>
    ///<param name="name">(string) Name of a currently open tool-bar file</param>
    ///<param name="toolbar">(string) Name of a tool-bar group</param>
    ///<param name="group">(bool) Optional, default value: <c>false</c>
    ///    If tool-bar parameter is referring to a tool-bar group</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member IsToolbar(name:string, toolbar:string, [<OPT;DEF(false)>]group:bool) : bool =
       let tbfile = RhinoApp.ToolbarFiles.FindByName(name, true)
       if notNull tbfile then
           if group then
              tbfile.GetGroup(toolbar) |> notNull
           else
              seq { for i = 0 to tbfile.ToolbarCount-1 do yield tbfile.GetToolbar(i).Name }
              |> Seq.exists (fun n -> n= toolbar)
           //tbfile.GetToolbar(tool-bar) <> null // Fails in Rhino 5 with string
       else
           false


    ///<summary>Checks if a tool-bar collection is open.</summary>
    ///<param name="file">(string) Full path to a tool-bar collection file</param>
    ///<returns>(string) Rhino-assigned name of the tool-bar collection.</returns>
    static member IsToolbarCollection(file:string) : string =
        let tbfile = RhinoApp.ToolbarFiles.FindByPath(file)
        if notNull tbfile then  tbfile.Name
        else ""


    ///<summary>Checks if a tool-bar group in an open tool-bar collection is visible.</summary>
    ///<param name="name">(string) Name of a currently open tool-bar file</param>
    ///<param name="toolbarGroup">(string) Name of a tool-bar group</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member IsToolbarDocked(name:string, toolbarGroup:string) : bool =
        let tbfile = RhinoApp.ToolbarFiles.FindByName(name, true)
        if notNull tbfile then
            let group = tbfile.GetGroup(toolbarGroup)
            if notNull group then  group.IsDocked
            else RhinoScriptingException.Raise "RhinoScriptSyntax.IsToolbarDocked failed on name '%s'" name
        else RhinoScriptingException.Raise "RhinoScriptSyntax.IsToolbarDocked failed on name '%s'" name


    ///<summary>Checks if a tool-bar group in an open tool-bar collection is visible.</summary>
    ///<param name="name">(string) Name of a currently open tool-bar file</param>
    ///<param name="toolbarGroup">(string) Name of a tool-bar group</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member IsToolbarVisible(name:string, toolbarGroup:string) : bool =
        let tbfile = RhinoApp.ToolbarFiles.FindByName(name, true)
        if notNull tbfile then
            let group = tbfile.GetGroup(toolbarGroup)
            if notNull group then  group.Visible
            else RhinoScriptingException.Raise "RhinoScriptSyntax.IsToolbarVisible failed on name '%s'" name
        else RhinoScriptingException.Raise "RhinoScriptSyntax.IsToolbarVisible failed on name '%s'" name


    ///<summary>Opens a tool-bar collection file.</summary>
    ///<param name="file">(string) Full path to the collection file</param>
    ///<returns>(string) Rhino-assigned name of the tool-bar collection.</returns>
    static member OpenToolbarCollection(file:string) : string =
        let tbfile = RhinoApp.ToolbarFiles.Open(file)
        if notNull tbfile then  tbfile.Name
        else RhinoScriptingException.Raise "RhinoScriptSyntax.OpenToolbarCollection failed on file '%s'" file


    ///<summary>Saves an open tool-bar collection to disk.</summary>
    ///<param name="name">(string) Name of a currently open tool-bar file</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member SaveToolbarCollection(name:string) : bool =
        let tbfile = RhinoApp.ToolbarFiles.FindByName(name, true)
        if notNull tbfile then  tbfile.Save()
        else false


    ///<summary>Saves an open tool-bar collection to a different disk file.</summary>
    ///<param name="name">(string) Name of a currently open tool-bar file</param>
    ///<param name="file">(string) Full path to file name to save to</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member SaveToolbarCollectionAs(name:string, file:string) : bool =
        let tbfile = RhinoApp.ToolbarFiles.FindByName(name, true)
        if notNull tbfile then  tbfile.SaveAs(file)
        else false


    ///<summary>Shows a previously hidden tool-bar group in an open tool-bar collection.</summary>
    ///<param name="name">(string) Name of a currently open tool-bar file</param>
    ///<param name="toolbarGroup">(string) Name of a tool-bar group to show</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member ShowToolbar(name:string, toolbarGroup:string) : bool =
        let tbfile = RhinoApp.ToolbarFiles.FindByName(name, true)
        if notNull tbfile then
            let group = tbfile.GetGroup(toolbarGroup)
            if notNull group then
                group.Visible <- true
                true
            else
                false
        else
            false


    ///<summary>Returns number of currently open tool-bar collections.</summary>
    ///<returns>(int) The number of currently open tool-bar collections.</returns>
    static member ToolbarCollectionCount() : int =
        RhinoApp.ToolbarFiles.Count


    ///<summary>Returns names of all currently open tool-bar collections.</summary>
    ///<returns>(string ResizeArray) The names of all currently open tool-bar collections.</returns>
    static member ToolbarCollectionNames() : string ResizeArray =
        resizeArray { for tbfile in RhinoApp.ToolbarFiles -> tbfile.Name }


    ///<summary>Returns full path to a currently open tool-bar collection file.</summary>
    ///<param name="name">(string) Name of currently open tool-bar collection</param>
    ///<returns>(string) The full path.</returns>
    static member ToolbarCollectionPath(name:string) : string =
        let tbfile = RhinoApp.ToolbarFiles.FindByName(name, true)
        if notNull tbfile then  tbfile.Path
        else ""


    ///<summary>Returns the number of tool-bars or groups in a currently open tool-bar file.</summary>
    ///<param name="name">(string) Name of currently open tool-bar collection</param>
    ///<param name="groups">(bool) Optional, default value: <c>false</c>
    ///    If true, return the number of tool-bar groups in the file</param>
    ///<returns>(int) number of tool-bars.</returns>
    static member ToolbarCount(name:string, [<OPT;DEF(false)>]groups:bool) : int =
        let tbfile = RhinoApp.ToolbarFiles.FindByName(name, true)
        if notNull tbfile then
            if groups then  tbfile.GroupCount
            else tbfile.ToolbarCount
        else
            -1


    ///<summary>Returns the names of all tool-bars (or tool-bar groups) found in a
    ///    currently open tool-bar file.</summary>
    ///<param name="name">(string) Name of currently open tool-bar collection</param>
    ///<param name="groups">(bool) Optional, default value: <c>false</c>
    ///    If true, return the names of tool-bar groups in the file</param>
    ///<returns>(string ResizeArray) names of all tool-bars (or tool-bar groups).</returns>
    static member ToolbarNames(name:string, [<OPT;DEF(false)>]groups:bool) : string ResizeArray =
        let tbfile = RhinoApp.ToolbarFiles.FindByName(name, true)
        let rc = ResizeArray()
        if notNull tbfile then
            if groups then
                for i = 0 to tbfile.GroupCount-1 do rc.Add(tbfile.GetGroup(i).Name)
            else
                for i = 0 to tbfile.ToolbarCount-1 do rc.Add(tbfile.GetToolbar(i).Name)
        rc



    //---End of header marker: don't change: {@$%^&*()*&^%$@}


    ///<summary>Verifies a matrix is the identity matrix.</summary>
    ///<param name="xForm">(Transform) Rhino.Geometry.Transform. A 4x4 transformation matrix</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member IsXformIdentity(xForm:Transform) : bool =
        xForm = Transform.Identity


    ///<summary>Verifies a matrix is a similarity transformation. A similarity
    ///    transformation can be broken into a sequence of dilatations, translations,
    ///    rotations, and reflections.</summary>
    ///<param name="xForm">(Transform) Rhino.Geometry.Transform. A 4x4 transformation matrix</param>
    ///<returns>(bool) True if this transformation is an orientation preserving similarity, otherwise False.</returns>
    static member IsXformSimilarity(xForm:Transform) : bool =
        xForm.SimilarityType <> TransformSimilarityType.NotSimilarity


    ///<summary>Checks if a matrix is a zero transformation matrix.</summary>
    ///<param name="xForm">(Transform) Rhino.Geometry.Transform. A 4x4 transformation matrix</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member IsXformZero(xForm:Transform) : bool =
        xForm.IsZero4x4



    ///<summary>Returns a change of basis transformation matrix or None on error.</summary>
    ///<param name="initialPlane">(Plane) The initial Plane</param>
    ///<param name="finalPlane">(Plane) The final Plane</param>
    ///<returns>(Transform) The 4x4 transformation matrix.</returns>
    static member XformChangeBasis(initialPlane:Plane, finalPlane:Plane) : Transform =
        let xForm = Transform.ChangeBasis(initialPlane, finalPlane)
        if not xForm.IsValid then RhinoScriptingException.Raise "RhinoScriptSyntax.XformChangeBasis failed.  initialPlane:'%A' finalPlane:'%A'" initialPlane finalPlane
        xForm


    ///<summary>Returns a change of basis transformation matrix of None on error.</summary>
    ///<param name="x0">(Vector3d) X of initial basis</param>
    ///<param name="y0">(Vector3d) Y of initial basis</param>
    ///<param name="z0">(Vector3d) Z of initial basis</param>
    ///<param name="x1">(Vector3d) X of final basis</param>
    ///<param name="y1">(Vector3d) Y of final basis</param>
    ///<param name="z1">(Vector3d) Z of final basis</param>
    ///<returns>(Transform) The 4x4 transformation matrix.</returns>
    static member XformChangeBasis2( x0:Vector3d,
                                     y0:Vector3d,
                                     z0:Vector3d,
                                     x1:Vector3d,
                                     y1:Vector3d,
                                     z1:Vector3d) : Transform =
        let xForm = Transform.ChangeBasis(x0, y0, z0, x1, y1, z1)
        if not xForm.IsValid   then RhinoScriptingException.Raise "RhinoScriptSyntax.XformChangeBasis2 failed.  x0:'%A' y0:'%A' z0:'%A' x1:'%A' y1:'%A' z1:'%A'" x0 y0 z0 x1 y1 z1
        xForm


    ///<summary>Compares two transformation matrices.</summary>
    ///<param name="xForm1">(Transform) First matrix to compare</param>
    ///<param name="xForm2">(Transform) Second matrix to compare</param>
    ///<returns>(int) -1 if xForm1 is smaller than xForm2
    ///    1 if xForm1 bigger than xForm2
    ///    0 if xForm1 = xForm2.</returns>
    static member XformCompare(xForm1:Transform, xForm2:Transform) : int =
        xForm1.CompareTo(xForm2)


    ///<summary>Transform point from construction Plane coordinates to world coordinates.</summary>
    ///<param name="point">(Point3d) A 3D point in construction Plane coordinates</param>
    ///<param name="plane">(Plane) The construction Plane</param>
    ///<returns>(Point3d) A 3D point in world coordinates.</returns>
    static member XformCPlaneToWorld(point:Point3d, plane:Plane) : Point3d =
        plane.Origin + point.X*plane.XAxis + point.Y*plane.YAxis + point.Z*plane.ZAxis


    ///<summary>Returns the determinant of a transformation matrix. If the determinant
    ///    of a transformation matrix is 0, the matrix is said to be singular. Singular
    ///    matrices do not have inverses.</summary>
    ///<param name="xForm">(Transform) Rhino.Geometry.Transform. A 4x4 transformation matrix</param>
    ///<returns>(float) The determinant.</returns>
    static member XformDeterminant(xForm:Transform) : float =
        xForm.Determinant


    ///<summary>Returns a diagonal transformation matrix. Diagonal matrices are 3x3 with
    ///    the bottom row [0, 0, 0, 1].</summary>
    ///<param name="diagonalValue">(float) The diagonal value</param>
    ///<returns>(Transform) The 4x4 transformation matrix.</returns>
    static member XformDiagonal(diagonalValue:float) : Transform =
        Transform(diagonalValue)


    ///<summary>returns the identity transformation matrix.</summary>
    ///<returns>(Transform) The 4x4 transformation matrix.</returns>
    static member XformIdentity() : Transform =
        Transform.Identity


    ///<summary>Returns the inverse of a non-singular transformation matrix.</summary>
    ///<param name="xForm">(Transform) Rhino.Geometry.Transform. A 4x4 transformation matrix</param>
    ///<returns>(Transform) The inverted 4x4 transformation matrix.</returns>
    static member XformInverse(xForm:Transform) : Transform =
        let rc, inverse = xForm.TryGetInverse()
        if not rc then RhinoScriptingException.Raise "RhinoScriptSyntax.XformInverse failed.  xForm:'%A'" xForm
        inverse


    ///<summary>Creates a mirror transformation matrix.</summary>
    ///<param name="mirrorPlanePoint">(Point3d) Point on the mirror Plane</param>
    ///<param name="mirrorPlaneNormal">(Vector3d) A 3D vector that is normal to the mirror Plane</param>
    ///<returns>(Transform) mirror Transform matrix.</returns>
    static member XformMirror(mirrorPlanePoint:Point3d, mirrorPlaneNormal:Vector3d) : Transform =
        Transform.Mirror(mirrorPlanePoint, mirrorPlaneNormal)


    ///<summary>Multiplies two transformation matrices, where result = xForm1 * xForm2.</summary>
    ///<param name="xForm1">(Transform) Rhino.Geometry.Transform. The first 4x4 transformation matrix to multiply</param>
    ///<param name="xForm2">(Transform) Rhino.Geometry.Transform. The second 4x4 transformation matrix to multiply</param>
    ///<returns>(Transform) result transformation.</returns>
    static member XformMultiply(xForm1:Transform, xForm2:Transform) : Transform =
        xForm1*xForm2


    ///<summary>Returns a transformation matrix that projects to a Plane.</summary>
    ///<param name="plane">(Plane) The Plane to project to</param>
    ///<returns>(Transform) The 4x4 transformation matrix.</returns>
    static member XformPlanarProjection(plane:Plane) : Transform =
        Transform.PlanarProjection(plane)


    ///<summary>Returns a rotation transformation that maps initialPlane to finalPlane.
    ///    The Planes should be right hand orthonormal Planes.</summary>
    ///<param name="initialPlane">(Plane) Plane to rotate from</param>
    ///<param name="finalPlane">(Plane) Plane to rotate to</param>
    ///<returns>(Transform) The 4x4 transformation matrix.</returns>
    static member XformRotation1(initialPlane:Plane, finalPlane:Plane) : Transform =
        let xForm = Transform.PlaneToPlane(initialPlane, finalPlane)
        if not xForm.IsValid   then RhinoScriptingException.Raise "RhinoScriptSyntax.XformRotation1 failed.  initialPlane:'%A' finalPlane:'%A'" initialPlane finalPlane
        xForm


    ///<summary>Returns a rotation transformation around an axis.</summary>
    ///<param name="angleDegrees">(float) Rotation angle in degrees</param>
    ///<param name="rotationAxis">(Vector3d) Rotation axis</param>
    ///<param name="centerPoint">(Point3d) Rotation center</param>
    ///<returns>(Transform) The 4x4 transformation matrix.</returns>
    static member XformRotation2( angleDegrees:float,
                                  rotationAxis:Vector3d,
                                  centerPoint:Point3d) : Transform =
        let anglerad = toRadians(angleDegrees)
        let xForm = Transform.Rotation(anglerad, rotationAxis, centerPoint)
        if not xForm.IsValid   then RhinoScriptingException.Raise "RhinoScriptSyntax.XformRotation2 failed.  angleDegrees:'%A' rotationAxis:'%A' centerPoint:'%A'" angleDegrees rotationAxis centerPoint
        xForm


    ///<summary>Calculate the minimal transformation that rotates startDirection to
    ///    endDirection while fixing centerPoint.</summary>
    ///<param name="startDirection">(Vector3d) Start direction</param>
    ///<param name="endDirection">(Vector3d) End direction</param>
    ///<param name="centerPoint">(Point3d) The rotation center</param>
    ///<returns>(Transform) The 4x4 transformation matrix.</returns>
    static member XformRotation3( startDirection:Vector3d,
                                  endDirection:Vector3d,
                                  centerPoint:Point3d) : Transform =
        let xForm = Transform.Rotation(startDirection, endDirection, centerPoint)
        if not xForm.IsValid   then RhinoScriptingException.Raise "RhinoScriptSyntax.XformRotation3 failed.  startDirection:'%A' endDirection:'%A' centerPoint:'%A'" startDirection endDirection centerPoint
        xForm


    ///<summary>Returns a rotation transformation.</summary>
    ///<param name="x0">(Vector3d) X of Vector defining the initial orthonormal frame</param>
    ///<param name="y0">(Vector3d) Y of Vector defining the initial orthonormal frame</param>
    ///<param name="z0">(Vector3d) Z of Vector defining the initial orthonormal frame</param>
    ///<param name="x1">(Vector3d) X of Vector defining the final orthonormal frame</param>
    ///<param name="y1">(Vector3d) Y of Vector defining the final orthonormal frame</param>
    ///<param name="z1">(Vector3d) Z of Vector defining the final orthonormal frame</param>
    ///<returns>(Transform) The 4x4 transformation matrix.</returns>
    static member XformRotation4( x0:Vector3d,
                                  y0:Vector3d,
                                  z0:Vector3d,
                                  x1:Vector3d,
                                  y1:Vector3d,
                                  z1:Vector3d) : Transform =
        let xForm = Transform.Rotation(x0, y0, z0, x1, y1, z1)
        if not xForm.IsValid   then RhinoScriptingException.Raise "RhinoScriptSyntax.XformRotation4 failed.  x0:'%A' y0:'%A' z0:'%A' x1:'%A' y1:'%A' z1:'%A'" x0 y0 z0 x1 y1 z1
        xForm


    ///<summary>Creates a scale transformation.</summary>
    ///<param name="scaleX">(float) Scale in X direction</param>
    ///<param name="scaleY">(float) Scale in Y direction</param>
    ///<param name="scaleZ">(float) Scale in Z direction</param>
    ///<param name="point">(Point3d) Center of scale</param>
    ///<returns>(Transform) The 4x4 transformation matrix.</returns>
    static member XformScale(scaleX, scaleY, scaleZ, point:Point3d) : Transform =
        let plane = Plane(point, Vector3d.ZAxis)
        Transform.Scale(plane, scaleX, scaleY, scaleZ)

    ///<summary>Creates a scale transformation based on World Origin point.</summary>
    ///<param name="scale">(float) Scale in X , Y and Z direction</param>
    ///<returns>(Transform) The 4x4 transformation matrix.</returns>
    static member XformScale(scale) : Transform =
        Transform.Scale(Plane.WorldXY, scale, scale, scale)

    ///<summary>Creates a scale transformation.</summary>
    ///<param name="scale">(float) Scale in X , Y and Z direction</param>
    ///<param name="point">(Point3d) Center of scale</param>
    ///<returns>(Transform) The 4x4 transformation matrix.</returns>
    static member XformScale(scale, point:Point3d) : Transform =
        let plane = Plane(point, Vector3d.ZAxis)
        Transform.Scale(plane, scale, scale, scale)


    ///<summary>Transforms a point from either client-area coordinates of the specified view
    ///    or screen coordinates to world coordinates. The resulting coordinates are represented
    ///    as a 3-D point.</summary>
    ///<param name="point">(Point3d) 2D point</param>
    ///<param name="view">(string) Optional, Title of a view. If omitted, the active view is used</param>
    ///<param name="screenCoordinates">(bool) Optional, default value: <c>false</c>
    ///    If False, point is in client-area coordinates. If True,
    ///    point is in screen-area coordinates</param>
    ///<returns>(Point3d) The transformedPoint.</returns>
    static member XformScreenToWorld( point:Point3d,
                                      [<OPT;DEF(null:string)>]view:string,
                                      [<OPT;DEF(false)>]screenCoordinates:bool) : Point3d =
        let view = RhinoScriptSyntax.CoerceView(view |? "") // ""to get active view
        let viewport = view.MainViewport
        let xForm = viewport.GetTransform(DocObjects.CoordinateSystem.Screen, DocObjects.CoordinateSystem.World)
        let mutable point3d = Point3d(point.X, point.Y, 0.0)
        if  screenCoordinates then
            let screen = view.ScreenRectangle
            point3d.X <- point.X - (float screen.Left) //TODO check if correct?
            point3d.Y <- point.Y - (float screen.Top)
        point3d <- xForm * point3d
        point3d


    ///<summary>Returns a shear transformation matrix.</summary>
    ///<param name="plane">(Plane) Plane.Origin is the fixed point</param>
    ///<param name="x">(Vector3d) X axis scale vector</param>
    ///<param name="y">(Vector3d) Y axis scale vector</param>
    ///<param name="z">(Vector3d) Z axis scale vector</param>
    ///<returns>(Transform) The 4x4 transformation matrix.</returns>
    static member XformShear( plane:Plane,
                              x:Vector3d,
                              y:Vector3d,
                              z:Vector3d) : Transform =
        Transform.Shear(plane, x, y, z)


    ///<summary>Creates a translation transformation matrix.</summary>
    ///<param name="vector">(Vector3d) List of 3 numbers, Point3d, or Vector3d. A 3-D translation vector</param>
    ///<returns>(Transform) The 4x4 transformation matrix if successful.</returns>
    static member XformTranslation(vector:Vector3d) : Transform =
        Transform.Translation(vector)


    ///<summary>Transforms a point from world coordinates to construction Plane coordinates.</summary>
    ///<param name="point">(Point3d) A 3D point in world coordinates</param>
    ///<param name="plane">(Plane) The construction Plane</param>
    ///<returns>(Point3d) 3D point in construction Plane coordinates.</returns>
    static member XformWorldToCPlane(point:Point3d, plane:Plane) : Point3d =
        let v = point - plane.Origin;
        Point3d(v*plane.XAxis, v*plane.YAxis, v*plane.ZAxis)


    ///<summary>Transforms a point from world coordinates to either client-area coordinates of
    ///    the specified view or screen coordinates. The resulting coordinates are represented
    ///    as a 2D point.</summary>
    ///<param name="point">(Point3d) 3D point in world coordinates</param>
    ///<param name="view">(string) Optional, Title of a view. If omitted, the active view is used</param>
    ///<param name="screenCoordinates">(bool) Optional, default value: <c>false</c>
    ///    If False, the function returns the results as
    ///    client-area coordinates. If True, the result is in screen-area coordinates</param>
    ///<returns>(Point2d) 2D point.</returns>
    static member XformWorldToScreen( point:Point3d,
                                      [<OPT;DEF(null:string)>]view:string,
                                      [<OPT;DEF(false)>]screenCoordinates:bool) : Point2d =
        let view = RhinoScriptSyntax.CoerceView(view |? "")// to get active view
        let viewport = view.MainViewport
        let xForm = viewport.GetTransform(DocObjects.CoordinateSystem.World, DocObjects.CoordinateSystem.Screen)
        let mutable point3 = xForm * point
        let mutable point = Point2d(point3.X, point3.Y)
        if  screenCoordinates then
            let screen = view.ScreenRectangle
            point.X <- point.X + (float screen.Left)
            point.Y <- point.Y + (float screen.Top)
        point


    ///<summary>Returns a zero transformation matrix.</summary>
    ///<returns>(Transform) a zero transformation matrix.</returns>
    static member XformZero() : Transform =
        Transform()



    //---End of header marker: don't change: {@$%^&*()*&^%$@}


    ///<summary>Removes user data strings from the current document.</summary>
    ///<param name="section">(string) Optional, Section name. If omitted, all sections and their corresponding entries are removed</param>
    ///<param name="entry">(string) Optional, Entry name. If omitted, all entries for section are removed</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DeleteDocumentData([<OPT;DEF(null:string)>]section:string, [<OPT;DEF(null:string)>]entry:string) : unit =
        State.Doc.Strings.Delete(section, entry) //TODO check null case


    ///<summary>Returns the number of user data strings in the current document.</summary>
    ///<returns>(int) The number of user data strings in the current document.</returns>
    static member DocumentDataCount() : int =
        State.Doc.Strings.DocumentDataCount


    ///<summary>Returns the number of user text strings in the current document.</summary>
    ///<returns>(int) The number of user text strings in the current document.</returns>
    static member DocumentUserTextCount() : int =
        State.Doc.Strings.DocumentUserTextCount


    ///<summary>Returns a user data item from the current document.</summary>
    ///<param name="sectionName">(string) Optional, Section name. If omitted, all section names are returned</param>
    ///<returns>(string array) Array of all section names if sectionName is omitted,
    /// else all entry names in this section.</returns>
    static member GetDocumentData([<OPT;DEF(null:string)>]sectionName:string) : array<string> =
        if notNull sectionName then
            State.Doc.Strings.GetSectionNames()
        else
            State.Doc.Strings.GetEntryNames(sectionName)

    ///<summary>Returns a user data item  entry from the current document.</summary>
    ///<param name="section">(string) Section name</param>
    ///<param name="entry">(string) Entry name</param>
    ///<returns>(string) The entry value.</returns>
    static member GetDocumentDataEntry(section:string, entry:string) : string =
        State.Doc.Strings.GetValue(section, entry)


    ///<summary>Returns user text stored in the document.</summary>
    ///<param name="key">(string) Key to use for retrieving user text</param>
    ///<returns>(string) If key is specified, then the associated value.</returns>
    static member GetDocumentUserText(key:string) : string =
        State.Doc.Strings.GetValue(key) //TODO add null checking

    ///<summary>Returns all document user text keys.</summary>
    ///<returns>(string ResizeArray) all document user text keys.</returns>
    static member GetDocumentUserTextKeys() : string ResizeArray =
        resizeArray {
            for i = 0 to State.Doc.Strings.Count-1  do
                let k = State.Doc.Strings.GetKey(i)
                if not <| k.Contains "\\" then  // TODO why ??
                    yield k
            }


    ///<summary>Returns all user text keys stored on an object.</summary>
    ///<param name="objectId">(Guid) The object's identifies</param>
    ///<param name="attachedToGeometry">(bool) Optional, default value: <c>false</c>
    ///    Location on the object to retrieve the user text</param>
    ///<returns>(string ResizeArray) all keys.</returns>
    static member GetUserTextKeys(objectId:Guid, [<OPT;DEF(false)>]attachedToGeometry:bool) : string ResizeArray =
        let obj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if attachedToGeometry then
            let uss = obj.Geometry.GetUserStrings()
            resizeArray { for  i = 0 to uss.Count-1 do yield uss.GetKey(i)}
        else
            let uss = obj.Attributes.GetUserStrings()
            resizeArray { for  i = 0 to uss.Count-1 do yield uss.GetKey(i)}


    ///<summary>Returns user text stored on an object, fails if non existing.</summary>
    ///<param name="objectId">(Guid) The object's identifies</param>
    ///<param name="key">(string) The key name</param>
    ///<param name="attachedToGeometry">(bool) Optional, default value: <c>false</c>
    ///    Location on the object to retrieve the user text</param>
    ///<returns>(string) if key is specified, the associated value,fails if non existing.</returns>
    static member GetUserText(objectId:Guid, key:string, [<OPT;DEF(false)>]attachedToGeometry:bool) : string =
        let obj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let s =
            if attachedToGeometry then  obj.Geometry.GetUserString(key)
            else                        obj.Attributes.GetUserString(key)

        if isNull s then
            let err = Text.StringBuilder()
            let addLn (s:String) = err.AppendLine s |> ignore
            let add (s:String) = err.Append s |> ignore
            addLn <| sprintf "RhinoScriptSyntax.GetUserText key: '%s' does not exist on %s" key (Nice.str objectId)
            let ks = RhinoScriptSyntax.GetUserTextKeys(objectId, attachedToGeometry=false)
            if ks.Count = 0 then
                addLn  "This Object does not have any UserText."
            else
                addLn  "Available keys on Object are:"
                for k in RhinoScriptSyntax.GetUserTextKeys(objectId, attachedToGeometry=false) do
                    add "    "
                    addLn k
            let gks = RhinoScriptSyntax.GetUserTextKeys(objectId, attachedToGeometry=true)
            if gks.Count > 0 then
                addLn "Available keys on Geometry:"
                for k in RhinoScriptSyntax.GetUserTextKeys(objectId, attachedToGeometry=true) do
                    add "    "
                    addLn k

            RhinoScriptingException.Raise "%s" (err.ToString())
        s

    ///<summary>Returns user text stored on an object, returns Option.None if non existing.</summary>
    ///<param name="objectId">(Guid) The object's identifies</param>
    ///<param name="key">(string) The key name</param>
    ///<param name="attachedToGeometry">(bool) Optional, default value: <c>false</c>
    ///    Location on the object to retrieve the user text</param>
    ///<returns>(string Option) if key is specified, Some(value) else None .</returns>
    static member TryGetUserText(objectId:Guid, key:string, [<OPT;DEF(false)>]attachedToGeometry:bool) : string Option=
        let obj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let s =
            if attachedToGeometry then  obj.Geometry.GetUserString(key)
            else                        obj.Attributes.GetUserString(key)
        if isNull s then None
        else Some s

    ///<summary>Checks if a User Text key is stored on an object.</summary>
    ///<param name="objectId">(Guid) The object's identifies</param>
    ///<param name="key">(string) The key name</param>
    ///<param name="attachedToGeometry">(bool) Optional, default value: <c>false</c> Location on the object to retrieve the user text</param>
    ///<returns>(bool) if key exist true.</returns>
    static member HasUserText(objectId:Guid, key:string, [<OPT;DEF(false)>]attachedToGeometry:bool) : bool =
        let obj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if attachedToGeometry then
            notNull <| obj.Geometry.GetUserString(key)
        else
            notNull <| obj.Attributes.GetUserString(key)


    ///<summary>Checks if the current document contains user data.</summary>
    ///<returns>(bool) True or False indicating the presence of Script user data.</returns>
    static member IsDocumentData() : bool =
        State.Doc.Strings.Count > 0 //DocumentDataCount > 0


    ///<summary>Checks if the current document contains user text.</summary>
    ///<returns>(bool) True or False indicating the presence of Script user text.</returns>
    static member IsDocumentUserText() : bool =
        State.Doc.Strings.Count > 0 //.DocumentUserTextCount > 0


    ///<summary>Checks if an object contains user text.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<returns>(int) result of test:
    ///    0 = no user text
    ///    1 = attribute user text
    ///    2 = geometry user text
    ///    3 = both attribute and geometry user text.</returns>
    static member IsUserText(objectId:Guid) : int =
        let obj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        let mutable rc = 0
        if obj.Attributes.UserStringCount > 0 then  rc <- rc ||| 1
        if obj.Geometry.UserStringCount > 0   then  rc <- rc ||| 2
        rc


    ///<summary>Adds or sets a user data string to the current document.</summary>
    ///<param name="section">(string) The section name</param>
    ///<param name="entry">(string) The entry name</param>
    ///<param name="value">(string) The string value</param>
    ///<returns>(unit) void, nothing.</returns>
    static member SetDocumentData(section:string, entry:string, value:string) : unit =
        // TODO verify input strings
        State.Doc.Strings.SetString(section, entry, value) |> ignore


    ///<summary>Sets a user text stored in the document.</summary>
    ///<param name="key">(string) Key name to set. Cannot be empty string.</param>
    ///<param name="value">(string) The string value to set. Can be empty string. To delete a key use rs.DeleteDocumentUserText</param>
    ///<param name="allowAllUnicode">(bool) Optional, default value: <c>false</c> , set to true to allow all Unicode characters,
    ///     (even the ones that look like ASCII characters but are not ASCII) in the value</param>
    ///<returns>(unit) void, nothing.</returns>
    static member SetDocumentUserText(key:string, value:string, [<OPT;DEF(false)>]allowAllUnicode:bool) : unit =
        if not <|  RhinoScriptSyntax.IsGoodStringId( key, allowEmpty=false) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.SetDocumentUserText the string '%s' cannot be used as key. See RhinoScriptSyntax.IsGoodStringId. You may be able bypass this restrictions in Rhino.Scripting by using RhinoCommon directly." key

        if allowAllUnicode then
            if not <| Util.isAcceptableStringId( value, true) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.SetDocumentUserText the string '%s' cannot be used as value. See RhinoScriptSyntax.IsGoodStringId. You can use RhinoCommon to bypass some of these restrictions." value
        else
            if not <|  RhinoScriptSyntax.IsGoodStringId( value, allowEmpty=true) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.SetDocumentUserText the string '%s' cannot be used as value. You may be able bypass this restrictions by using the optional argument: allowAllUnicode=true" value
        State.Doc.Strings.SetString(key, value) |> ignore


    ///<summary>Removes user text stored in the document.</summary>
    ///<param name="key">(string) Key name to delete</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DeleteDocumentUserText(key:string) : unit =
        if isNull key  then RhinoScriptingException.Raise "RhinoScriptSyntax.DeleteDocumentUserText failed on for null key"
        let p = State.Doc.Strings.SetString(key, null)
        if isNull p then RhinoScriptingException.Raise "RhinoScriptSyntax.DeleteDocumentUserText failed,  key '%s' does not exist"  key

    ///<summary>Sets a user text stored on an object. Key and value must noy contain ambiguous Unicode characters.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<param name="key">(string) The key name to set. Cannot be an empty string.</param>
    ///<param name="value">(string) The string value to set. Can be an empty string. Use rs.DeleteUserText to delete keys</param>
    ///<param name="attachToGeometry">(bool) Optional, default value: <c>false</c> Location on the object to store the user text</param>
    ///<param name="allowAllUnicode">(bool) Optional, default value: <c>false</c> , set to true to allow all Unicode characters,
    ///     (even the ones that look like ASCII characters but are not ASCII) in the value</param>
    ///<returns>(unit) void, nothing.</returns>
    static member SetUserText(objectId:Guid, key:string, value:string, [<OPT;DEF(false)>]attachToGeometry:bool, [<OPT;DEF(false)>]allowAllUnicode:bool) : unit =
        if not <| RhinoScriptSyntax.IsGoodStringId( key, allowEmpty=false) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.SetUserText the string '%s' cannot be used as key. See RhinoScriptSyntax.IsGoodStringId. You can use RhinoCommon to bypass some of these restrictions." key

        if allowAllUnicode then
            if not <| Util.isAcceptableStringId( value, true) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.SetUserText the string '%s' cannot be used as value. See RhinoScriptSyntax.IsGoodStringId. You can use RhinoCommon to bypass some of these restrictions." value
        else
            if not <|  RhinoScriptSyntax.IsGoodStringId( value, allowEmpty=true) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.SetUserText the string '%s' cannot be used as value. You may be able bypass this restrictions by using the optional argument: allowAllUnicode=true" value
        let obj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if attachToGeometry then
            if not <| obj.Geometry.SetUserString(key, value) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.SetUserText failed on %s for key '%s' value '%s'" (Nice.str objectId) key value
        else
            if not <| obj.Attributes.SetUserString(key, value) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.SetUserText failed on %s for key '%s' value '%s'" (Nice.str objectId) key value

        obj.CommitChanges() |> ignore // should not be needed but still do it because of this potential bug: https://mcneel.myjetbrains.com/youtrack/issue/RH-71536

    ///<summary>Sets or removes user text stored on multiple objects. Key and value must noy contain ambiguous Unicode characters.</summary>
    ///<param name="objectIds">(Guid seq) The object identifiers</param>
    ///<param name="key">(string) The key name to set. Cannot be an empty string.</param>
    ///<param name="value">(string) The string value to set. Can be an empty string. Use rs.DeleteUserText to delete keys</param>
    ///<param name="attachToGeometry">(bool) Optional, default value: <c>false</c> Location on the object to store the user text</param>
    ///<param name="allowAllUnicode">(bool) Optional, default value: <c>false</c> , set to true to allow Unicode characters,
    ///     (even the ones that look like ASCII characters but are not ASCII) in the value</param>
    ///<returns>(unit) void, nothing.</returns>
    static member SetUserText(objectIds:Guid seq, key:string, value:string, [<OPT;DEF(false)>]attachToGeometry:bool, [<OPT;DEF(false)>]allowAllUnicode:bool) : unit = //PLURAL
        if not <|  RhinoScriptSyntax.IsGoodStringId( key, allowEmpty=false) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.SetUserText the string '%s' cannot be used as key. See RhinoScriptSyntax.IsGoodStringId. You can use RhinoCommon to bypass some of these restrictions." key

        if allowAllUnicode then
            if not <| Util.isAcceptableStringId( value, true) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.SetUserText the string '%s' cannot be used as value. See RhinoScriptSyntax.IsGoodStringId. You can use RhinoCommon to bypass some of these restrictions." value
        else
            if not <|  RhinoScriptSyntax.IsGoodStringId( value, allowEmpty=true) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.SetUserText the string '%s' cannot be used as value. You may be able bypass this restrictions by using the optional argument: allowAllUnicode=true" value

        for objectId in objectIds do
            let obj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            if attachToGeometry then
                if not <| obj.Geometry.SetUserString(key, value) then
                    RhinoScriptingException.Raise "RhinoScriptSyntax.SetUserText failed on %s for key '%s' value '%s'" (Nice.str objectId) key value
            else
                if not <| obj.Attributes.SetUserString(key, value) then
                    RhinoScriptingException.Raise "RhinoScriptSyntax.SetUserText failed on %s for key '%s' value '%s'" (Nice.str objectId) key value
            obj.CommitChanges() |> ignore  // should not be needed but still do it because of this potential bug: https://mcneel.myjetbrains.com/youtrack/issue/RH-71536

    ///<summary>Removes user text stored on an object. If the key exists.</summary>
    ///<param name="objectId">(Guid) The object's identifier</param>
    ///<param name="key">(string) The key name to delete</param>
    ///<param name="attachToGeometry">(bool) Optional, default value: <c>false</c> Location on the object to delete the user text from</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DeleteUserText(objectId:Guid, key:string,  [<OPT;DEF(false)>]attachToGeometry:bool) : unit =
        let obj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
        if attachToGeometry then obj.Geometry.SetUserString  (key, null) |> ignore // returns false if key does not exist yet, otherwise true
        else                     obj.Attributes.SetUserString(key, null) |> ignore
        obj.CommitChanges() |> ignore  // should not be needed but still do it because of this potential bug: https://mcneel.myjetbrains.com/youtrack/issue/RH-71536


    ///<summary>Removes user text stored on multiple objects.If the key exists.</summary>
    ///<param name="objectIds">(Guid seq) The object identifiers</param>
    ///<param name="key">(string) The key name to delete</param>
    ///<param name="attachToGeometry">(bool) Optional, default value: <c>false</c> Location on the object to delete the user text from</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DeleteUserText(objectIds:Guid seq, key:string,  [<OPT;DEF(false)>]attachToGeometry:bool) : unit = //PLURAL
        for objectId in objectIds do
            let obj = RhinoScriptSyntax.CoerceRhinoObject(objectId)
            if attachToGeometry then  obj.Geometry.SetUserString  (key, null) |> ignore // returns false if key does not exist yet, otherwise true
            else                      obj.Attributes.SetUserString(key, null) |> ignore
            obj.CommitChanges() |> ignore  // should not be needed but still do it because of this potential bug: https://mcneel.myjetbrains.com/youtrack/issue/RH-71536


    //---End of header marker: don't change: {@$%^&*()*&^%$@}


    ///<summary>Display browse-for-folder dialog allowing the user to select a folder.</summary>
    ///<param name="folder">(string) Optional, A default folder</param>
    ///<param name="message">(string) Optional, A prompt or message</param>
    /// <param name="title">(string) Optional, A dialog box title</param>
    ///<returns>(string) selected folder or None if selection was canceled.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member BrowseForFolder(
            [<OPT;DEF(null:string)>]folder:string,
            [<OPT;DEF(null:string)>]message:string,
            [<OPT;DEF(null:string)>]title:string) : string =
        let getKeepEditor () =
            use dlg = new Eto.Forms.SelectFolderDialog()
            if notNull folder then
                dlg.Directory <- folder
            if notNull message then
                dlg.Title <- message
            if notNull title then
                dlg.Title <- title
            let parentEtoWindow = null
            if dlg.ShowDialog(parentEtoWindow) = Eto.Forms.DialogResult.Ok then
                dlg.Directory
            else
                RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.BrowseForFolder()"
        RhinoSync.DoSync getKeepEditor

        // use dlg = new Windows.Forms.FolderBrowserDialog()
        // dlg.ShowNewFolderButton <- true
        // if notNull folder then
        //     if IO.Directory.Exists(folder) then
        //         dlg.SelectedPath <-  folder
        // if notNull message then
        //     dlg.Description <- message
        // if dlg.ShowDialog() = Windows.Forms.DialogResult.OK then
        //     dlg.SelectedPath
        // else
        //     RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.BrowseForFolder()"



    ///<summary>Displays a list of items in a checkable-style list dialog box.</summary>
    ///<param name="items">((string*bool) seq) A list of tuples containing a string and a boolean check state</param>
    ///<param name="message">(string) Optional, A prompt or message</param>
    ///<param name="title">(string) Optional, A dialog box title</param>
    ///<returns>((string*bool) ResizeArray) Option of tuples containing the input string in items along with their new boolean check value.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member CheckListBox( items:(string*bool) seq,
                                [<OPT;DEF(null:string)>]message:string,
                                [<OPT;DEF(null:string)>]title:string) :ResizeArray<string*bool> =
        let checkStates = resizeArray { for  item in items -> snd item }
        let itemStrings =    resizeArray { for item in items -> fst item}

        let newCheckStates =
            let getKeepEditor () = UI.Dialogs.ShowCheckListBox(title, message, itemStrings, checkStates)
            RhinoSync.DoSync getKeepEditor

        if notNull newCheckStates then
            (Seq.zip itemStrings newCheckStates |>  ResizeArray.ofSeq)
        else
            //RhinoScriptingException.Raise "RhinoScriptSyntax.CheckListBox failed.  items:'%A' message:'%A' title:'%A'" items message title
            RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.CheckListBox()"


    ///<summary>Displays a list of items in a combo-style list box dialog.</summary>
    ///<param name="items">(string seq) A list of string</param>
    ///<param name="message">(string) Optional, A prompt of message</param>
    ///<param name="title">(string) Optional, A dialog box title</param>
    ///<returns>(string) Option of The selected item.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member ComboListBox(items:string seq, [<OPT;DEF(null:string)>]message:string, [<OPT;DEF(null:string)>]title:string) : string=
        let getKeepEditor () =
            match UI.Dialogs.ShowComboListBox(title, message, items|> Array.ofSeq) with
            | null -> RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.ComboListBox()"
            | :? string as s -> s
            | _ -> RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.ComboListBox()"
        RhinoSync.DoSync getKeepEditor


    ///<summary>Display dialog prompting the user to enter a string. The
    ///    string value may span multiple lines.</summary>
    ///<param name="defaultValString">(string) Optional, A default string value</param>
    ///<param name="message">(string) Optional, A prompt message</param>
    ///<param name="title">(string) Optional, A dialog box title</param>
    ///<returns>(string Option) Option of Multiple lines that are separated by carriage return-linefeed combinations.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member EditBox(  [<OPT;DEF(null:string)>]defaultValString:string,
                            [<OPT;DEF(null:string)>]message:string,
                            [<OPT;DEF(null:string)>]title:string) : string =
        let getKeepEditor () =
            let rc, text = UI.Dialogs.ShowEditBox(title, message, defaultValString, true)
            if rc then text else RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.EditBox()"
        RhinoSync.DoSync getKeepEditor


    ///<summary>Pause for user input of an angle.</summary>
    ///<param name="point">(Point3d) Optional, default value: <c>Point3d.Unset</c>
    ///    Starting, or base point</param>
    ///<param name="referencePoint">(Point3d) Optional, default value: <c>Point3d.Unset</c>
    ///    If specified, the reference angle is calculated from it and the base point</param>
    ///<param name="defaultValAngleDegrees">(float) Optional, A default angle value specified</param>
    ///<param name="message">(string) Optional, A prompt to display</param>
    ///<returns>(float) Option of angle in degree.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetAngle( [<OPT;DEF(Point3d())>]point:Point3d, //TODO make overload instead,[<OPT;DEF(Point3d())>] may leak  see draw vector and transform point!
                            [<OPT;DEF(Point3d())>]referencePoint:Point3d,
                            [<OPT;DEF(0.0)>]defaultValAngleDegrees:float,
                            [<OPT;DEF(null:string)>]message:string) : float=
        let get () =
            let point = if point = Point3d.Origin then Point3d.Unset else point
            let referencepoint = if referencePoint = Point3d.Origin then Point3d.Unset else referencePoint
            let defaultangle = toRadians(defaultValAngleDegrees)
            let rc, angle = Input.RhinoGet.GetAngle(message, point, referencepoint, defaultangle)
            if rc = Commands.Result.Success then toDegrees(angle)
            else RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetAngle()"
        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Pauses for user input of one or more boolean values. Boolean values are
    ///    displayed as click-able Command-line toggles.</summary>
    ///<param name="message">(string) A prompt</param>
    ///<param name="items">((string*string*string) array) List of options. Each is a tuple of three strings
    ///    [n][1]    description of the boolean value. Must only consist of letters and numbers. (no characters like space, period, or dash)
    ///    [n][2]    string identifying the false value
    ///    [n][3]    string identifying the true value</param>
    ///<param name="defaultVals">(bool seq) List of boolean values used as default or starting values</param>
    ///<returns>(bool ResizeArray) Option of a list of values that represent the boolean values.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetBoolean(message:string, items:(string*string*string) array, defaultVals:bool array) : ResizeArray<bool> =
        let get () =
            use go = new Input.Custom.GetOption()
            go.AcceptNothing(true)
            go.SetCommandPrompt( message )
            let count = Seq.length(items)
            if count < 1 || count <> Seq.length(defaultVals) then RhinoScriptingException.Raise "RhinoScriptSyntax.GetBoolean failed.  message:'%A' items:'%A' defaultVals:'%A'" message items defaultVals
            let toggles = ResizeArray()
            for i = 0 to count - 1 do
                let initial = defaultVals.[i]
                let item = items.[i]
                let name, off, on = item
                let t = new Input.Custom.OptionToggle( initial, off, on )
                toggles.Add(t)
                go.AddOptionToggle(name, ref t) |> ignore
            let mutable getrc = go.Get()
            while getrc = Input.GetResult.Option do
                getrc <- go.Get()

            let res =
                if getrc <> Input.GetResult.Nothing then
                    RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetBoolean()"
                else
                    (ResizeArray.map (fun (t:Input.Custom.OptionToggle) ->  t.CurrentValue) toggles)
            res
        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Pauses for user input of a box.</summary>
    ///<param name="mode">(int) Optional, default value: <c>0</c>
    ///    The box selection mode.
    ///    0 = All modes
    ///    1 = Corner. The base rectangle is created by picking two corner points
    ///    2 = 3-Point. The base rectangle is created by picking three points
    ///    3 = Vertical. The base vertical rectangle is created by picking three points.
    ///    4 = Center. The base rectangle is created by picking a center point and a corner point</param>
    ///<param name="basePoint">(Point3d) Optional, Optional 3D base point</param>
    ///<param name="prompt1">(string) Optional, Prompt1 of 'optional prompts to set'</param>
    ///<param name="prompt2">(string) Optional, Prompt2 of 'optional prompts to set'</param>
    ///<param name="prompt3">(string) Optional, Prompt3 of 'optional prompts to set'</param>
    ///<returns>(Point3d array) array of eight Point3d that define the corners of the box.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetBox(   [<OPT;DEF(0)>]mode:int,
                            [<OPT;DEF(Point3d())>]basePoint:Point3d, //TODO make overload instead,[<OPT;DEF(Point3d())>] may leak  see draw vector and transform point!
                            [<OPT;DEF(null:string)>]prompt1:string,
                            [<OPT;DEF(null:string)>]prompt2:string,
                            [<OPT;DEF(null:string)>]prompt3:string) : (Point3d [])=
        let get () =
            let basePoint = if basePoint <> Point3d.Origin then basePoint else  Point3d.Unset
            let m =
                match mode with
                |0 -> Input.GetBoxMode.All
                |1 -> Input.GetBoxMode.Corner
                |2 -> Input.GetBoxMode.ThreePoint
                |3 -> Input.GetBoxMode.Vertical
                |4 -> Input.GetBoxMode.Center
                |_ -> RhinoScriptingException.Raise "RhinoScriptSyntax.GetBox:Bad mode %A" mode

            let box = ref (Box())
            let rc= Input.RhinoGet.GetBox(box, m, basePoint, prompt1, prompt2, prompt3)
            if rc = Commands.Result.Success then ((!box).GetCorners())
            else RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetBox()"
        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Display the Rhino color picker dialog allowing the user to select an RGB color.</summary>
    ///<param name="color">(Drawing.Color) Optional, default value: <c>Drawing.Color.Black</c></param>
    ///<returns>(Drawing.Color) RGB color.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetColor([<OPT;DEF(Drawing.Color())>]color:Drawing.Color) : Drawing.Color =
        let get () =
            let zero = Drawing.Color()
            let mutable col = if color = zero then Drawing.Color.Black else color
            let colRef = &col
            // let rc = UI.Dialogs.ShowColorDialog(col) // needs a ref to WinForms
            // let mi = typeof<UI.Dialogs>.GetMethod("ShowColorDialog", [| typeof<byref<System.Drawing.Color>> |]) // fails
            let methOp =
                typeof<UI.Dialogs>.GetMethods()
                |> Seq.tryFind ( fun m ->
                    let ps = m.GetParameters()
                    ps.Length=1 &&  ps[0].ParameterType.FullName = "System.Drawing.Color&"    )
            match methOp with
            | None -> RhinoScriptingException.Raise "RhinoScriptSyntax.GetColor: ShowColorDialog method not found"
            | Some mi ->
                let rc = unbox<bool> (mi.Invoke(null,[|colRef:>obj|]))
                if not rc then  RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetColor()"
                col

        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Retrieves the cursor's position.</summary>
    ///<returns>(Point3d * Point2d * Guid * Point2d) a Tuple of containing the following information
    ///    0  Point3d: cursor position in world coordinates
    ///    1  Point2d: cursor position in screen coordinates
    ///    2  Guid:    objectId of the active view-port
    ///    3  Point2d: cursor position in client coordinates.</returns>
    static member GetCursorPos() : Point3d * Point2d * Guid * Point2d =
        let get () =   //or skip ?
            let view = State.Doc.Views.ActiveView
            let screenPt = UI.MouseCursor.Location
            let clientPt = view.ScreenToClient(screenPt)
            let viewport = view.ActiveViewport
            let xf = viewport.GetTransform(DocObjects.CoordinateSystem.Screen, DocObjects.CoordinateSystem.World)
            let worldPt = Point3d(clientPt.X, clientPt.Y, 0.0)
            worldPt.Transform(xf)
            worldPt, screenPt, viewport.Id, clientPt
        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Pauses for user input of a distance.</summary>
    ///<param name="firstPt">(Point3d) Optional, First distance point</param>
    ///<param name="distance">(float) Optional, Default distance</param>
    ///<param name="firstPtMsg">(string) Optional, default value: <c>"First distance point"</c>
    ///    Prompt for the first distance point</param>
    ///<param name="secondPtMsg">(string) Optional, default value: <c>"Second distance point"</c>
    ///    Prompt for the second distance point</param>
    ///<returns>(float) The distance between the two points.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetDistance(  [<OPT;DEF(Point3d())>]firstPt:Point3d, //TODO make overload instead,[<OPT;DEF(Point3d())>] may leak  see draw vector and transform point!
                                [<OPT;DEF(0.0)>]distance:float,
                                [<OPT;DEF("First distance point")>]firstPtMsg:string,
                                [<OPT;DEF("Second distance point")>]secondPtMsg:string) : float =
        let get () =
            let pt1 =
                if firstPt = Point3d.Origin then
                    let gp1 = new Input.Custom.GetPoint()
                    gp1.SetCommandPrompt(firstPtMsg)
                    match gp1.Get() with
                    | Input.GetResult.Point ->
                        gp1.Dispose()
                        Some (gp1.Point())
                    | _ ->
                        gp1.Dispose()
                        None
                else
                    Some firstPt

            match pt1 with
            | Some pt ->
                let gp2 = new Input.Custom.GetPoint()
                if distance <> 0.0 then
                    gp2.AcceptNothing(true)
                    gp2.SetCommandPrompt(sprintf "%s<%f>" secondPtMsg distance)
                else
                    gp2.SetCommandPrompt(secondPtMsg)
                gp2.DrawLineFromPoint(pt, true)
                gp2.EnableDrawLineFromPoint(true)
                match gp2.Get() with
                | Input.GetResult.Point ->
                    let d = gp2.Point().DistanceTo(pt)
                    InternalToNiceStringSetup.printfnBlue "Distance: %s %s" (NiceFormat.float d) (
                                State.Doc.GetUnitSystemName(modelUnits=true, capitalize=true, singular=false, abbreviate=false))

                    gp2.Dispose()
                    d
                | _ ->
                    gp2.Dispose()
                    RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetDistance()"
            | _ -> RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetDistance()"
        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Prompt the user to pick one or more Surface or Polysurface edge Curves.</summary>
    ///<param name="message">(string) Optional, default value: <c>Select Edges</c>
    ///    A prompt or message</param>
    ///<param name="minCount">(int) Optional, default value: <c>1</c>
    ///    Minimum number of edges to select</param>
    ///<param name="maxCount">(int) Optional, default value: <c>0</c>
    ///    Maximum number of edges to select</param>
    ///<param name="select">(bool) Optional, default value: <c>false</c>
    ///    Select the duplicated edge Curves</param>
    ///<returns>((Guid*Guid*Point3d) ResizeArray) a List of selection prompts (curve objectId, parent objectId, selection point).
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetEdgeCurves(    [<OPT;DEF("Select Edges")>]message:string,
                                    [<OPT;DEF(1)>]minCount:int,
                                    [<OPT;DEF(0)>]maxCount:int,
                                    [<OPT;DEF(false)>]select:bool) : ResizeArray<Guid*Guid*Point3d> =
        let get () =
            if maxCount > 0 && minCount > maxCount then RhinoScriptingException.Raise "RhinoScriptSyntax.GetEdgeCurves: minCount %d is bigger than  maxCount %d" minCount  maxCount
            use go = new Input.Custom.GetObject()
            go.SetCommandPrompt(message)
            go.GeometryFilter <- DocObjects.ObjectType.Curve
            go.GeometryAttributeFilter <- Input.Custom.GeometryAttributeFilter.EdgeCurve
            go.EnablePreSelect(false, true)
            let rc = go.GetMultiple(minCount, maxCount)
            if rc <> Input.GetResult.Object then RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetEdgeCurves()"
            else
                let r = ResizeArray()
                for i = 0 to go.ObjectCount - 1 do
                    let edge = go.Object(i).Edge()
                    if notNull edge then
                        let crv = edge.Duplicate() :?> NurbsCurve
                        let curveid = State.Doc.Objects.AddCurve(crv)
                        let parentid = go.Object(i).ObjectId
                        let pt = go.Object(i).SelectionPoint()
                        r.Add( (curveid, parentid, pt))
                if  select then
                    for item in r do
                        let rhobj = State.Doc.Objects.FindId(t1 item)
                        rhobj.Select(true)|> ignore
                    State.Doc.Views.Redraw()
                r
        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Pauses for user input of a whole number.</summary>
    ///<param name="message">(string) Optional, A prompt or message</param>
    ///<param name="number">(int) Optional, A default whole number value</param>
    ///<param name="minimum">(int) Optional, A minimum allowable value</param>
    ///<param name="maximum">(int) Optional, A maximum allowable value</param>
    ///<returns>(int) The whole number input by the user.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetInteger(   [<OPT;DEF(null:string)>]message:string,
                                [<OPT;DEF(2147482999)>]number:int,
                                [<OPT;DEF(2147482999)>]minimum:int,
                                [<OPT;DEF(2147482999)>]maximum:int) : int =
        let get () =
            use gi = new Input.Custom.GetInteger()
            if notNull message then gi.SetCommandPrompt(message)
            if number  <> 2147482999 then gi.SetDefaultInteger(number)
            if minimum <> 2147482999 then gi.SetLowerLimit(minimum, strictlyGreaterThan=false)
            if maximum <> 2147482999 then gi.SetUpperLimit(maximum, strictlyLessThan=false)
            if gi.Get() <> Input.GetResult.Number then
                gi.Dispose()
                RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetInteger()"
            else
                let rc = gi.Number()
                gi.Dispose()
                rc
        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Displays dialog box prompting the user to select a layer.</summary>
    ///<param name="title">(string) Optional, default value: <c>"Select Layer"</c>
    ///    Dialog box title</param>
    ///<param name="layer">(string) Optional, Name of a layer to preselect. If omitted, the current layer will be preselected</param>
    ///<param name="showNewButton">(bool) Optional, default value: <c>false</c>
    ///    Show new button of on the dialog</param>
    ///<param name="showSetCurrent">(bool) Optional, default value: <c>false</c>
    ///    Show set current  button on the dialog</param>
    ///<returns>(string) name of selected layer.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetLayer( [<OPT;DEF("Select Layer")>]title:string,
                            [<OPT;DEF(null:string)>]layer:string,
                            [<OPT;DEF(false)>]showNewButton:bool,
                            [<OPT;DEF(false)>]showSetCurrent:bool) : string =
        let getKeepEditor () =
            let layerindex = ref State.Doc.Layers.CurrentLayerIndex
            if notNull layer then
                let layerinstance = State.Doc.Layers.FindName(layer)
                if notNull layerinstance then layerindex := layerinstance.Index
            let rc = UI.Dialogs.ShowSelectLayerDialog(layerindex, title, showNewButton, showSetCurrent, ref true)
            if not rc then RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetLayer()"
            else
                let layer = State.Doc.Layers.[!layerindex]
                layer.FullPath
        RhinoSync.DoSync getKeepEditor


    ///<summary>Displays a dialog box prompting the user to select one or more layers.</summary>
    ///<param name="title">(string) Optional, default value: <c>"Select Layers"</c>
    ///    Dialog box title</param>
    ///<param name="showNewButton">(bool) Optional, default value: <c>false</c>
    ///    Optional button to show on the dialog</param>
    ///<returns>(string ResizeArray) The names of selected layers.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetLayers([<OPT;DEF("Select Layers")>]title:string, [<OPT;DEF(false)>]showNewButton:bool) : string ResizeArray =
        let getKeepEditor () =
            let rc, layerindices = UI.Dialogs.ShowSelectMultipleLayersDialog(null, title, showNewButton)
            if rc then
                (resizeArray { for index in layerindices do yield  State.Doc.Layers.[index].FullPath })
            else
                RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetLayers()"
        RhinoSync.DoSync getKeepEditor


    ///<summary>Prompts the user to pick points that define a line.</summary>
    ///<param name="mode">(int) Optional, default value: <c>0</c>
    ///    Line definition mode.
    ///    0  Default - Show all modes, start in two-point mode
    ///    1  Two-point - Defines a line from two points.
    ///    2  Normal - Defines a line normal to a location on a Surface.
    ///    3  Angled - Defines a line at a specified angle from a reference line.
    ///    4  Vertical - Defines a line vertical to the construction Plane.
    ///    5  Four-point - Defines a line using two points to establish direction and two points to establish length.
    ///    6  Bisector - Defines a line that bisects a specified angle.
    ///    7  Perpendicular - Defines a line perpendicular to or from a Curve
    ///    8  Tangent - Defines a line tangent from a Curve.
    ///    9  Extension - Defines a line that extends from a Curve</param>
    ///<param name="point">(Point3d) Optional, Optional starting point</param>
    ///<param name="message1">(string) Optional, Message1 of optional prompts</param>
    ///<param name="message2">(string) Optional, Message2 of optional prompts</param>
    ///<param name="message3">(string) Optional, Message3 of optional prompts</param>
    ///<returns>(Line) a Line.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetLine(  [<OPT;DEF(0)>]mode:int,
                            [<OPT;DEF(Point3d())>]point:Point3d,
                            [<OPT;DEF(null:string)>]message1:string,
                            [<OPT;DEF(null:string)>]message2:string,
                            [<OPT;DEF(null:string)>]message3:string) : Line =
        let get () =
            use gl = new Input.Custom.GetLine()
            if mode = 0 then gl.EnableAllVariations(true)
            else  gl.GetLineMode <- LanguagePrimitives.EnumOfValue( mode-1)
            if point <> Point3d.Origin then
                gl.SetFirstPoint(point)
            if notNull message1 then gl.FirstPointPrompt <- message1
            if notNull message2 then gl.MidPointPrompt <- message2
            if notNull message3 then gl.SecondPointPrompt <- message3
            let rc, line = gl.Get()
            if rc = Commands.Result.Success then
                line
            else
                RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetLine()"

        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Displays a dialog box prompting the user to select one line-type.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</summary>
    ///<param name="defaultValLinetype">(string) Optional, Optional. The name of the line-type to select. If omitted, the current line-type will be selected</param>
    ///<returns>(string) The names of selected line-type.</returns>
    static member GetLinetype(  [<OPT;DEF(null:string)>]defaultValLinetype:string) : string =
        // the original python script has an unused parameter showByLayer
        //<param name="showByLayer">(bool) Optional, default value: <c>false</c> If True, the "by Layer" line-type will show. Defaults to False</param>
        let getKeepEditor () =
            let mutable ltinstance = State.Doc.Linetypes.CurrentLinetype
            if notNull defaultValLinetype then
                let ltnew = State.Doc.Linetypes.FindName(defaultValLinetype)
                if notNull ltnew  then ltinstance <- ltnew
            try
                let objectId = UI.Dialogs.ShowLineTypes("Select Linetype", "Select Linetype", State.Doc) :?> Guid  // this fails if clicking in void
                // https://github.com/mcneel/rhinoscriptsyntax/pull/211/files
                let linetype = State.Doc.Linetypes.FindId(objectId)
                linetype.Name
            with _ ->
                RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetLinetype()"
        RhinoSync.DoSync getKeepEditor


    ///<summary>Prompts the user to pick one or more Mesh faces.</summary>
    ///<param name="objectId">(Guid) The Mesh object's identifier</param>
    ///<param name="message">(string) Optional, default value: <c>"Select Mesh Faces"</c>
    ///    A prompt of message</param>
    ///<param name="minCount">(int) Optional, default value: <c>1</c>
    ///    The minimum number of faces to select</param>
    ///<param name="maxCount">(int) Optional, default value: <c>0</c>
    ///    The maximum number of faces to select.
    ///    If 0, the user must press enter to finish selection.
    ///    If -1, selection stops as soon as there are at least minCount faces selected</param>
    ///<returns>(int ResizeArray) Mesh face indices.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetMeshFaces( objectId:Guid,
                                [<OPT;DEF("Select Mesh Faces")>]message:string,
                                [<OPT;DEF(1)>]minCount:int,
                                [<OPT;DEF(0)>]maxCount:int) : ResizeArray<int> =
        let get () =
            State.Doc.Objects.UnselectAll() |> ignore
            State.Doc.Views.Redraw()
            use go = new Input.Custom.GetObject()
            go.SetCustomGeometryFilter(fun rhinoObject _ _ -> objectId = rhinoObject.Id)
            go.SetCommandPrompt(message)
            go.GeometryFilter <- DocObjects.ObjectType.MeshFace
            go.AcceptNothing(true)
            if go.GetMultiple(minCount, maxCount) <> Input.GetResult.Object then
                RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetMeshFaces()"
            else
                let objrefs = go.Objects()
                let rc = resizeArray { for  item in objrefs do yield item.GeometryComponentIndex.Index }
                rc

        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Prompts the user to pick one or more Mesh vertices.</summary>
    ///<param name="objectId">(Guid) The Mesh object's identifier</param>
    ///<param name="message">(string) Optional, default value: <c>"Select Mesh Vertices"</c>
    ///    A prompt of message</param>
    ///<param name="minCount">(int) Optional, default value: <c>1</c>
    ///    The minimum number of vertices to select</param>
    ///<param name="maxCount">(int) Optional, default value: <c>0</c>
    ///    The maximum number of vertices to select. If 0, the user must
    ///    press enter to finish selection. If -1, selection stops as soon as there
    ///    are at least minCount vertices selected</param>
    ///<returns>(int ResizeArray) Mesh vertex indices.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetMeshVertices(  objectId:Guid,
                                    [<OPT;DEF("Select Mesh Vertices")>]message:string,
                                    [<OPT;DEF(1)>]minCount:int,
                                    [<OPT;DEF(0)>]maxCount:int) : ResizeArray<int> =
        let get () =
            State.Doc.Objects.UnselectAll() |> ignore
            State.Doc.Views.Redraw()
            use go = new Input.Custom.GetObject()
            go.SetCustomGeometryFilter(fun rhinoObject _ _ -> objectId = rhinoObject.Id)
            go.SetCommandPrompt(message)
            go.GeometryFilter <-  DocObjects.ObjectType.MeshVertex
            go.AcceptNothing(true)
            if go.GetMultiple(minCount, maxCount) <> Input.GetResult.Object then
                RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetMeshVertices()"
            else
                let objrefs = go.Objects()
                let rc = resizeArray { for  item in objrefs do yield item.GeometryComponentIndex.Index }
                rc

        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Pauses for user input of a point.</summary>
    ///<param name="message">(string) Optional, A prompt or message</param>
    ///<param name="basePoint">(Point3d) Optional, Point3d identifying a starting, or base point</param>
    ///<param name="distance">(float) Optional, Constraining distance. If distance is specified, basePoint must also be specified</param>
    ///<param name="inPlane">(bool) Optional, default value: <c>false</c>
    ///    Constrains the point selections to the active construction Plane</param>
    ///<returns>(Point3d) point3d.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetPoint( [<OPT;DEF(null:string)>]message:string,
                            [<OPT;DEF(Point3d())>]basePoint:Point3d,
                            [<OPT;DEF(0.0)>]distance:float,
                            [<OPT;DEF(false)>]inPlane:bool) : Point3d =
        let get () =
            use gp = new Input.Custom.GetPoint()
            if notNull message then gp.SetCommandPrompt(message)
            if basePoint <> Point3d.Origin then
                gp.DrawLineFromPoint(basePoint, true)
                gp.EnableDrawLineFromPoint(true)
                if distance<>0.0 then gp.ConstrainDistanceFromBasePoint(distance)
            if inPlane then gp.ConstrainToConstructionPlane(true)|> ignore
            gp.Get() |> ignore
            if gp.CommandResult() <> Commands.Result.Success then
                RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetPoint()"
            else
                let pt = gp.Point()
                pt

        RhinoSync.DoSyncRedrawHideEditor get



    ///<summary>Pauses for user input of a point constrained to a Curve object.</summary>
    ///<param name="curveId">(Guid) Identifier of the Curve to get a point on</param>
    ///<param name="message">(string) Optional, default value: <c>"Pick Point On Curve"</c>
    ///    A prompt of message</param>
    ///<returns>(Point3d) 3d point.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetPointOnCurve(curveId:Guid, [<OPT;DEF("Pick Point On Curve")>]message:string) : Point3d =
        let get () =
            let curve = RhinoScriptSyntax.CoerceCurve(curveId)
            use gp = new Input.Custom.GetPoint()
            gp.SetCommandPrompt(message)
            gp.Constrain(curve, allowPickingPointOffObject=false) |> ignore
            gp.Get() |> ignore
            if gp.CommandResult() <> Commands.Result.Success then
                RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetPointOnCurve()"
            else
                let pt = gp.Point()
                pt

        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Pauses for user input of a point constrained to a Mesh object.</summary>
    ///<param name="meshId">(Guid) Identifier of the Mesh to get a point on</param>
    ///<param name="message">(string) Optional, default value: <c>"Pick Point On Mesh"</c>
    ///    A prompt or message</param>
    ///<returns>(Point3d) 3d point.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetPointOnMesh(meshId:Guid, [<OPT;DEF("Pick Point On Mesh")>]message:string) : Point3d =
        let get () =
            //let res, point = Input.RhinoGet.GetPointOnMesh(State.Doc, meshId, message, acceptNothing=false) // TODO later versions of RhinoCommon7 require this !?
            let res, point = Input.RhinoGet.GetPointOnMesh( meshId, message, acceptNothing=false) //still Ok in earlier versions of RhinoCommon 7
            if res = Commands.Result.Success then point
            else RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetPointOnMesh()"

        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Pauses for user input of a point constrained to a Surface or Polysurface
    ///    object.</summary>
    ///<param name="surfaceId">(Guid) Identifier of the Surface to get a point on</param>
    ///<param name="message">(string) Optional, default value: <c>"Pick Point on Surface or Polysurface"</c>
    ///    A prompt or message</param>
    ///<returns>(Point3d) 3d point.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetPointOnSurface(surfaceId:Guid, [<OPT;DEF("Pick Point on Surface or Polysurface")>]message:string) : Point3d =
        let get () =
            use gp = new Input.Custom.GetPoint()
            gp.SetCommandPrompt(message)
            match RhinoScriptSyntax.CoerceGeometry surfaceId with
            | :? Surface as srf ->
                gp.Constrain(srf, allowPickingPointOffObject=false) |> ignore

            | :? Brep as brep ->
                gp.Constrain(brep, -1, -1, allowPickingPointOffObject=false) |> ignore

            | _ ->
                RhinoScriptingException.Raise "RhinoScriptSyntax.GetPointOnSurface failed input is not surface or Polysurface.  surfaceId:'%s' message:'%A'" (Nice.str surfaceId) message

            gp.Get() |>ignore
            if gp.CommandResult() <> Commands.Result.Success then
                RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetPointOnSurface()"
            else
                let pt = gp.Point()
                pt

        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Pauses for user input of one or more points.</summary>
    ///<param name="drawLines">(bool) Optional, default value: <c>false</c>
    ///    Draw lines between points</param>
    ///<param name="inPlane">(bool) Optional, default value: <c>false</c>
    ///    Constrain point selection to the active construction Plane</param>
    ///<param name="message1">(string) Optional, A prompt or message for the first point</param>
    ///<param name="message2">(string) Optional, A prompt or message for the next points</param>
    ///<param name="maxPoints">(int) Optional, Maximum number of points to pick. If not specified, an
    ///    unlimited number of points can be picked</param>
    ///<returns>(Point3d array) 3d points.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetPoints(    [<OPT;DEF(false)>]drawLines:bool,
                                [<OPT;DEF(false)>]inPlane:bool,
                                [<OPT;DEF(null:string)>]message1:string,
                                [<OPT;DEF(null:string)>]message2:string,
                                [<OPT;DEF(0)>]maxPoints:int) :Point3d ResizeArray =
                                //[<OPT;DEF(Point3d())>]basePoint:Point3d) // Ignored here because ignored in python too

        let get () =
            use gp = new Input.Custom.GetPoint()
            if notNull message1 then gp.SetCommandPrompt(message1)
            gp.EnableDrawLineFromPoint( drawLines )
            if inPlane then
                gp.ConstrainToConstructionPlane(true) |> ignore
                let plane = State.Doc.Views.ActiveView.ActiveViewport.ConstructionPlane()
                gp.Constrain(plane, allowElevator=false) |> ignore
            let mutable getres = gp.Get()
            if gp.CommandResult() <> Commands.Result.Success then RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetPoints()"
            else
                let mutable prevPoint = gp.Point()
                let rc = ResizeArray([prevPoint])
                if maxPoints = 0 || maxPoints > 1 then
                    let mutable currentpoint = 1
                    if notNull message2 then gp.SetCommandPrompt(message2)

                    if drawLines then
                        gp.DynamicDraw.Add (fun args  -> if rc.Count > 1 then
                                                            let c = ApplicationSettings.AppearanceSettings.FeedbackColor
                                                            args.Display.DrawPolyline(rc, c))
                    let mutable cont = true
                    while cont do
                        if maxPoints <> 0 && currentpoint>=maxPoints then cont <- false
                        if cont && drawLines then
                            gp.DrawLineFromPoint(prevPoint, true)
                        if cont then
                            gp.SetBasePoint(prevPoint, true)
                            currentpoint <- currentpoint + 1
                            getres <- gp.Get()
                            if getres = Input.GetResult.Cancel then
                                cont <- false
                                //RhinoApp.WriteLine "GetPoints canceled"
                            if cont && gp.CommandResult() <> Commands.Result.Success then
                                rc.Clear()
                                cont <- false
                                InternalToNiceStringSetup.printfnRed "%s" "GetPoints had no Success"
                            if cont then
                                prevPoint <- gp.Point()
                                rc.Add(prevPoint)
                if rc.Count>0 then
                    InternalToNiceStringSetup.printfnBlue "%d Points picked" rc.Count
                    rc
                else
                    RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetPoints()"


        RhinoSync.DoSyncRedrawHideEditor get




    ///<summary>Prompts the user to pick points that define a polyline.</summary>
    ///<param name="message1">(string) Optional, A prompt or message for the first point</param>
    ///<param name="message2">(string) Optional, A prompt or message for the second point</param>
    ///<param name="message3">(string) Optional, A prompt or message for the third point</param>
    ///<param name="message4">(string) Optional, A prompt or message for the 'next' point</param>
    ///<param name="min">(int) Optional, default value: <c>2</c>
    ///    The minimum number of points to require. The default is 2</param>
    ///<param name="max">(int) Optional, default value: <c>0</c>
    ///    The maximum number of points to require; 0 for no limit.</param>
    ///<returns>(Polyline) a  polyline.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetPolyline( [<OPT;DEF(null:string)>]message1:string,
                               [<OPT;DEF(null:string)>]message2:string,
                               [<OPT;DEF(null:string)>]message3:string,
                               [<OPT;DEF(null:string)>]message4:string,
                               [<OPT;DEF(2147482999)>]min:int,
                               [<OPT;DEF(0)>]max:int) : Polyline =
        // original python code has a flags parameter, but it is not used in the code
        let get () =
            let gpl = new Input.Custom.GetPolyline()
            if notNull message1 then gpl.FirstPointPrompt <- message1
            if notNull message2 then gpl.SecondPointPrompt <- message2
            if notNull message3 then gpl.ThirdPointPrompt <- message3
            if notNull message4 then gpl.FourthPointPrompt <- message4
            gpl.MinPointCount <- min
            if max>min then gpl.MaxPointCount <- max
            let rc, polyline = gpl.Get()
            State.Doc.Views.Redraw()
            if rc = Commands.Result.Success then polyline
            else RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.GetPolyline()"

        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Pauses for user input of a number.</summary>
    ///<param name="message">(string) Optional, default value: <c>"Number"</c>
    ///    A prompt or message</param>
    ///<param name="number">(float) Optional, A default number value</param>
    ///<param name="minimum">(float) Optional, A minimum allowable value</param>
    ///<param name="maximum">(float) Optional, A maximum allowable value</param>
    ///<returns>(float) The number input by the user.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetReal(              [<OPT;DEF("Number")>]message:string,
                                        [<OPT;DEF(7e89)>]number:float,
                                        [<OPT;DEF(7e89)>]minimum:float,
                                        [<OPT;DEF(7e89)>]maximum:float) : float =
        let get () =
            let gn = new Input.Custom.GetNumber()
            if notNull message then gn.SetCommandPrompt(message)
            if number <> 7e89 then gn.SetDefaultNumber(number)
            if minimum <> 7e89 then gn.SetLowerLimit(minimum, strictlyGreaterThan=false)
            if maximum <> 7e89 then gn.SetUpperLimit(maximum, strictlyLessThan=false)
            if gn.Get() <> Input.GetResult.Number then
                RhinoUserInteractionException.Raise "No number was given in RhinoScriptSyntax.GetReal()"
            else
                let rc = gn.Number()
                gn.Dispose()
                rc

        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Pauses for user input of a rectangle.</summary>
    ///<param name="mode">(int) Optional, default value: <c>0</c>
    ///    The rectangle selection mode. The modes are as follows
    ///    0 = All modes
    ///    1 = Corner - a rectangle is created by picking two corner points
    ///    2 = 3Point - a rectangle is created by picking three points
    ///    3 = Vertical - a vertical rectangle is created by picking three points
    ///    4 = Center - a rectangle is created by picking a center point and a corner point</param>
    ///<param name="basePoint">(Point3d) Optional, A 3d base point</param>
    ///<param name="prompt1">(string) Optional, Prompt1 of optional prompts</param>
    ///<param name="prompt2">(string) Optional, Prompt2 of optional prompts</param>
    ///<param name="prompt3">(string) Optional, Prompt3 of optional prompts</param>
    ///<returns>(Point3d * Point3d * Point3d * Point3d) Four 3d points that define the corners of the rectangle. A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetRectangle(         [<OPT;DEF(0)>]mode:int,
                                        [<OPT;DEF(Point3d())>]basePoint:Point3d,
                                        [<OPT;DEF(null:string)>]prompt1:string,
                                        [<OPT;DEF(null:string)>]prompt2:string,
                                        [<OPT;DEF(null:string)>]prompt3:string) : Point3d * Point3d * Point3d * Point3d =
        let get () =
            let mode : Input.GetBoxMode = LanguagePrimitives.EnumOfValue mode

            let basePoint = if basePoint = Point3d.Origin then Point3d.Unset else basePoint
            let prompts = ResizeArray([""; ""; ""])
            if notNull prompt1 then prompts.[0] <- prompt1
            if notNull prompt2 then prompts.[1] <- prompt2
            if notNull prompt3 then prompts.[2] <- prompt3
            let rc, corners = Input.RhinoGet.GetRectangle(mode, basePoint, prompts)
            if rc = Commands.Result.Success then  (corners.[0], corners.[1], corners.[2], corners.[3])
            else RhinoUserInteractionException.Raise "No rectangle was given by user in RhinoScriptSyntax.GetRectangle()"

        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Pauses for user input of a string value.</summary>
    ///<param name="message">(string) Optional, A prompt or message</param>
    ///<param name="defaultValString">(string) Optional, A default value</param>
    ///<param name="strings">(string seq) Optional, List of strings to be displayed as a click-able command options.
    ///    Note, strings cannot begin with a numeric character</param>
    ///<returns>(string) The string either input or selected by the user .
    ///    If the user presses the Enter key without typing in a string, an empty string "" is returned.
    ///    A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member GetString(            [<OPT;DEF(null:string)>]message:string,
                                        [<OPT;DEF(null:string)>]defaultValString:string,
                                        [<OPT;DEF(null:string seq)>]strings:string seq) : string =
        let get () =
            let gs = new Input.Custom.GetString()
            gs.AcceptNothing(true)
            if notNull message then gs.SetCommandPrompt(message)
            if notNull defaultValString then gs.SetDefaultString(defaultValString)
            if notNull strings then
                for s in strings do gs.AddOption(s) |> ignore
            let result = gs.Get()
            if result = Input.GetResult.Cancel then
                RhinoUserInteractionException.Raise "No text was given by user in RhinoScriptSyntax.GetString()"
            elif( result = Input.GetResult.Option ) then
                gs.Option().EnglishName
            else
                gs.StringResult()

        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Display a list of items in a list box dialog.</summary>
    ///<param name="items">(string IList) A list of values to select</param>
    ///<param name="message">(string) Optional, A prompt of message</param>
    ///<param name="title">(string) Optional, A dialog box title</param>
    ///<param name="defaultVal">(string) Optional, Selected item in the list</param>
    ///<returns>(string) The selected item.</returns>
    static member ListBox(              items:string IList,
                                        [<OPT;DEF(null:string)>]message:string,
                                        [<OPT;DEF(null:string)>]title:string,
                                        [<OPT;DEF(null:string)>]defaultVal:string) : string =
        let getKeepEditor () =
            match UI.Dialogs.ShowListBox(title, message, Array.ofSeq items , defaultVal) with
            | null ->  RhinoUserInteractionException.Raise "No items was given by user in RhinoScriptSyntax.ListBox()"
            |  :? string as s ->  s
            | _ -> RhinoUserInteractionException.Raise "No items was given by user in RhinoScriptSyntax.ListBox()"

        RhinoSync.DoSync getKeepEditor


    ///<summary>Displays a message box. A message box contains a message and
    ///    title, plus any combination of predefined icons and push buttons.</summary>
    ///<param name="message">(string) A prompt or message</param>
    ///<param name="buttons">(int) Optional, default value: <c>0</c>
    ///    Buttons and icon to display as a bit coded flag. Can be a combination of the
    ///    following flags. If omitted, an OK button and no icon is displayed
    ///    0      Display OK button only.
    ///    1      Display OK and Cancel buttons.
    ///    2      Display Abort, Retry, and Ignore buttons.
    ///    3      Display Yes, No, and Cancel buttons.
    ///    4      Display Yes and No buttons.
    ///    5      Display Retry and Cancel buttons.
    ///    16     Display Critical Message icon.
    ///    32     Display Warning Query icon.
    ///    48     Display Warning Message icon.
    ///    64     Display Information Message icon.
    ///    0      First button is the default.
    ///    256    Second button is the default.
    ///    512    Third button is the default.
    ///    768    Fourth button is the default.
    ///    0      Application modal. The user must respond to the message box
    ///      before continuing work in the current application.
    ///    4096   System modal. The user must respond to the message box
    ///      before continuing work in any application</param>
    ///<param name="title">(string) Optional, default value: <c>""</c>
    ///    The dialog box title</param>
    ///<returns>(int) an Int32 of indicating which button was clicked:
    ///    1      OK button was clicked.
    ///    2      Cancel button was clicked.
    ///    3      Abort button was clicked.
    ///    4      Retry button was clicked.
    ///    5      Ignore button was clicked.
    ///    6      Yes button was clicked.
    ///    7      No button was clicked.
    ///    _      A RhinoUserInteractionException is raised if input is cancelled.</returns>
    static member MessageBox(           message:string,
                                        [<OPT;DEF(0)>]buttons:int,
                                        [<OPT;DEF("")>]title:string) : int =
        let getKeepEditor () =
            let mutable buttontyp =  buttons &&& 0x00000007 //111 in binary
            let mutable btn = UI.ShowMessageButton.OK
            if   buttontyp = 1 then btn <- UI.ShowMessageButton.OKCancel
            elif buttontyp = 2 then btn <- UI.ShowMessageButton.AbortRetryIgnore
            elif buttontyp = 3 then btn <- UI.ShowMessageButton.YesNoCancel
            elif buttontyp = 4 then btn <- UI.ShowMessageButton.YesNo
            elif buttontyp = 5 then btn <- UI.ShowMessageButton.RetryCancel
            let icontyp = buttons &&& 0x00000070
            let mutable icon = UI.ShowMessageIcon.None
            if   icontyp = 16 then icon <- UI.ShowMessageIcon.Error
            elif icontyp = 32 then icon <- UI.ShowMessageIcon.Question
            elif icontyp = 48 then icon <- UI.ShowMessageIcon.Warning
            elif icontyp = 64 then icon <- UI.ShowMessageIcon.Information
            ////// 15 Sep 2014 Alain - default button not supported in new version of RC
            ////// that isn"t tied to Windows.Forms but it probably will so I"m commenting
            ////// the old code instead of deleting it.
            //defbtntyp = buttons & 0x00000300
            //defbtn = Windows.Forms.MessageDefaultButton.Button1
            //if defbtntyp = 256:
            //    defbtn = Windows.Forms.MessageDefaultButton.Button2
            //elif defbtntyp = 512:
            //    defbtn <- Windows.Forms.MessageDefaultButton.Button3
            let dlgresult = UI.Dialogs.ShowMessage(message, title, btn, icon)
            if   dlgresult = UI.ShowMessageResult.OK then      1
            elif dlgresult = UI.ShowMessageResult.Cancel then  2
            elif dlgresult = UI.ShowMessageResult.Abort then   3
            elif dlgresult = UI.ShowMessageResult.Retry then   4
            elif dlgresult = UI.ShowMessageResult.Ignore then  5
            elif dlgresult = UI.ShowMessageResult.Yes then     6
            elif dlgresult = UI.ShowMessageResult.No then      7
            else RhinoUserInteractionException.Raise "No MessageBox input was given by user in RhinoScriptSyntax.MessageBox"
        RhinoSync.DoSync getKeepEditor


    ///<summary>Displays list of items and their values in a property-style list box dialog.</summary>
    ///<param name="items">(string IList) list of string items</param>
    ///<param name="values">(string seq) The corresponding values to the items</param>
    ///<param name="message">(string) Optional, A prompt or message</param>
    ///<param name="title">(string) Optional, A dialog box title</param>
    ///<returns>(string array) An Array of new values.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member PropertyListBox(  items:string IList,
                                    values:string seq,
                                    [<OPT;DEF(null:string)>]message:string,
                                    [<OPT;DEF(null:string)>]title:string) : string array =
        let getKeepEditor () =
            let values = resizeArray { for  v in values do yield v.ToString() }
            match UI.Dialogs.ShowPropertyListBox(title, message, Array.ofSeq items , values) with
            | null -> RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.PropertyListBox"
            | s -> s
        RhinoSync.DoSync getKeepEditor


    ///<summary>Displays a list of items in a multiple-selection list box dialog.</summary>
    ///<param name="items">(string IList) A zero-based list of string items</param>
    ///<param name="message">(string) Optional, A prompt or message</param>
    ///<param name="title">(string) Optional, A dialog box title</param>
    ///<param name="defaultVals">(string IList) Optional, a list if multiple items that are pre-selected</param>
    ///<returns>(string array) an Array of containing the selected items.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member MultiListBox(     items:string IList,
                                    [<OPT;DEF(null:string)>]message:string,
                                    [<OPT;DEF(null:string)>]title:string,
                                    [<OPT;DEF(null:string IList)>]defaultVals:string IList) : string array =
        let getKeepEditor () =
            let r =  UI.Dialogs.ShowMultiListBox(title, message, items, defaultVals)
            if notNull r then r
            else RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.MultiListBox"
        RhinoSync.DoSync getKeepEditor


    ///<summary>Displays file open dialog box allowing the user to enter a file name.
    ///    Note, this function does not open the file.</summary>
    ///<param name="title">(string) Optional, A dialog box title</param>
    ///<param name="filter">(string) Optional, A filter string. The filter must be in the following form:
    ///    "Description1|Filter1|Description2|Filter2||", where "||" terminates filter string.
    ///    If omitted, the filter (*.*) is used</param>
    ///<param name="folder">(string) Optional, A default folder</param>
    ///<param name="filename">(string) Optional, A default file name</param>
    ///<param name="extension">(string) Optional, A default file extension</param>
    ///<returns>(string) A file name is successful.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member OpenFileName(     [<OPT;DEF(null:string)>]title:string,
                                    [<OPT;DEF(null:string)>]filter:string,
                                    [<OPT;DEF(null:string)>]folder:string,
                                    [<OPT;DEF(null:string)>]filename:string,
                                    [<OPT;DEF(null:string)>]extension:string) : string =
        let getKeepEditor () =
            let fd = UI.OpenFileDialog()
            if notNull title then fd.Title <- title
            if notNull filter then fd.Filter <- filter
            if notNull folder then fd.InitialDirectory <- folder
            if notNull filename then fd.FileName <- filename
            if notNull extension then fd.DefaultExt <- extension
            if fd.ShowOpenDialog() then fd.FileName
            else RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.OpenFileName()"
        RhinoSync.DoSync getKeepEditor


    ///<summary>Displays file open dialog box allowing the user to select one or more file names.
    ///    Note, this function does not open the file.</summary>
    ///<param name="title">(string) Optional, A dialog box title</param>
    ///<param name="filter">(string) Optional, A filter string. The filter must be in the following form:
    ///    "Description1|Filter1|Description2|Filter2||", where "||" terminates filter string.
    ///    If omitted, the filter (*.*) is used</param>
    ///<param name="folder">(string) Optional, A default folder</param>
    ///<param name="filename">(string) Optional, A default file name</param>
    ///<param name="extension">(string) Optional, A default file extension</param>
    ///<returns>(string array) The selected file names.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member OpenFileNames(    [<OPT;DEF(null:string)>]title:string,
                                    [<OPT;DEF(null:string)>]filter:string,
                                    [<OPT;DEF(null:string)>]folder:string,
                                    [<OPT;DEF(null:string)>]filename:string,
                                    [<OPT;DEF(null:string)>]extension:string) : string array =
        let getKeepEditor () =
            let fd = UI.OpenFileDialog()
            if notNull title then fd.Title <- title
            if notNull filter then fd.Filter <- filter
            if notNull folder then fd.InitialDirectory <- folder
            if notNull filename then fd.FileName <- filename
            if notNull extension then fd.DefaultExt <- extension
            fd.MultiSelect <- true
            if fd.ShowOpenDialog() then fd.FileNames
            else RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.OpenFileNames()"
        RhinoSync.DoSync getKeepEditor


    ///<summary>Display a context-style popup menu. The popup menu can appear almost
    ///    anywhere, and can be dismissed by clicking the left or right mouse buttons.</summary>
    ///<param name="items">(string seq) List of strings representing the menu items. An empty string or None
    ///    will create a separator</param>
    ///<param name="modes">(int seq) Optional, List of numbers identifying the display modes. If omitted, all
    ///    modes are enabled.
    ///      0 = menu item is enabled
    ///      1 = menu item is disabled
    ///      2 = menu item is checked
    ///      3 = menu item is disabled and checked</param>
    ///<param name="point">(Point3d) Optional, A 3D point where the menu item will appear. If omitted, the menu
    ///    will appear at the current cursor position</param>
    ///<param name="view">(string) Optional, If point is specified, the view in which the point is computed.
    ///    If omitted, the active view is used</param>
    ///<returns>(int) index of the menu item picked or -1 if no menu item was picked.</returns>
    static member PopupMenu(items:string seq,
                            [<OPT;DEF(null:int seq)>]modes:int seq,
                            [<OPT;DEF(Point3d())>]point:Point3d,
                            [<OPT;DEF(null:string)>]view:string) : int =
        let getKeepEditor () =
            let viewport =
                match RhinoScriptSyntax.TryCoerceView(view) with
                | Some v -> v.ActiveViewport
                | None -> RhinoDoc.ActiveDoc.Views.ActiveView.ActiveViewport

            let screenPoint =
                if Point3d.Origin = point then // because  [<OPT;DEF(Point3d())>] gives a 0,0,0 point
                    let cursorPoint =
                        // Windows.Forms.Cursor.Position can not be used directly since the reference to windows.forms is removed, goodbye mono https://discourse.mcneel.com/t/rhino-for-mac-wip-goodbye-mono-hello-net-6/131925
                        //let cursorType = Type.GetType("System.Windows.Forms.Cursor")
                        // use reflection to avoid dependency on Windows.Forms
                        let cursorType = Type.GetType "System.Windows.Forms.Cursor, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                        match cursorType with
                        | null ->
                            State.Warn "Could not get cursor position in RhinoScriptSyntax.PopupMenu. Could not load System.Windows.Forms.Cursor type"
                            None
                        | t ->
                            let positionProperty = t.GetProperty "Position"
                            match positionProperty with
                            | null ->
                                State.Warn "Could not get cursor position in RhinoScriptSyntax.PopupMenu. Could not find Position property on Cursor type"
                                None
                            | p ->
                                Some (p.GetValue(null) :?> Drawing.Point)

                    match cursorPoint with
                    | Some p ->
                        p
                    | None ->
                        let point2d = viewport.WorldToClient(viewport.CameraTarget)
                        viewport.ClientToScreen(point2d)
                else
                    let point2d = viewport.WorldToClient(point)
                    viewport.ClientToScreen(point2d)

            UI.Dialogs.ShowContextMenu(items, screenPoint, modes)

        RhinoSync.DoSync getKeepEditor


    ///<summary>Display a dialog box prompting the user to enter a number.</summary>
    ///<param name="message">(string) Optional, default value: <c>""</c>
    ///    A prompt message</param>
    ///<param name="defaultValNumber">(float) Optional, A default number</param>
    ///<param name="title">(string) Optional, default value: <c>""</c>
    ///    A dialog box title</param>
    ///<param name="minimum">(float) Optional, A minimum allowable value</param>
    ///<param name="maximum">(float) Optional, A maximum allowable value</param>
    ///<returns>(float) The newly entered number.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member RealBox(          [<OPT;DEF("")>]message:string,
                                    [<OPT;DEF(7e89)>]defaultValNumber:float,
                                    [<OPT;DEF("")>]title:string,
                                    [<OPT;DEF(7e89)>]minimum:float,
                                    [<OPT;DEF(7e89)>]maximum:float) : float =
        let get () =
            let defaultValNumber = ref <| if defaultValNumber = 7e89 then RhinoMath.UnsetValue else defaultValNumber
            let minimum = if minimum = 7e89 then RhinoMath.UnsetValue else minimum
            let maximum = if maximum = 7e89 then RhinoMath.UnsetValue else maximum

            let rc = UI.Dialogs.ShowNumberBox(title, message, defaultValNumber, minimum, maximum)
            if  rc then (defaultValNumber.Value)
            else RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.RealBox()"

        RhinoSync.DoSyncRedrawHideEditor get


    ///<summary>Display a save dialog box allowing the user to enter a file name.
    ///    Note, this function does not save the file.</summary>
    ///<param name="title">(string) Optional, A dialog box title</param>
    ///<param name="filter">(string) Optional, A filter string. The filter must be in the following form:
    ///    "Description1|Filter1|Description2|Filter2||", where "||" terminates filter string.
    ///    If omitted, the filter (*.*) is used</param>
    ///<param name="folder">(string) Optional, A default folder</param>
    ///<param name="filename">(string) Optional, A default file name</param>
    ///<param name="extension">(string) Optional, A default file extension</param>
    ///<returns>(string) the file name is successful.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member SaveFileName(     [<OPT;DEF(null:string)>]title:string,
                                    [<OPT;DEF(null:string)>]filter:string,
                                    [<OPT;DEF(null:string)>]folder:string,
                                    [<OPT;DEF(null:string)>]filename:string,
                                    [<OPT;DEF(null:string)>]extension:string) : string =
        let getKeepEditor () =
            let fd = UI.SaveFileDialog()
            if notNull title then fd.Title <- title
            if notNull filter then fd.Filter <- filter
            if notNull folder then fd.InitialDirectory <- folder
            if notNull filename then fd.FileName <- filename
            if notNull extension then fd.DefaultExt <- extension
            if fd.ShowSaveDialog() then fd.FileName else RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.SaveFileName()"
        RhinoSync.DoSync getKeepEditor


    ///<summary>Display a dialog box prompting the user to enter a string value.</summary>
    ///<param name="message">(string) Optional, A prompt message</param>
    ///<param name="defaultValValue">(string) Optional, A default string value</param>
    ///<param name="title">(string) Optional, A dialog box title</param>
    ///<returns>(string) the newly entered string value.
    /// A RhinoUserInteractionException is raised if input is cancelled via Esc Key.</returns>
    static member StringBox(        [<OPT;DEF(null:string)>]message:string,
                                    [<OPT;DEF(null:string)>]defaultValValue:string,
                                    [<OPT;DEF(null:string)>]title:string) : string =
        let getKeepEditor () =
            let rc, text = UI.Dialogs.ShowEditBox(title, message, defaultValValue, multiline=false)
            if rc then text else RhinoUserInteractionException.Raise "User Input was cancelled in RhinoScriptSyntax.StringBox()"
        RhinoSync.DoSync getKeepEditor


    ///<summary>Display a text dialog box similar to the one used by the _What command.</summary>
    ///<param name="message">(string) The message</param>
    ///<param name="title">(string) Optional, The message title</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TextOut(message:string,
                          [<OPT;DEF(null:string)>]title:string) : unit =
        let getKeepEditor () =
            UI.Dialogs.ShowTextDialog(message, title)
        RhinoSync.DoSync getKeepEditor



    //---End of header marker: don't change: {@$%^&*()*&^%$@}



    ///<summary>Return true if the script is being executed in the context of Rhino(currently always true).</summary>
    ///<returns>(bool) true if the script is being executed in the context of Rhino(currently always true).</returns>
    static member ContextIsRhino() : bool =
        true //TODO implement correctly


    ///<summary>Return true if the script is being executed in a grasshopper component(currently always false).</summary>
    ///<returns>(bool) true if the script is being executed in a grasshopper component(currently always false).</returns>
    static member ContextIsGrasshopper() : bool =
        false //TODO implement correctly


    ///<summary>Measures the angle between two points.</summary>
    ///<param name="point1">(Point3d) Point1 of input points</param>
    ///<param name="point2">(Point3d) Point2 of input points</param>
    ///<param name="plane">(Plane) Optional, default value: <c>Plane.WorldX</c>
    ///    If a Plane is provided, angle calculation is with respect to this Plane</param>
    ///<returns>(float * float * float * float * float) containing the following elements:
    ///    element 0 = the X, Y angle in degrees
    ///    element 1 = the elevation
    ///    element 2 = delta in the X direction
    ///    element 3 = delta in the Y direction
    ///    element 4 = delta in the Z direction.</returns>
    static member Angle(point1:Point3d, point2:Point3d, [<OPT;DEF(Plane())>]plane:Plane) : float * float * float * float * float  =
        let plane = if plane.IsValid then plane else Plane.WorldXY
        let vector = point2 - point1
        let mutable x = vector.X
        let mutable y = vector.Y
        let mutable z = vector.Z
        let vfrom = point1 - plane.Origin
        let vto = point2 - plane.Origin
        x <- vto * plane.XAxis - vfrom * plane.XAxis
        y <- vto * plane.YAxis - vfrom * plane.YAxis
        z <- vto * plane.ZAxis - vfrom * plane.ZAxis
        let h = Math.Sqrt( x * x + y * y)
        let angleXY = toDegrees( Math.Atan2( y, x ))
        let elevation = toDegrees( Math.Atan2( z, h ))
        angleXY, elevation, x, y, z


    ///<summary>Measures the angle between two lines.</summary>
    ///<param name="line1">(Line) List of 6 numbers or 2 Point3d</param>
    ///<param name="line2">(Line) List of 6 numbers or 2 Point3d</param>
    ///<returns>(float * float) containing the following elements .
    ///    0 The angle in degrees.
    ///    1 The reflex angle in degrees.</returns>
    static member Angle2(line1:Line, line2:Line) : float * float =
        let vec0 = line1.To - line1.From
        let vec1 = line2.To - line2.From
        if not <| vec0.Unitize() || not <| vec1.Unitize() then  RhinoScriptingException.Raise "RhinoScriptSyntax.Angle2 two failed on %A and %A" line1 line2
        let mutable dot = vec0 * vec1
        dot <- max -1.0 (min 1.0 dot) // clamp for math errors
        let mutable angle = Math.Acos(dot)
        let mutable reflexAngle = 2.0*Math.PI - angle
        angle <- toDegrees(angle)
        reflexAngle <- toDegrees(reflexAngle)
        angle, reflexAngle


    ///<summary>Gets the text string in the Windows clipboard.</summary>
    ///<returns>(string) The current text in the clipboard
    /// or an empty string if the content of the clipboard is not a text</returns>
    static member ClipboardText() : string = //GET
        // Eto Forms fails:
        // https://discourse.mcneel.com/t/using-default-eto-control-over-rhino-variant/167138/8
        // let platform = Eto.Platform.Get(Eto.Platform.Instance.GetType().AssemblyQualifiedName) // Platform.Instance is null
        //let platform = Eto.Platform.Detect //Could not detect platform. Are you missing a platform assembly? --->  Error creating instance of platform type 'Eto.Wpf.Platform, Eto.Wpf' --->  Unable to cast object of type 'Eto.Wpf.Platform' to type 'Eto.Platform'.
        //use _ctx = platform.Context
        // let cl = Eto.Forms.Clipboard.Instance
        // if isNull cl then RhinoScriptingException.Raise "RhinoScriptSyntax.ClipboardText() failed to get clipboard instance"
        // if cl.ContainsText then cl.Text else ""

        // if Windows.Forms.Clipboard.ContainsText() then Windows.Forms.Clipboard.GetText() else ""
        // use reflection to avoid dependency on Windows.Forms
        let clipboardType = Type.GetType "System.Windows.Forms.Clipboard, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
        match clipboardType with
        | null ->
            State.Warn "Could not access clipboard in RhinoScriptSyntax.ClipboardText. Could not load System.Windows.Forms.Clipboard type"
            ""
        | t ->
            let containsTextMethod = t.GetMethod("ContainsText", System.Type.EmptyTypes)
            let getTextMethod = t.GetMethod("GetText", System.Type.EmptyTypes)
            match containsTextMethod, getTextMethod with
            | null, _ ->
                State.Warn "Could not access clipboard in RhinoScriptSyntax.ClipboardText. Could not find ContainsText method on Clipboard type"
                ""
            | _, null ->
                State.Warn "Could not access clipboard in RhinoScriptSyntax.ClipboardText. Could not find GetText method on Clipboard type"
                ""
            | containsMethod, getText ->
                let containsText = containsMethod.Invoke(null, null) :?> bool
                if containsText then
                    getText.Invoke(null, null) :?> string
                else
                    ""

    ///<summary>Sets a text string to the Windows clipboard.</summary>
    ///<param name="text">(string) Text to set</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ClipboardText(text:string) : unit = //SET
        // does not work with Eto.Forms.Clipboard
        // let cl = Eto.Forms.Clipboard.Instance
        // if isNull cl then RhinoScriptingException.Raise "RhinoScriptSyntax.ClipboardText(text) failed to get clipboard instance"
        // cl.Text <- text //System.InvalidOperationException: Platform instance is null. Have you created your application?

        // Windows.Forms.Clipboard.SetText(text)
        // use reflection to avoid dependency on Windows.Forms
        let clipboardType = Type.GetType "System.Windows.Forms.Clipboard, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
        match clipboardType with
        | null ->
            State.Warn "Could not access clipboard in RhinoScriptSyntax.ClipboardText. Could not load System.Windows.Forms.Clipboard type"
        | t ->
            let setTextMethod = t.GetMethod("SetText", [| typeof<string> |])
            match setTextMethod with
            | null ->
                State.Warn "Could not access clipboard in RhinoScriptSyntax.ClipboardText. Could not find SetText method on Clipboard type"
            | setText ->
                try
                    let _ = setText.Invoke(null, [| text :> obj |])
                    ()
                with ex ->
                    State.Warn $"Failed to set clipboard text: {ex.Message}"



    ///<summary>Changes the luminance of a red-green-blue value. Hue and saturation are
    ///    not affected.</summary>
    ///<param name="rgb">(Drawing.Color) Initial rgb value</param>
    ///<param name="luminance">(float) The luminance in units of 0.1 percent of the total range. A
    ///    value of luminance = 50 corresponds to 5 percent of the maximum luminance </param>
    ///<param name="isScaleRelative">(bool) Optional, default value: <c>false</c>
    ///    If True, luminance specifies how much to increment or decrement the
    ///    current luminance. If False, luminance specified the absolute luminance </param>
    ///<returns>(Drawing.Color) modified rgb value.</returns>
    static member ColorAdjustLuma(rgb:Drawing.Color, luminance:float, [<OPT;DEF(false)>]isScaleRelative:bool) : Drawing.Color =
        let mutable hsl = Display.ColorHSL(rgb)
        let mutable luminance = luminance / 1000.0
        if isScaleRelative then luminance <- hsl.L + luminance
        hsl.L <- luminance
        hsl.ToArgbColor()


    ///<summary>Retrieves intensity value for the blue component of an RGB color.</summary>
    ///<param name="rgb">(Drawing.Color) The RGB color value</param>
    ///<returns>(int) The blue component.</returns>
    static member ColorBlueValue(rgb:Drawing.Color) : int =
       int rgb.B


    ///<summary>Retrieves intensity value for the green component of an RGB color.</summary>
    ///<param name="rgb">(Drawing.Color) The RGB color value</param>
    ///<returns>(int) The green component.</returns>
    static member ColorGreenValue(rgb:Drawing.Color) : int =
       int rgb.G


    ///<summary>Converts colors from hue-luminance-saturation to RGB.</summary>
    ///<param name="hls">(Drawing.Color) The HLS color value</param>
    ///<returns>(Drawing.Color) The RGB color value.</returns>
    static member ColorHLSToRGB(hls:Drawing.Color) : Drawing.Color =
        let hls = Display.ColorHSL((float hls.A) /240.0, (float hls.R)/240.0, (float hls.G)/240.0, (float hls.B)/240.0) // TODO test if correct with reverse function
        hls.ToArgbColor()


    ///<summary>Retrieves intensity value for the red component of an RGB color.</summary>
    ///<param name="rgb">(Drawing.Color) The RGB color value</param>
    ///<returns>(int) The red color value.</returns>
    static member ColorRedValue(rgb:Drawing.Color) : int =
        int rgb.R


    ///<summary>Convert colors from RGB to  HSL ( Hue, Saturation and Luminance).</summary>
    ///<param name="rgb">(Drawing.Color) The RGB color value</param>
    ///<returns>(Display.ColorHSL) The HLS color value.</returns>
    static member ColorRGBToHLS(rgb:Drawing.Color) : Display.ColorHSL =
        let hsl = Display.ColorHSL(rgb)
        hsl


    ///<summary>Removes duplicates from an array of numbers.</summary>
    ///<param name="numbers">(float seq) List of Doubles</param>
    ///<param name="tolerance">(float) Optional, default value: <c>RhinoMath.ZeroTolerance</c>
    ///    The minimum distance between numbers. Numbers that fall within this tolerance will be discarded</param>
    ///<returns>(float ResizeArray) numbers with duplicates removed.</returns>
    static member CullDuplicateNumbers(numbers:float seq, [<OPT;DEF(0.0)>]tolerance:float) : float ResizeArray =
        if Seq.length numbers < 2 then ResizeArray(numbers )
        else
            let tol = Util.ifZero1 tolerance  RhinoMath.ZeroTolerance // or State.Doc.ModelAbsoluteTolerance
            let nums = numbers|> Seq.sort
            let first = Seq.head nums
            let second = (Seq.item 1 nums)
            let mutable lastOK = first
            resizeArray {
                if abs(first-second) > tol then
                    yield first
                    lastOK <- second
                for n in Seq.skip 2 nums do
                    if abs(lastOK-n) > tol then
                        yield n
                        lastOK <- n
                }


    ///<summary>Removes duplicates from a list of 3D points.</summary>
    ///<param name="points">(Point3d seq) A list of 3D points</param>
    ///<param name="tolerance">(float) Optional, default value: <c>RhinoMath.ZeroTolerance</c> Minimum distance between points.
    /// Points within this tolerance will be discarded.</param>
    ///<returns>(Point3d array) Array of 3D points with duplicates removed.</returns>
    static member CullDuplicatePoints(points:Point3d seq, [<OPT;DEF(0.0)>]tolerance:float) : Point3d array =
        let tol = Util.ifZero1 tolerance State.Doc.ModelAbsoluteTolerance // RhinoMath.ZeroTolerance
        Geometry.Point3d.CullDuplicates(points, tol)


    ///<summary>Measures Square distance between two 3D points. Does not validate input.</summary>
    ///<param name="point1">(Point3d) The first 3D point</param>
    ///<param name="point2">(Point3d) The second 3D point</param>
    ///<returns>(float) The square distance.</returns>
    static member inline DistanceSquare(point1:Point3d, point2:Point3d) : float =
        let x = point1.X - point2.X
        let y = point1.Y - point2.Y
        let z = point1.Z - point2.Z
        x*x + y*y + z*z

    ///<summary>Measures distance between two 3D points.</summary>
    ///<param name="point1">(Point3d) The first 3D point</param>
    ///<param name="point2">(Point3d) The second 3D point</param>
    ///<returns>(float) The distance.</returns>
    static member inline Distance(point1:Point3d, point2:Point3d) : float =
        let x = point1.X - point2.X
        let y = point1.Y - point2.Y
        let z = point1.Z - point2.Z
        sqrt (x*x + y*y + z*z)

    ///<summary>Returns 3D point that is a specified angle and distance from a 3D point.</summary>
    ///<param name="point">(Point3d) The point to transform</param>
    ///<param name="angleDegrees">(float) Angle in degrees</param>
    ///<param name="distance">(float) Distance from point</param>
    ///<param name="plane">(Plane) Optional, Plane to base the transformation. If omitted, the world
    ///    x-y Plane is used</param>
    ///<returns>(Point3d) resulting point is successful.</returns>
    static member Polar(point:Point3d, angleDegrees:float, distance:float, [<OPT;DEF(Plane())>]plane:Plane) : Point3d =
        let angle = toRadians(angleDegrees)
        let mutable offset = plane.XAxis
        offset.Unitize() |> ignore
        offset <- distance * offset
        let rc = point + offset
        let xForm = Transform.Rotation(angle, plane.ZAxis, point)
        rc.Transform(xForm)
        rc


    ///<summary>Flattens an array of 3-D points into a one-dimensional list of real numbers. For example, if you had an array containing three 3-D points, this method would return a one-dimensional array containing nine real numbers.</summary>
    ///<param name="points">(Point3d seq) Points to flatten</param>
    ///<returns>(float ResizeArray) A one-dimensional list containing real numbers.</returns>
    static member SimplifyArray(points:Point3d seq) : float ResizeArray =
        resizeArray {
            for p in points do
                yield p.X
                yield p.Y
                yield p.Z
            }


    ///<summary>Suspends execution of a running script for the specified interval. Then refreshes Rhino UI.</summary>
    ///<param name="milliseconds">(int) Thousands of a second</param>
    ///<returns>(unit).</returns>
    static member Sleep(milliseconds:int) : unit =
        Threading.Thread.Sleep(milliseconds)
        RhinoApp.Wait()


    ///<summary>Sorts list of points so they will be connected in a "reasonable" Polyline order.</summary>
    ///<param name="points">(Point3d seq) The points to sort</param>
    ///<param name="tolerance">(float) Optional, default value: <c>RhinoMath.ZeroTolerance</c>
    ///    Minimum distance between points. Points that fall within this tolerance
    ///    will be discarded.</param>
    ///<returns>(Point3d array) Array of sorted 3D points.</returns>
    static member SortPointList(points:Point3d seq, [<OPT;DEF(0.0)>]tolerance:float) : Point3d array =
        let tol = Util.ifZero2 RhinoMath.ZeroTolerance tolerance
        Point3d.SortAndCullPointList(points, tol)


    ///<summary>Sorts the components of an array of 3D points.</summary>
    ///<param name="points">(Point3d seq) Points to sort</param>
    ///<param name="ascending">(bool) Optional, default value: <c>true</c>
    ///    Ascending if omitted (True) or True, descending if False</param>
    ///<param name="order">(int) Optional, default value: <c>0</c>
    ///    The component sort order
    ///    Value       Component Sort Order
    ///    0 (default) X, Y, Z
    ///    1           X, Z, Y
    ///    2           Y, X, Z
    ///    3           Y, Z, X
    ///    4           Z, X, Y
    ///    5           Z, Y, X</param>
    ///<returns>(Point3d seq) sorted 3-D points.</returns>
    static member SortPoints(points:Point3d seq, [<OPT;DEF(true)>]ascending:bool, [<OPT;DEF(0)>]order:int) : Point3d seq =
        let f =
            match order with
            |0 -> fun (p:Point3d) -> p.X, p.Y, p.Z
            |1 -> fun (p:Point3d) -> p.X, p.Z, p.Y
            |2 -> fun (p:Point3d) -> p.Y, p.X, p.Z
            |3 -> fun (p:Point3d) -> p.Y, p.Z, p.X
            |4 -> fun (p:Point3d) -> p.Z, p.X, p.Y
            |5 -> fun (p:Point3d) -> p.Z, p.Y, p.X
            |_ -> RhinoScriptingException.Raise "RhinoScriptSyntax.SortPoints is missing implementation for order input %d, only 0 to 5 are valid inputs" order
        if ascending then points |>  Seq.sortBy           f
        else              points |>  Seq.sortByDescending f


    ///<summary>convert a formatted string value into a 3D point value.</summary>
    ///<param name="point">(string) A string that contains a delimited point like "1, 2, 3"</param>
    ///<returns>(Point3d) Point structure from the input string.</returns>
    static member Str2Pt(point:string) : Point3d =
        RhinoScriptSyntax.Coerce3dPoint point


    ///<summary>Converts 'point' into a Rhino.Geometry.Point3d if possible.</summary>
    ///<param name="point">('T) any value that can be converted or parsed to a point</param>
    ///<returns>(Point3d) a Rhino.Geometry.Point3d.</returns>
    static member CreatePoint(point:'T ) : Point3d =
        RhinoScriptSyntax.Coerce3dPoint point

    ///<summary>Converts x, y and z into a Rhino.Geometry.Point3d if possible.</summary>
    ///<param name="x">('T) any value that can be converted or parsed to X coordinate</param>
    ///<param name="y">('T) any value that can be converted or parsed to Y coordinate</param>
    ///<param name="z">('T) any value that can be converted or parsed to Z coordinate</param>
    ///<returns>(Point3d) a Rhino.Geometry.Point3d.</returns>
    static member CreatePoint(x:'T, y:'T, z:'T ) : Point3d =
        RhinoScriptSyntax.Coerce3dPoint ((x, y, z))


    ///<summary>Converts 'Vector' into a Rhino.Geometry.Vector3d if possible.</summary>
    ///<param name="vector">('T) any value that can be converted or parsed to a Vector</param>
    ///<returns>(Vector3d) a Rhino.Geometry.Vector3d.</returns>
    static member CreateVector(vector:'T ) : Vector3d =
        RhinoScriptSyntax.Coerce3dVector vector
    ///<summary>Converts x, y and z into a Rhino.Geometry.Vector3d if possible.</summary>
    ///<param name="x">('T) any value that can be converted or parsed to X coordinate</param>
    ///<param name="y">('T) any value that can be converted or parsed to Y coordinate</param>
    ///<param name="z">('T) any value that can be converted or parsed to Z coordinate</param>
    ///<returns>(Vector3d) a Rhino.Geometry.Vector3d.</returns>
    static member CreateVector(x:'T, y:'T, z:'T ) : Vector3d =
        RhinoScriptSyntax.Coerce3dVector ((x, y, z))



    ///<summary>Converts input into a Rhino.Geometry.Plane object if possible.</summary>
    ///<param name="origin">(Point3d) The Plane Center or Origin</param>
    ///<param name="xAxis">(Vector3d) Optional, default value: <c>Vector3d.XAxis</c>
    ///    Direction of X-Axis</param>
    ///<param name="yAxis">(Vector3d) Optional, default value: <c>Vector3d.YAxis</c>
    ///    Direction of Y-Axis</param>
    ///<returns>(Plane) A Rhino.Geometry.Plane.</returns>
    static member CreatePlane(origin:Point3d , [<OPT;DEF(Vector3d())>]xAxis:Vector3d, [<OPT;DEF(Vector3d())>]yAxis:Vector3d) : Plane =
        if xAxis.IsZero || yAxis.IsZero then
            Plane(origin, Vector3d.XAxis, Vector3d.YAxis)
        else
            Plane(origin, xAxis, yAxis)


    ///<summary>Converts input into a Rhino.Geometry.Transform object if possible.</summary>
    ///<param name="xForm">(float seq seq) The transform. This can be seen as a 4x4 matrix, given as nested lists</param>
    ///<returns>(Transform) A Rhino.Geometry.Transform. result[0, 3] gives access to the first row, last column.</returns>
    static member CreateXform(xForm:seq<seq<float>>) : Transform =
        RhinoScriptSyntax.CoerceXform(xForm) // TODO verify row, column order !!


    ///<summary>Creates a RGB color from red, green and  blue  values as Integers. Raise an exception if values are out of range</summary>
    ///<param name="red">(int) Red Value between 0 and 255 </param>
    ///<param name="green">(int) Green value between 0 and 255 </param>
    ///<param name="blue">(int) Blue value between 0 and 255 </param>
    ///<returns>(System.Drawing.Color) a Color.</returns>
    static member CreateColor(red:int, green:int, blue:int) : Drawing.Color =
        if red   < 0 || red > 255 then RhinoScriptingException.Raise "RhinoScriptSyntax.CreateColor red value out of range 0 to 255: %d" red
        if green < 0 || green > 255 then RhinoScriptingException.Raise "RhinoScriptSyntax.CreateColor green value out of range 0 to 255: %d" green
        if blue  < 0 || blue > 255 then RhinoScriptingException.Raise "RhinoScriptSyntax.CreateColor blue value out of range 0 to 255: %d" blue
        Drawing.Color.FromArgb(red, green, blue)

    ///<summary>Creates a RGB color from  red, green and  blue  values as Bytes.</summary>
    ///<param name="red">(byte) Red Value</param>
    ///<param name="green">(byte) Green value</param>
    ///<param name="blue">(byte) Blue value</param>
    ///<returns>(System.Drawing.Color) a Color.</returns>
    static member CreateColor(red:byte, green:byte, blue:byte) : Drawing.Color =
        Drawing.Color.FromArgb(int red, int green, int blue)

    ///<summary>Converts input into a Rhino.Geometry.Interval. This interval can be increasing or decreasing</summary>
    ///<param name="start">(float) Start of interval</param>
    ///<param name="ende">(float) End of interval</param>
    ///<returns>(Rhino.Geometry.Interval) This can be seen as an object made of two items:
    ///    [0] start of interval
    ///    [1] end of interval.</returns>
    static member CreateInterval(start:float, ende:float) : Rhino.Geometry.Interval =
        Geometry.Interval(start , ende)


    (*
    manipulating ini files like in original Rhinoscript could be include via
    <PackageReference Include="ini-parser" Version="2.5.2" />
    however for now it is excluded to keep the dependencies at just FsEx.
    If ini-file reading and writing is needed I would suggest to use the "ini-parser" package directly and not the below functions.

    open IniParser
    open IniParser.Model

    ///<summary>Returns section names or keys in one section of an ini file.</summary>
    ///<param name="filename">(string) Name  and path of the ini-file</param>
    ///<param name="section">(string) Optional, Section to list keys from</param>
    ///<returns>(string array)
    ///    If section is NOT specified, a list containing all section names
    ///    If section is specified, a list containing all entry names for the given section.</returns>
    static member GetSettings(filename:string, [<OPT;DEF(null:string)>]section:string) : string ResizeArray =
        //https://github.com/rickyah/ini-parser

        //https://github.com/rickyah/ini-parser/wiki/Configuring-parser-behavior
        let parser = new FileIniDataParser()
        let data = parser.ReadFile(filename)
        data.Configuration.ThrowExceptionsOnError <-true
        if isNull section then
            resizeArray { for s in data.Sections do s.SectionName }
        else
            resizeArray { for k in data.[section] do k.KeyName}

    ///<summary>Returns string from a specified section and entry in an ini file.</summary>
    ///<param name="filename">(string) Name  and path of the ini file</param>
    ///<param name="section">(string) Section containing the entry,for keys without section use empty string</param>
    ///<param name="entry">(string) Entry whose associated string is to be returned</param>
    ///<returns>(string) a value for entry.</returns>
    static member GetSettings(filename:string, section:string, entry:string) : string =
        let parser = new FileIniDataParser()
        let data = parser.ReadFile(filename)
        data.Configuration.ThrowExceptionsOnError <-true
        let s =
            if section = "" then
                data.Global.[entry]
            else
                data.[section].[entry]
        if isNull s then RhinoScriptingException.Raise "RhinoScriptSyntax.GetSettings entry '%s' in section '%s' not found in file %s" entry section filename
        else s

    ///<summary>Saves a specified section and entry in an ini file.</summary>
    ///<param name="filename">(string) Name and path of the ini file</param>
    ///<param name="section">(string) Section containing the entry. if empty string key without section will be added</param>
    ///<param name="entry">(string) Entry whose associated string is to be returned</param>
    ///<param name="value">(string) The Value of this entry</param>
    ///<returns>(string) a value for entry.</returns>
    static member SaveSettings(filename:string, section:string, entry:string,value:string) : unit =
        if IO.File.Exists filename then
            let parser = new FileIniDataParser()
            parser.Parser.Configuration.ThrowExceptionsOnError <-true
            let data = parser.ReadFile(filename)
            data.Configuration.ThrowExceptionsOnError <-true
            if section = "" then
                data.Global.[entry]<- value
            else
                data.Configuration.AllowCreateSectionsOnFly <- true
                data.[section].[entry] <- value
            parser.WriteFile(filename,data)
        else
            let data = IniData()
            data.Configuration.ThrowExceptionsOnError <-true
            if section = "" then
                data.Global.[entry]<- value
            else
                data.Configuration.AllowCreateSectionsOnFly <- true
                data.[section].[entry] <- value
            IO.File.WriteAllText(filename,data.ToString())
    *)

    //---End of header marker: don't change: {@$%^&*()*&^%$@}



    ///<summary>Add new detail view to an existing layout view.</summary>
    ///<param name="layoutName">(string) Name of an existing layout</param>
    ///<param name="corner1">(Point2d) Corner1 of the detail in the layout's unit system</param>
    ///<param name="corner2">(Point2d) Corner2 of the detail in the layout's unit system</param>
    ///<param name="title">(string) Optional, Title of the new detail</param>
    ///<param name="projection">(int) Optional, default value: <c>1</c>
    ///    Type of initial view projection for the detail
    ///    1 = parallel top view
    ///    2 = parallel bottom view
    ///    3 = parallel left view
    ///    4 = parallel right view
    ///    5 = parallel front view
    ///    6 = parallel back view
    ///    7 = perspective view</param>
    ///<returns>(Guid) identifier of the newly created detail.</returns>
    static member AddDetail( layoutName:string,
                             corner1:Point2d,
                             corner2:Point2d,
                             [<OPT;DEF(null:string)>]title:string,
                             [<OPT;DEF(1)>]projection:int) : Guid =
        if projection<1 || projection>7 then RhinoScriptingException.Raise "RhinoScriptSyntax.AddDetail: Projection must be a value between 1-7.  layoutId:'%s' corner1:'%A' corner2:'%A' title:'%A' projection:'%A'" layoutName corner1 corner2 title projection
        let layout = RhinoScriptSyntax.CoercePageView(layoutName)//TODO test this
        if isNull layout then RhinoScriptingException.Raise "RhinoScriptSyntax.AddDetail: No layout found for given layoutId.  layoutId:'%s' corner1:'%A' corner2:'%A' title:'%A' projection:'%A'" layoutName corner1 corner2 title projection
        let projection : Display.DefinedViewportProjection = LanguagePrimitives.EnumOfValue  projection
        let detail = layout.AddDetailView(title, corner1, corner2, projection)
        if isNull detail then RhinoScriptingException.Raise "RhinoScriptSyntax.AddDetail failed.  layoutId:'%s' corner1:'%A' corner2:'%A' title:'%A' projection:'%A'" layoutName corner1 corner2 title projection
        State.Doc.Views.Redraw()
        detail.Id


    ///<summary>Adds a new page layout view.</summary>
    ///<param name="title">(string) Optional, Title of new layout</param>
    ///<param name="width">(float)  Optional, width  of paper for the new layout</param>
    ///<param name="height">(float) Optional, height of paper for the new layout</param>
    ///<returns>(Guid*string) Id and Name of new layout.</returns>
    static member AddLayout([<OPT;DEF(null:string)>]title:string,
                            [<OPT;DEF(0.0)>]width:float,
                            [<OPT;DEF(0.0)>]height:float) : Guid*string =
        let page =
            if width=0.0 || height=0.0  then State.Doc.Views.AddPageView(title)
            else                             State.Doc.Views.AddPageView(title, width, height)
        if notNull page then page.MainViewport.Id, page.PageName
        else RhinoScriptingException.Raise "RhinoScriptSyntax.AddLayout failed for %A %A" title (width, height)


    ///<summary>Adds new named construction Plane to the document.</summary>
    ///<param name="cPlaneName">(string) The name of the new named construction Plane</param>
    ///<param name="plane">(Plane) The construction Plane</param>
    ///<returns>(unit) void, nothing.</returns>
    static member AddNamedCPlane(cPlaneName:string, plane:Plane) : unit =
        if isNull cPlaneName then RhinoScriptingException.Raise "RhinoScriptSyntax.AddNamedCPlane: cPlaneName = null.  plane:'%A'"  plane
        let index = State.Doc.NamedConstructionPlanes.Add(cPlaneName, plane)
        if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.AddNamedCPlane failed.  cPlaneName:'%A' plane:'%A'" cPlaneName plane
        ()


    ///<summary>Adds a new named view to the document.</summary>
    ///<param name="name">(string) The name of the new named view</param>
    ///<param name="view">(string) Optional, The title of the view to save. If omitted, the current
    ///    active view is saved</param>
    ///<returns>(unit) void, nothing.</returns>
    static member AddNamedView(name:string, [<OPT;DEF("")>]view:string) : unit =
        let view = RhinoScriptSyntax.CoerceView(view)
        if isNull name then RhinoScriptingException.Raise "RhinoScriptSyntax.AddNamedView: Name = null.  view:'%A'"  view
        let viewportId = view.MainViewport.Id
        let index = State.Doc.NamedViews.Add(name, viewportId)
        if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.AddNamedView failed.  name:'%A' view:'%A'" name view



    ///<summary>Returns the current detail view in a page layout view.</summary>
    ///<param name="layout">(string) Title of an existing page layout view</param>
    ///<returns>(string) The name of the current detail view, or an empty String if the Page view is the current view.</returns>
    static member CurrentDetail(layout:string) : string = //GET
        let page = RhinoScriptSyntax.CoercePageView(layout)
        if page.MainViewport.Id = page.ActiveViewport.Id then ""
        else page.ActiveViewport.Name

    ///<summary>Changes the current detail view in a page layout view.</summary>
    ///<param name="layout">(string) Title of an existing page layout view</param>
    ///<param name="detail">(string) Title of the detail view to set</param>
    ///<returns>(unit) void, nothing.</returns>
    static member CurrentDetail(layout:string, detail:string) : unit = //SET
        let page = RhinoScriptSyntax.CoercePageView(layout)
        if layout = detail then page.SetPageAsActive()
        else
            if not <| page.SetActiveDetail(detail, compareCase=false) then
                RhinoScriptingException.Raise "RhinoScriptSyntax.CurrentDetail set failed for %s to %s" layout detail
        State.Doc.Views.Redraw()



    ///<summary>Returns the currently active view.</summary>
    ///<returns>(string) The title of the current view.</returns>
    static member CurrentView() : string = //GET
        State.Doc.Views.ActiveView.MainViewport.Name

    ///<summary>Sets the currently active view.</summary>
    ///<param name="view">(string) Title of the view to set current</param>
    ///<returns>(unit) void, nothing.</returns>
    static member CurrentView(view:string) : unit = //SET
        State.Doc.Views.ActiveView <- RhinoScriptSyntax.CoerceView(view)



    ///<summary>Removes a named construction Plane from the document.</summary>
    ///<param name="name">(string) Name of the construction Plane to remove</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member DeleteNamedCPlane(name:string) : bool =
        State.Doc.NamedConstructionPlanes.Delete(name)


    ///<summary>Removes a named view from the document.</summary>
    ///<param name="name">(string) Name of the named view to remove</param>
    ///<returns>(bool) True or False indicating success or failure.</returns>
    static member DeleteNamedView(name:string) : bool =
        State.Doc.NamedViews.Delete(name)


    ///<summary>Returns the projection locked state of a detail view-port rectangle.</summary>
    ///<param name="detailId">(Guid) Identifier of a detail rectangle object</param>
    ///<returns>(bool) The current detail projection locked state.</returns>
    static member DetailLock(detailId:Guid) : bool = //GET
        let detail = RhinoScriptSyntax.CoerceDetailView(detailId)
        detail.IsProjectionLocked

    ///<summary>Modifies the projection locked state of a detail.</summary>
    ///<param name="detailId">(Guid) Identifier of a detail object</param>
    ///<param name="lock">(bool) The new lock state</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DetailLock(detailId:Guid, lock:bool) : unit = //SET
        let detail =
            try State.Doc.Objects.FindId(detailId) :?> DocObjects.DetailViewObject
            with _ ->  RhinoScriptingException.Raise "RhinoScriptSyntax.DetailLock: Setting it failed. detailId is a %s  lock:'%A'" (Nice.str detailId)  lock
        if lock <> detail.DetailGeometry.IsProjectionLocked then
            detail.DetailGeometry.IsProjectionLocked <- lock
            detail.CommitChanges() |> ignore



    ///<summary>Returns the scale of a detail object.</summary>
    ///<param name="detailId">(Guid) Identifier of a detail object</param>
    ///<returns>(float) current page to model scale ratio if model Length and page Length are both None.</returns>
    static member DetailScale(detailId:Guid) : float = //GET
        let detail = RhinoScriptSyntax.CoerceDetailViewObject(detailId)
        detail.DetailGeometry.PageToModelRatio

    ///<summary>Modifies the scale of a detail object.</summary>
    ///<param name="detailId">(Guid) Identifier of a detail object</param>
    ///<param name="modelLength">(float) A length in the current model units</param>
    ///<param name="pageLength">(float) A length in the current page units</param>
    ///<returns>(unit) void, nothing.</returns>
    static member DetailScale(detailId:Guid, modelLength:float, pageLength:float) : unit = //SET
        let detail = RhinoScriptSyntax.CoerceDetailViewObject(detailId)
        let modelUnits = State.Doc.ModelUnitSystem
        let pageUnits = State.Doc.PageUnitSystem
        if detail.DetailGeometry.SetScale(modelLength, modelUnits, pageLength, pageUnits) then
            detail.CommitChanges() |> ignore
            State.Doc.Views.Redraw()
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.DetailScale failed.  detailId:'%s' modelLength:'%A' pageLength:'%A'" (Nice.str detailId) modelLength pageLength



    ///<summary>Checks if a detail view exists on a page layout view.</summary>
    ///<param name="layout">(string) Title of an existing page layout</param>
    ///<param name="detail">(string) Title of an existing detail view</param>
    ///<returns>(bool) True if detail is a detail view, False if detail is not a detail view.</returns>
    static member IsDetail(layout:string, detail:string) : bool =
        let view = RhinoScriptSyntax.CoercePageView(layout)
        let det = RhinoScriptSyntax.CoerceView(detail)
        view.GetDetailViews()
        |> Array.exists (fun v -> v.Name = det.ActiveViewport.Name) // TODO test


    ///<summary>Checks if a view is a page layout view.</summary>
    ///<param name="layout">(string) Title of an existing page layout view</param>
    ///<returns>(bool) True if layout is a page layout view, False is layout is a standard model view.</returns>
    static member IsLayout(layout:string) : bool =
        if   State.Doc.Views.GetViewList(includeStandardViews=false,includePageViews=true) |> Array.exists (fun v -> v.MainViewport.Name = layout) then
            true
        elif State.Doc.Views.GetViewList(includeStandardViews=true ,includePageViews=false) |> Array.exists (fun v -> v.MainViewport.Name = layout) then
            false
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.IsLayout View does not exist at all.  layout:'%A'" layout // or false


    ///<summary>Checks if the specified view exists.</summary>
    ///<param name="view">(string) Title of the view</param>
    ///<returns>(bool) True of False indicating success or failure.</returns>
    static member IsView(view:string) : bool =
        State.Doc.Views.GetViewList(includeStandardViews=false, includePageViews=true) |> Array.exists ( fun v -> v.MainViewport.Name = view)



    ///<summary>Checks if the specified view is the current, or active view.</summary>
    ///<param name="view">(string) Title of the view</param>
    ///<returns>(bool) True of False indicating success or failure.</returns>
    static member IsViewCurrent(view:string) : bool =
        let activeView = State.Doc.Views.ActiveView
        view = activeView.MainViewport.Name


    ///<summary>Checks if the specified view is maximized (enlarged so as to fill
    ///    the entire Rhino window).</summary>
    ///<param name="view">(string) Optional, Title of the view. If omitted, the current
    ///    view is used</param>
    ///<returns>(bool) True of False.</returns>
    static member IsViewMaximized([<OPT;DEF("")>]view:string) : bool =
        let view = RhinoScriptSyntax.CoerceView(view)
        view.Maximized


    ///<summary>Checks if the specified view's projection is set to perspective.</summary>
    ///<param name="view">(string) Title of the view</param>
    ///<returns>(bool) True of False.</returns>
    static member IsViewPerspective(view:string) : bool =
        let view = RhinoScriptSyntax.CoerceView(view)
        view.MainViewport.IsPerspectiveProjection


    ///<summary>Checks if the specified view's title window is visible.</summary>
    ///<param name="view">(string) Optional, The title of the view. If omitted, the current
    ///    active view is used</param>
    ///<returns>(bool) True of False.</returns>
    static member IsViewTitleVisible([<OPT;DEF("")>]view:string) : bool =
        let view = RhinoScriptSyntax.CoerceView(view)
        view.TitleVisible


    ///<summary>Checks if the specified view contains a wallpaper image.</summary>
    ///<param name="view">(string) View to verify</param>
    ///<returns>(bool) True or False.</returns>
    static member IsWallpaper(view:string) : bool =
        let view = RhinoScriptSyntax.CoerceView(view)
        view.MainViewport.WallpaperFilename.Length > 0


    ///<summary>Toggles a view's maximized/restore window state of the specified view.</summary>
    ///<param name="view">(string) Optional, The title of the view. If omitted, the current
    ///    active view is used</param>
    ///<returns>(unit).</returns>
    static member MaximizeRestoreView([<OPT;DEF("")>]view:string) : unit =
        let view = RhinoScriptSyntax.CoerceView(view)
        view.Maximized <- not view.Maximized


    ///<summary>Returns the Plane geometry of the specified named construction Plane.</summary>
    ///<param name="name">(string) The name of the construction Plane</param>
    ///<returns>(Plane) a Plane.</returns>
    static member NamedCPlane(name:string) : Plane =
        let index = State.Doc.NamedConstructionPlanes.Find(name)
        if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.NamedCPlane failed.  name:'%A'" name
        State.Doc.NamedConstructionPlanes.[index].Plane


    ///<summary>Returns the names of all named construction Planes in the document.</summary>
    ///<returns>(string ResizeArray) The names of all named construction Planes in the document.</returns>
    static member NamedCPlanes() : string ResizeArray =
        let count = State.Doc.NamedConstructionPlanes.Count
        resizeArray {for i = 0 to count - 1 do State.Doc.NamedConstructionPlanes.[i].Name }



    ///<summary>Returns the names of all named views in the document.</summary>
    ///<returns>(string ResizeArray) The names of all named views in the document.</returns>
    static member NamedViews() : string ResizeArray =
        let count = State.Doc.NamedViews.Count
        resizeArray {for i = 0 to count - 1 do State.Doc.NamedViews.[i].Name }


    ///<summary>Changes the title of the specified view.</summary>
    ///<param name="oldTitle">(string) The title of the view to rename</param>
    ///<param name="newTitle">(string) The new title of the view</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RenameView(oldTitle:string, newTitle:string) : unit =
        if isNull oldTitle || isNull newTitle then RhinoScriptingException.Raise "RhinoScriptSyntax.RenameView failed.  oldTitle:'%A' newTitle:'%A'" oldTitle newTitle
        let foundview = RhinoScriptSyntax.CoerceView(oldTitle)
        foundview.MainViewport.Name <- newTitle



    ///<summary>Restores a named construction Plane to the specified view.</summary>
    ///<param name="cplaneName">(string) Name of the construction Plane to restore</param>
    ///<param name="view">(string) Optional, The title of the view. If omitted, the current
    ///    active view is used</param>
    ///<returns>(string) name of the restored named construction Plane.</returns>
    static member RestoreNamedCPlane(cplaneName:string, [<OPT;DEF("")>]view:string) : string =
        let view = RhinoScriptSyntax.CoerceView(view)
        let index = State.Doc.NamedConstructionPlanes.Find(cplaneName)
        if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.RestoreNamedCPlane failed.  cplaneName:'%A' view:'%A'" cplaneName view
        let cplane = State.Doc.NamedConstructionPlanes.[index]
        view.MainViewport.PushConstructionPlane(cplane)
        view.Redraw()
        cplaneName


    ///<summary>Restores a named view to the specified view.</summary>
    ///<param name="namedView">(string) Name of the named view to restore</param>
    ///<param name="view">(string) Optional, Title of the view to restore the named view.
    ///    If omitted, the current active view is used</param>
    ///<param name="restoreBitmap">(bool) Optional, default value: <c>false</c>
    ///    Restore the named view's background bitmap</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RestoreNamedView( namedView:string,
                                    [<OPT;DEF("")>]view:string,
                                    [<OPT;DEF(false)>]restoreBitmap:bool) : unit =
        let view = RhinoScriptSyntax.CoerceView(view)
        let index = State.Doc.NamedViews.FindByName(namedView)
        if index<0 then RhinoScriptingException.Raise "RhinoScriptSyntax.RestoreNamedView failed.  namedView:'%A' view:'%A' restoreBitmap:'%A'" namedView view restoreBitmap
        let viewinfo = State.Doc.NamedViews.[index]
        if view.MainViewport.PushViewInfo(viewinfo, restoreBitmap) then
            view.Redraw()
            //view.MainViewport.Name
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.RestoreNamedView failed.  namedView:'%A' view:'%A' restoreBitmap:'%A'" namedView view restoreBitmap


    ///<summary>Rotates a perspective-projection view's camera. See the RotateCamera
    ///    command in the Rhino help file for more details.</summary>
    ///<param name="direction">(int)
    ///    The direction to rotate the camera where
    ///    0 = right
    ///    1 = left
    ///    2 = down
    ///    3 = up</param>
    ///<param name="angle">(float) The angle to rotate</param>
    ///<param name="view">(string) Optional, Title of the view. If omitted, current active view is used</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RotateCamera( direction:int,
                                angle:float,
                                [<OPT;DEF("")>]view:string) : unit =
        let view = RhinoScriptSyntax.CoerceView(view)
        let viewport = view.ActiveViewport
        let mutable angle = RhinoMath.ToRadians( abs(angle))
        let targetdistance = (viewport.CameraLocation-viewport.CameraTarget)*viewport.CameraZ
        let mutable axis = viewport.CameraY
        if direction = 0 || direction = 2 then angle <- -angle
        if direction = 0 || direction = 1 then
            if ApplicationSettings.ViewSettings.RotateToView then
                axis <- viewport.CameraY
            else
                axis <- Vector3d.ZAxis
        elif direction = 2 || direction = 3 then
            axis <- viewport.CameraX

        if ApplicationSettings.ViewSettings.RotateReverseKeyboard then angle<- -angle
        let rot = Transform.Rotation(angle, axis, Point3d.Origin)
        let camUp = rot * viewport.CameraY
        let camDir = -(rot * viewport.CameraZ)
        let target = viewport.CameraLocation + targetdistance*camDir
        viewport.SetCameraLocations(target, viewport.CameraLocation)
        viewport.CameraUp <- camUp
        view.Redraw()



    ///<summary>Rotates a view. See RotateView command in Rhino help for more information.</summary>
    ///<param name="direction">(int) Optional, The direction to rotate the view where
    ///    0 = right
    ///    1 = left
    ///    2 = down
    ///    3 = up</param>
    ///<param name="angle">(float) Angle to rotate. If omitted, the angle of rotation is specified
    ///    by the "Increment in divisions of a circle" parameter specified in
    ///    Options command's View tab</param>
    ///<param name="view">(string) Optional, Title of the view. If omitted, the current active view is used</param>
    ///<returns>(unit) void, nothing.</returns>
    static member RotateView( direction:int,
                              angle:float,
                              [<OPT;DEF("")>]view:string) : unit =
        let view = RhinoScriptSyntax.CoerceView(view)
        let viewport = view.ActiveViewport
        let mutable angle =  RhinoMath.ToRadians( abs(angle))
        if ApplicationSettings.ViewSettings.RotateReverseKeyboard then angle <- -angle
        if direction = 0 then viewport.KeyboardRotate(true, angle)       |> ignore
        elif direction = 1 then viewport.KeyboardRotate(true, -angle)    |> ignore
        elif direction = 2 then viewport.KeyboardRotate(false, -angle)   |> ignore
        elif direction = 3 then viewport.KeyboardRotate(false, angle)    |> ignore
        view.Redraw()


    ///<summary>Get status of a view's construction Plane grid.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<returns>(bool) The grid display state.</returns>
    static member ShowGrid(view:string) : bool = //GET
        let view = RhinoScriptSyntax.CoerceView(view)
        let viewport = view.ActiveViewport
        viewport.ConstructionGridVisible

    ///<summary>Shows or hides a view's construction Plane grid.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<param name="show">(bool) The grid state to set</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ShowGrid(view:string, show:bool) : unit = //SET
        let view = RhinoScriptSyntax.CoerceView(view)
        let viewport = view.ActiveViewport
        let rc = viewport.ConstructionGridVisible
        if  rc <> show then
            viewport.ConstructionGridVisible <- show
            view.Redraw()



    ///<summary>Get status of a view's construction Plane grid axes.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<returns>(bool) The grid axes display state.</returns>
    static member ShowGridAxes(view:string) : bool = //GET
        let view = RhinoScriptSyntax.CoerceView(view)
        let viewport = view.ActiveViewport
        let rc = viewport.ConstructionAxesVisible
        rc

    ///<summary>Shows or hides a view's construction Plane grid axes.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<param name="show">(bool) The state to set</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ShowGridAxes(view:string, show:bool) : unit = //SET
        let view = RhinoScriptSyntax.CoerceView(view)
        let viewport = view.ActiveViewport
        let rc = viewport.ConstructionAxesVisible
        if  rc <> show then
            viewport.ConstructionAxesVisible <- show
            view.Redraw()



    ///<summary>Get status of the title window of a view.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<returns>(bool) The state to View Title visibility.</returns>
    static member ShowViewTitle(view:string) : bool = //GET
        let view = RhinoScriptSyntax.CoerceView(view)
        view.TitleVisible

    ///<summary>Shows or hides the title window of a view.</summary>
    ///<param name="view">(string) Title of the view. If omitted, the current active view is used</param>
    ///<param name="show">(bool) The state to set</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ShowViewTitle(view:string, show:bool) : unit = //SET
        let view = RhinoScriptSyntax.CoerceView(view)
        view.TitleVisible <- show


    ///<summary>Get status of a view's world axis icon.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<returns>(bool) The world axes display state.</returns>
    static member ShowWorldAxes(view:string) : bool = //GET
        let view = RhinoScriptSyntax.CoerceView(view)
        let viewport = view.ActiveViewport
        let rc = viewport.WorldAxesVisible
        rc

    ///<summary>Shows or hides a view's world axis icon.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<param name="show">(bool) The state to set</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ShowWorldAxes(view:string, show:bool) : unit = //SET
        let view = RhinoScriptSyntax.CoerceView(view)
        let viewport = view.ActiveViewport
        let rc = viewport.WorldAxesVisible
        if rc <> show then
            viewport.WorldAxesVisible <- show
            view.Redraw()



    ///<summary>Tilts a view by rotating the camera up vector. See the TiltView command in
    ///    the Rhino help file for more details.</summary>
    ///<param name="direction">(int) The direction to rotate the view where
    ///    0 = right
    ///    1 = left</param>
    ///<param name="angle">(float) The angle in degrees to rotate</param>
    ///<param name="view">(string) Optional, Title of the view. If omitted, the current active view is used</param>
    ///<returns>(unit) void, nothing.</returns>
    static member TiltView( direction:int,
                            angle:float,
                            [<OPT;DEF("")>]view:string) : unit =
        let view = RhinoScriptSyntax.CoerceView(view)
        let viewport = view.ActiveViewport
        let mutable angle = angle
        if ApplicationSettings.ViewSettings.RotateReverseKeyboard then angle <- -angle
        let axis = viewport.CameraLocation - viewport.CameraTarget
        if direction = 0 then viewport.Rotate(angle, axis, viewport.CameraLocation) |> ignore
        elif direction = 1 then viewport.Rotate(-angle, axis, viewport.CameraLocation)   |> ignore
        view.Redraw()



    ///<summary>Returns the camera location of the specified view.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<returns>(Point3d) The current camera location.</returns>
    static member ViewCamera(view:string) : Point3d = //GET
        let view = RhinoScriptSyntax.CoerceView(view)
        view.ActiveViewport.CameraLocation

    ///<summary>Sets the camera location of the specified view.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<param name="cameraLocation">(Point3d) A 3D point identifying the new camera location</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ViewCamera(view:string, cameraLocation:Point3d) : unit = //SET
        let view = RhinoScriptSyntax.CoerceView(view)
        view.ActiveViewport.SetCameraLocation(cameraLocation, true)
        view.Redraw()



    ///<summary>Returns the 35mm camera lens length of the specified perspective
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    /// projection view.</summary>
    ///<returns>(float) The current lens length.</returns>
    static member ViewCameraLens(view:string) : float = //GET
        let view = RhinoScriptSyntax.CoerceView(view)
        view.ActiveViewport.Camera35mmLensLength

    ///<summary>Sets the 35mm camera lens length of the specified perspective
    /// projection view.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<param name="length">(float) The new 35mm camera lens length</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ViewCameraLens(view:string, length:float) : unit = //SET
        let view = RhinoScriptSyntax.CoerceView(view)
        view.ActiveViewport.Camera35mmLensLength <- length
        view.Redraw()



    ///<summary>Returns the orientation of a view's camera.</summary>
    ///<param name="view">(string) Optional, Title of the view. If omitted, the current active view is used</param>
    ///<returns>(Plane) The view's camera Plane.</returns>
    static member ViewCameraPlane([<OPT;DEF("")>]view:string) : Plane =
        let view = RhinoScriptSyntax.CoerceView(view)
        let rc, frame = view.ActiveViewport.GetCameraFrame()
        if not rc then RhinoScriptingException.Raise "RhinoScriptSyntax.ViewCameraPlane failed.  view:'%A'" view
        frame


    ///<summary>Returns the camera and target positions of the specified view.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<returns>(Point3d * Point3d) The 3d points containing the current camera and target locations.</returns>
    static member ViewCameraTarget(view:string) : Point3d * Point3d = //GET
        let view = RhinoScriptSyntax.CoerceView(view)
        view.ActiveViewport.CameraLocation, view.ActiveViewport.CameraTarget

    ///<summary>Sets the camera and target positions of the specified view.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<param name="camera">(Point3d) 3d point identifying the new camera location</param>
    ///<param name="target">(Point3d) 3d point identifying the new target location</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ViewCameraTarget(view:string, camera:Point3d, target:Point3d) : unit = //SET
        let view = RhinoScriptSyntax.CoerceView(view)
        view.ActiveViewport.SetCameraLocations(target, camera)
        view.Redraw()


    ///<summary>Returns the camera up direction of a specified.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<returns>(Vector3d) The current camera up direction.</returns>
    static member ViewCameraUp(view:string) : Vector3d = //GET
        let view = RhinoScriptSyntax.CoerceView(view)
        view.ActiveViewport.CameraUp

    ///<summary>Sets the camera up direction of a specified.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<param name="upVector">(Vector3d) 3D vector identifying the new camera up direction</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ViewCameraUp(view:string, upVector:Vector3d) : unit = //SET
        let view = RhinoScriptSyntax.CoerceView(view)
        view.ActiveViewport.CameraUp <- upVector
        view.Redraw()



    ///<summary>Return a view's construction Plane.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<returns>(Plane) The current construction Plane.</returns>
    static member ViewCPlane(view:string) : Plane = //GET
        let view = RhinoScriptSyntax.CoerceView(view)
        view.ActiveViewport.ConstructionPlane()

    ///<summary>Set a view's construction Plane.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<param name="plane">(Plane) The new construction Plane if setting</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ViewCPlane(view:string, plane:Plane) : unit = //SET
        let view = RhinoScriptSyntax.CoerceView(view)
        view.ActiveViewport.SetConstructionPlane(plane)
        view.Redraw()



    ///<summary>Return a view display mode.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<returns>(string) The current mode.</returns>
    static member ViewDisplayMode(view:string) : string = //GET
        let view = RhinoScriptSyntax.CoerceView(view)
        let current = view.ActiveViewport.DisplayMode
        current.EnglishName

    ///<summary>Set a view display mode.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<param name="mode">(string) Name of a display mode</param>
    ///<returns>(string) If mode is not specified, the current mode.</returns>
    static member ViewDisplayMode(view:string, mode:string) : unit = //SET
        let view = RhinoScriptSyntax.CoerceView(view)
        let desc = Display.DisplayModeDescription.FindByName(mode)
        if notNull desc then
            view.ActiveViewport.DisplayMode <- desc
            State.Doc.Views.Redraw()
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.ViewDisplayMode set mode %s not found." mode



    ///<summary>Return id of a display mode given it's name.</summary>
    ///<param name="name">(string) Name of the display mode</param>
    ///<returns>(Guid) The id of the display mode.</returns>
    static member ViewDisplayModeId(name:string) : Guid =
        let desc = Display.DisplayModeDescription.FindByName(name)
        if notNull desc then desc.Id
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.ViewDisplayModeId set mode %s not found." name


    ///<summary>Return name of a display mode given it's id.</summary>
    ///<param name="modeId">(Guid) The identifier of the display mode obtained from the ViewDisplayModes method</param>
    ///<returns>(string) The name of the display mode.</returns>
    static member ViewDisplayModeName(modeId:Guid) : string =
        let desc = Display.DisplayModeDescription.GetDisplayMode(modeId)
        if notNull desc then desc.EnglishName
        else
            RhinoScriptingException.Raise "RhinoScriptSyntax.ViewDisplayModeName set Id %A not found." modeId


    ///<summary>Return list of display modes.</summary>
    ///<returns>(string ResizeArray) strings identifying the display mode names.</returns>
    static member ViewDisplayModes() : string ResizeArray =
        let modes = Display.DisplayModeDescription.GetDisplayModes()
        resizeArray {for mode in modes do mode.EnglishName }


    ///<summary>Return the names/titles, of all views in the document.</summary>
    ///<param name="viewType">(int) Optional, default value: <c>0</c>. The standard model views.
    ///    The type of view to return
    ///    0 = standard model views
    ///    1 = page layout views
    ///    2 = both standard and page layout views</param>
    ///<returns>(string ResizeArray) List of the view names.</returns>
    static member ViewNames([<OPT;DEF(0)>]viewType:int) : string ResizeArray =
        let views = State.Doc.Views.GetViewList(viewType <> 1, viewType>0)
        if views|> isNull  then RhinoScriptingException.Raise "RhinoScriptSyntax.ViewNames failed. viewType:'%A'" viewType
        resizeArray { for view in views do view.MainViewport.Name}



    ///<summary>Return 3d corners of a view's near clipping Plane rectangle. Useful
    ///    in determining the "real world" size of a parallel-projected view.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<returns>(Point3d * Point3d * Point3d * Point3d) Four Point3d that define the corners of the rectangle (counter-clockwise order).</returns>
    static member ViewNearCorners([<OPT;DEF("")>]view:string) : Point3d * Point3d * Point3d * Point3d =
        let view = RhinoScriptSyntax.CoerceView(view)
        let rc = view.ActiveViewport.GetNearRect()
        rc.[0], rc.[1], rc.[3], rc.[2]


    ///<summary>Return a view's projection mode.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<returns>(int) The current projection mode for the specified view
    ///    1 = parallel
    ///    2 = perspective
    ///    3 = two point perspective.</returns>
    static member ViewProjection(view:string) : int = //GET
        let view = RhinoScriptSyntax.CoerceView(view)
        let viewport = view.ActiveViewport
        let mutable rc = 2
        if viewport.IsParallelProjection then rc <- 1
        elif viewport.IsTwoPointPerspectiveProjection then rc <- 3
        rc

    ///<summary>Set a view's projection mode.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<param name="mode">(int) The projection mode
    ///    1 = parallel
    ///    2 = perspective
    ///    3 = two point perspective</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ViewProjection(view:string, mode:int) : unit = //SET
        let view = RhinoScriptSyntax.CoerceView(view)
        let viewport = view.ActiveViewport
        if mode = 1 then viewport.ChangeToParallelProjection(true) |> ignore
        elif mode = 2 then viewport.ChangeToPerspectiveProjection(true, 35.)|> ignore
        elif mode = 3 then viewport.ChangeToTwoPointPerspectiveProjection(35.)       |> ignore
        view.Redraw()



    ///<summary>Returns the radius of a parallel-projected view. Useful
    /// when you need an absolute zoom factor for a parallel-projected view.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<returns>(float) The current view radius for the specified view.</returns>
    static member ViewRadius(view:string) : float = //GET
        let view = RhinoScriptSyntax.CoerceView(view)
        let viewport = view.ActiveViewport
        if not viewport.IsParallelProjection then RhinoScriptingException.Raise "RhinoScriptSyntax.ViewRadius view is not ParallelProjection.  view:'%A'" view
        // let ok, a, b, c, d, e, f = viewport.GetFrustum()
        let _, _, b, _, d, _, _ = viewport.GetFrustum()
        let frusright = b
        let frustop = d
        let oldradius = min frustop frusright
        oldradius

    ///<summary>Sets the radius of a parallel-projected view. Useful
    /// when you need an absolute zoom factor for a parallel-projected view.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<param name="radius">(float) The view radius</param>
    ///<param name="mode">(bool) Perform a "dolly" magnification by moving the camera
    ///    towards/away from the target so that the amount of the screen
    ///    subtended by an object changes. true = perform a "zoom"
    ///    magnification by adjusting the "lens" angle</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ViewRadius(view:string, radius:float, mode:bool) : unit = //SET
        let view = RhinoScriptSyntax.CoerceView(view)
        let viewport = view.ActiveViewport
        if not viewport.IsParallelProjection then RhinoScriptingException.Raise "RhinoScriptSyntax.ViewRadius view is not ParallelProjection.  view:'%A'" view
        // let ok, a, b, c, d, e, f = viewport.GetFrustum()
        let _, _, b, _, d, _, _ = viewport.GetFrustum()
        let frusright = b
        let frustop = d
        let oldradius = min frustop frusright
        let magnificationfactor = radius / oldradius
        let d = 1.0 / magnificationfactor
        viewport.Magnify(d, mode) |> ignore
        view.Redraw()



    ///<summary>Returns the width and height in pixels of the specified view.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<returns>(int * int ) of two numbers identifying width and height.</returns>
    static member ViewSize([<OPT;DEF(null:string)>]view:string) : int * int =
        let view = RhinoScriptSyntax.CoerceView(view)
        let cr = view.ClientRectangle
        cr.Width, cr.Height


    ///<summary>Test's Rhino's display performance.</summary>
    ///<param name="view">(string) Optional, The title of the view. If omitted, the current active view is used</param>
    ///<param name="frames">(int) Optional, default value: <c>100</c>
    ///    The number of frames, or times to regenerate the view. If omitted, the view will be regenerated 100 times</param>
    ///<param name="freeze">(bool) Optional, default value: <c>true</c>
    ///    If True (Default), then Rhino's display list will not be updated with every frame redraw. If False, then Rhino's display list will be updated with every frame redraw</param>
    ///<param name="direction">(int) Optional, default value: <c>0</c>
    ///    The direction to rotate the view. The default direction is Right (0). Modes:
    ///    0 = Right
    ///    1 = Left
    ///    2 = Down
    ///    3 = Up</param>
    ///<param name="angleDegrees">(float) Optional, default value: <c>5</c>
    ///    The angle to rotate. If omitted, the rotation angle of 5.0 degrees will be used</param>
    ///<returns>(float) The number of seconds it took to regenerate the view frames number of times.</returns>
    static member ViewSpeedTest( [<OPT;DEF("")>]view:string,
                                 [<OPT;DEF(100)>]frames:int,
                                 [<OPT;DEF(true)>]freeze:bool,
                                 [<OPT;DEF(0)>]direction:int,
                                 [<OPT;DEF(5.0)>]angleDegrees:float) : float =
        let view = RhinoScriptSyntax.CoerceView(view)
        let angleradians = toRadians(angleDegrees)
        view.SpeedTest(frames, freeze, direction, angleradians)


    ///<summary>Returns the target location of the specified view.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<returns>(Point3d) The current target location.</returns>
    static member ViewTarget(view:string) : Point3d = //GET
        let view = RhinoScriptSyntax.CoerceView(view)
        let viewport = view.ActiveViewport
        viewport.CameraTarget

    ///<summary>Sets the target location of the specified view.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<param name="target">(Point3d) 3d point identifying the new target location</param>
    ///<returns>(unit) void, nothing.</returns>
    static member ViewTarget(view:string, target:Point3d) : unit = //SET
        let view = RhinoScriptSyntax.CoerceView(view)
        let viewport = view.ActiveViewport
        viewport.SetCameraTarget(target, true)
        view.Redraw()



    ///<summary>Returns the name, or title, of a given view's identifier.</summary>
    ///<param name="viewId">(Guid) The identifier of the view</param>
    ///<returns>(string) name or title of the view.</returns>
    static member ViewTitle(viewId:Guid) : string =
        let view = RhinoScriptSyntax.CoerceView(viewId)
        view.MainViewport.Name


    ///<summary>Returns the wallpaper bitmap of the specified view. To remove a
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    /// wallpaper bitmap, pass an empty string "".</summary>
    ///<returns>(string option) The current wallpaper bitmap filename. Or an empty string if none found.</returns>
    static member Wallpaper(view:string) : string= //GET
        let view = RhinoScriptSyntax.CoerceView(view)
        let f= view.ActiveViewport.WallpaperFilename
        if isNull f then "" else f

    ///<summary>Sets the wallpaper bitmap of the specified view. To remove a
    /// wallpaper bitmap, pass an empty string "".</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<param name="filename">(string) Name of the bitmap file to set as wallpaper</param>
    ///<returns>(unit) void, nothing.</returns>
    static member Wallpaper(view:string, filename:string) : unit = //SET
        let viewo = RhinoScriptSyntax.CoerceView(view)
        if not <| viewo.ActiveViewport.SetWallpaper(filename, grayscale=false) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.Wallpaper failed to set wallpaper to %s in view %s" filename view
        viewo.Redraw()


    ///<summary>Returns the gray-scale display option of the wallpaper bitmap in a
    /// specified view.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<returns>(bool) The current gray-scale display option.</returns>
    static member WallpaperGrayScale(view:string) : bool = //GET
        let view = RhinoScriptSyntax.CoerceView(view)
        view.ActiveViewport.WallpaperGrayscale

    ///<summary>Sets the gray-scale display option of the wallpaper bitmap in a
    /// specified view.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<param name="grayscale">(bool) Display the wallpaper in gray(True) or color (False)</param>
    ///<returns>(unit) void, nothing.</returns>
    static member WallpaperGrayScale(view:string, grayscale:bool) : unit = //SET
        let viewo = RhinoScriptSyntax.CoerceView(view)
        let filename = viewo.ActiveViewport.WallpaperFilename
        if not <| viewo.ActiveViewport.SetWallpaper(filename, grayscale) then
            RhinoScriptingException.Raise "RhinoScriptSyntax.WallpaperGrayScale failed to set wallpaper to %s in view %s" filename view
        viewo.Redraw()



    ///<summary>Returns the visibility of the wallpaper bitmap in a specified view.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<returns>(bool) The current hidden state.</returns>
    static member WallpaperHidden(view:string) : bool = //GET
        let view = RhinoScriptSyntax.CoerceView(view)
        not view.ActiveViewport.WallpaperVisible


    ///<summary>Sets the visibility of the wallpaper bitmap in a specified view.</summary>
    ///<param name="view">(string) Title of the view. Use "" empty string for the current active view</param>
    ///<param name="hidden">(bool) Show or hide the wallpaper</param>
    ///<returns>(unit) void, nothing.</returns>
    static member WallpaperHidden(view:string, hidden:bool) : unit = //SET
        let view = RhinoScriptSyntax.CoerceView(view)
        let filename = view.ActiveViewport.WallpaperFilename
        let gray = view.ActiveViewport.WallpaperGrayscale
        view.ActiveViewport.SetWallpaper(filename, gray, not hidden) |> ignore
        view.Redraw()



    ///<summary>Zooms to the extents of a specified bounding box in the specified view.</summary>
    ///<param name="boundingBox">(Geometry.BoundingBox) a BoundingBox class instance</param>
    ///<param name="view">(string) Optional, Title of the view. If omitted, current active view is used</param>
    ///<param name="all">(bool) Optional, default value: <c>false</c>
    ///    Zoom extents in all views</param>
    ///<returns>(unit).</returns>
    static member ZoomBoundingBox( boundingBox:BoundingBox,
                                   [<OPT;DEF("")>]view:string,
                                   [<OPT;DEF(false)>]all:bool) : unit =
          if all then
              let views = State.Doc.Views.GetViewList(true, true)
              for view in views do view.ActiveViewport.ZoomBoundingBox(boundingBox) |> ignore
          else
              let view = RhinoScriptSyntax.CoerceView(view)
              view.ActiveViewport.ZoomBoundingBox(boundingBox) |> ignore
          State.Doc.Views.Redraw()


    ///<summary>Zooms to extents of visible objects in the specified view.</summary>
    ///<param name="view">(string) Optional, Title of the view. If omitted, current active view is used</param>
    ///<param name="all">(bool) Optional, default value: <c>false</c>
    ///    Zoom extents in all views</param>
    ///<returns>(unit).</returns>
    static member ZoomExtents([<OPT;DEF("")>]view:string, [<OPT;DEF(false)>]all:bool) : unit =
        if  all then
            let views = State.Doc.Views.GetViewList(true, true)
            for view in views do view.ActiveViewport.ZoomExtents()|> ignore
        else
            let view = RhinoScriptSyntax.CoerceView(view)
            view.ActiveViewport.ZoomExtents()|> ignore
        State.Doc.Views.Redraw()


    ///<summary>Zoom to extents of selected objects in a view.</summary>
    ///<param name="view">(string) Optional, Title of the view. If omitted, active view is used</param>
    ///<param name="all">(bool) Optional, default value: <c>false</c>
    ///    Zoom extents in all views</param>
    ///<returns>(unit).</returns>
    static member ZoomSelected([<OPT;DEF("")>]view:string, [<OPT;DEF(false)>]all:bool) : unit =
        if all then
            let views = State.Doc.Views.GetViewList(true, true)
            for view in views do view.ActiveViewport.ZoomExtentsSelected()|> ignore
        else
            let view = RhinoScriptSyntax.CoerceView(view)
            view.ActiveViewport.ZoomExtentsSelected()|> ignore
        State.Doc.Views.Redraw()


